{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Children, cloneElement, isValidElement } from \"react\";\nimport cn from \"classnames\";\nexport function TextIconSpacing(_a) {\n  var _b;\n  var className = _a.className,\n    propIcon = _a.icon,\n    _c = _a.children,\n    children = _c === void 0 ? null : _c,\n    _d = _a.stacked,\n    stacked = _d === void 0 ? false : _d,\n    _e = _a.iconAfter,\n    iconAfter = _e === void 0 ? false : _e,\n    _f = _a.flexReverse,\n    flexReverse = _f === void 0 ? false : _f,\n    _g = _a.forceIconWrap,\n    forceIconWrap = _g === void 0 ? false : _g,\n    _h = _a.beforeClassName,\n    beforeClassName = _h === void 0 ? \"rmd-icon--before\" : _h,\n    _j = _a.afterClassName,\n    afterClassName = _j === void 0 ? \"rmd-icon--after\" : _j,\n    _k = _a.aboveClassName,\n    aboveClassName = _k === void 0 ? \"rmd-icon--above\" : _k,\n    _l = _a.belowClassName,\n    belowClassName = _l === void 0 ? \"rmd-icon--below\" : _l;\n  if (!propIcon) {\n    return _jsx(_Fragment, {\n      children: children\n    });\n  }\n  var isAfter = flexReverse ? !iconAfter : iconAfter;\n  var baseClassName = cn((_b = {}, _b[beforeClassName] = !stacked && !isAfter, _b[afterClassName] = !stacked && isAfter, _b[aboveClassName] = stacked && !isAfter, _b[belowClassName] = stacked && isAfter, _b), className);\n  var iconEl = propIcon;\n  var content = children;\n  if (!forceIconWrap && isValidElement(propIcon)) {\n    var icon = Children.only(propIcon);\n    iconEl = cloneElement(icon, {\n      className: cn(baseClassName, icon.props.className)\n    });\n  } else if (propIcon) {\n    iconEl = _jsx(\"span\", __assign({\n      className: cn(\"rmd-text-icon-spacing\", baseClassName)\n    }, {\n      children: propIcon\n    }));\n  }\n  if (iconEl) {\n    content = _jsxs(_Fragment, {\n      children: [!iconAfter && iconEl, children, iconAfter && iconEl]\n    });\n  }\n  return _jsx(_Fragment, {\n    children: content\n  });\n}","map":{"version":3,"mappings":";;;;;;;;;;;AACA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,cAAc,QAAQ,OAAO;AAC9D,OAAOC,EAAE,MAAM,YAAY;AAiF3B,OAAM,SAAUC,eAAe,CAACC,EAYT;;MAXrBC,SAAS;IACHC,QAAQ;IACdC,gBAAe;IAAfC,QAAQ,mBAAG,IAAI;IACfC,eAAe;IAAfC,OAAO,mBAAG,KAAK;IACfC,iBAAiB;IAAjBC,SAAS,mBAAG,KAAK;IACjBC,mBAAmB;IAAnBC,WAAW,mBAAG,KAAK;IACnBC,qBAAqB;IAArBC,aAAa,mBAAG,KAAK;IACrBC,uBAAoC;IAApCC,eAAe,mBAAG,kBAAkB;IACpCC,sBAAkC;IAAlCC,cAAc,mBAAG,iBAAiB;IAClCC,sBAAkC;IAAlCC,cAAc,mBAAG,iBAAiB;IAClCC,sBAAkC;IAAlCC,cAAc,mBAAG,iBAAiB;EAElC,IAAI,CAAClB,QAAQ,EAAE;IACb,OAAOmB;MAAAjB,UAAGA;IAAQ,EAAI;;EAGxB,IAAMkB,OAAO,GAAGZ,WAAW,GAAG,CAACF,SAAS,GAAGA,SAAS;EACpD,IAAMe,aAAa,GAAGzB,EAAE,WAEpB0B,GAACV,eAAe,IAAG,CAACR,OAAO,IAAI,CAACgB,OAAO,EACvCE,GAACR,cAAc,IAAG,CAACV,OAAO,IAAIgB,OAAO,EACrCE,GAACN,cAAc,IAAGZ,OAAO,IAAI,CAACgB,OAAO,EACrCE,GAACJ,cAAc,IAAGd,OAAO,IAAIgB,OAAO,OAEtCrB,SAAS,CACV;EAED,IAAIwB,MAAM,GAAGvB,QAAQ;EACrB,IAAIwB,OAAO,GAAGtB,QAAQ;EACtB,IAAI,CAACQ,aAAa,IAAIf,cAAc,CAACK,QAAQ,CAAC,EAAE;IAC9C,IAAMyB,IAAI,GAAGhC,QAAQ,CAACiC,IAAI,CAAC1B,QAAQ,CAAC;IACpCuB,MAAM,GAAG7B,YAAY,CAAC+B,IAAI,EAAE;MAC1B1B,SAAS,EAAEH,EAAE,CAACyB,aAAa,EAAEI,IAAI,CAACE,KAAK,CAAC5B,SAAS;KAClD,CAAC;GACH,MAAM,IAAIC,QAAQ,EAAE;IACnBuB,MAAM,GACJJ;MAAMpB,SAAS,EAAEH,EAAE,CAAC,uBAAuB,EAAEyB,aAAa;IAAC;MAAAnB,UACxDF;IAAQ,GAEZ;;EAGH,IAAIuB,MAAM,EAAE;IACVC,OAAO,GACLI;MAAA1B,WACG,CAACI,SAAS,IAAIiB,MAAM,EACpBrB,QAAQ,EACRI,SAAS,IAAIiB,MAAM;IAAA,EAEvB;;EAGH,OAAOJ;IAAAjB,UAAGsB;EAAO,EAAI;AACvB","names":["Children","cloneElement","isValidElement","cn","TextIconSpacing","_a","className","propIcon","_c","children","_d","stacked","_e","iconAfter","_f","flexReverse","_g","forceIconWrap","_h","beforeClassName","_j","afterClassName","_k","aboveClassName","_l","belowClassName","_jsx","isAfter","baseClassName","_b","iconEl","content","icon","only","props","_jsxs"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/icon/src/TextIconSpacing.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport { Children, cloneElement, isValidElement } from \"react\";\nimport cn from \"classnames\";\n\nexport interface TextIconSpacingProps {\n  /**\n   * An optional className to apply to the surrounding `<span>` when the\n   * `forceIconWrap` prop is enabled or the icon is not a valid React Element.\n   * If the `forceIconWrap` prop is not enabled, it will be cloned into the icon\n   * instead.\n   */\n  className?: string;\n\n  /**\n   * An optional icon to display with a text button. This is invalid for icon\n   * buttons. If this is a single element, a new class name will be cloned into\n   * the element to get correct spacing so if you have a custom icon element,\n   * you **must** also pass that class name down. If you are using one of the\n   * react-md icon component packages, this is handled automatically.\n   *\n   * If this is not a valid react element, the icon will be wrapped in a\n   * `<span>` instead with the class names applied.\n   */\n  icon?: ReactElement | ReactNode;\n\n  /**\n   * Boolean if the icon should appear after the text instead of before.\n   */\n  iconAfter?: boolean;\n\n  /**\n   * The children to render before or after the provided icon. This is defaulted\n   * to `null` so that providing a `null` icon will correctly render without\n   * React crashing.\n   */\n  children?: ReactNode;\n\n  /**\n   * The class name to use for an icon that is placed before text.\n   */\n  beforeClassName?: string;\n\n  /**\n   * The class name to use for an icon that is placed after text.\n   */\n  afterClassName?: string;\n\n  /**\n   * The class name to use for an icon that is placed before above the text.\n   * This is used when the `stacked` prop is enabled and the `iconAfter` prop is\n   * disabled or omitted.\n   */\n  aboveClassName?: string;\n\n  /**\n   * The class name to use for an icon that is placed before above the text.\n   * This is used when the `stacked` prop is enabled and the `iconAfter` prop is\n   * enabled.\n   */\n  belowClassName?: string;\n\n  /**\n   * Boolean if the icon should be forced into a `<span>` with the class names\n   * applied instead of attempting to clone into the provided icon.\n   */\n  forceIconWrap?: boolean;\n\n  /**\n   * Boolean if the icon and text should be stacked instead of inline. Note:\n   * You'll normally want to update the container element to have\n   * `display: flex` and `flex-direction: column` for this to work.\n   */\n  stacked?: boolean;\n\n  /**\n   * Boolean if the icon and content are in a `column-reverse` or `row-reverse`\n   * `flex-direction`. This will swap the different classnames as needed.\n   *\n   * @remarks \\@since 2.5.0\n   */\n  flexReverse?: boolean;\n}\n\nexport function TextIconSpacing({\n  className,\n  icon: propIcon,\n  children = null,\n  stacked = false,\n  iconAfter = false,\n  flexReverse = false,\n  forceIconWrap = false,\n  beforeClassName = \"rmd-icon--before\",\n  afterClassName = \"rmd-icon--after\",\n  aboveClassName = \"rmd-icon--above\",\n  belowClassName = \"rmd-icon--below\",\n}: TextIconSpacingProps): ReactElement {\n  if (!propIcon) {\n    return <>{children}</>;\n  }\n\n  const isAfter = flexReverse ? !iconAfter : iconAfter;\n  const baseClassName = cn(\n    {\n      [beforeClassName]: !stacked && !isAfter,\n      [afterClassName]: !stacked && isAfter,\n      [aboveClassName]: stacked && !isAfter,\n      [belowClassName]: stacked && isAfter,\n    },\n    className\n  );\n\n  let iconEl = propIcon;\n  let content = children;\n  if (!forceIconWrap && isValidElement(propIcon)) {\n    const icon = Children.only(propIcon);\n    iconEl = cloneElement(icon, {\n      className: cn(baseClassName, icon.props.className),\n    });\n  } else if (propIcon) {\n    iconEl = (\n      <span className={cn(\"rmd-text-icon-spacing\", baseClassName)}>\n        {propIcon}\n      </span>\n    );\n  }\n\n  if (iconEl) {\n    content = (\n      <>\n        {!iconAfter && iconEl}\n        {children}\n        {iconAfter && iconEl}\n      </>\n    );\n  }\n\n  return <>{content}</>;\n}\n"]},"metadata":{},"sourceType":"module"}