{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { forwardRef } from \"react\";\nimport cn from \"classnames\";\nimport { useInteractionStates } from \"@react-md/states\";\nimport { bem } from \"@react-md/utils\";\nimport { Label } from \"../label/Label\";\nimport { useFocusState } from \"../useFocusState\";\nimport { ToggleContainer } from \"./ToggleContainer\";\nimport { InputToggleIcon } from \"./InputToggleIcon\";\nvar block = bem(\"rmd-toggle\");\nexport var InputToggle = forwardRef(function InputToggle(allProps, ref) {\n  var _a = allProps,\n    style = _a.style,\n    className = _a.className,\n    iconStyle = _a.iconStyle,\n    iconClassName = _a.iconClassName,\n    toggleStyle = _a.toggleStyle,\n    propToggleClassName = _a.toggleClassName,\n    inputStyle = _a.inputStyle,\n    inputClassName = _a.inputClassName,\n    icon = _a.icon,\n    propOnFocus = _a.onFocus,\n    propOnBlur = _a.onBlur,\n    _b = _a.error,\n    error = _b === void 0 ? false : _b,\n    _c = _a.inline,\n    inline = _c === void 0 ? false : _c,\n    _d = _a.stacked,\n    stacked = _d === void 0 ? false : _d,\n    _e = _a.disabled,\n    disabled = _e === void 0 ? false : _e,\n    label = _a.label,\n    labelStyle = _a.labelStyle,\n    labelClassName = _a.labelClassName,\n    labelDisabled = _a.labelDisabled,\n    _f = _a.iconAfter,\n    iconAfter = _f === void 0 ? false : _f,\n    _g = _a.disableIconOverlay,\n    disableIconOverlay = _g === void 0 ? false : _g,\n    disableRipple = _a.disableRipple,\n    disableProgrammaticRipple = _a.disableProgrammaticRipple,\n    rippleTimeout = _a.rippleTimeout,\n    rippleClassNames = _a.rippleClassNames,\n    children = _a.children,\n    indeterminate = _a.indeterminate,\n    props = __rest(_a, [\"style\", \"className\", \"iconStyle\", \"iconClassName\", \"toggleStyle\", \"toggleClassName\", \"inputStyle\", \"inputClassName\", \"icon\", \"onFocus\", \"onBlur\", \"error\", \"inline\", \"stacked\", \"disabled\", \"label\", \"labelStyle\", \"labelClassName\", \"labelDisabled\", \"iconAfter\", \"disableIconOverlay\", \"disableRipple\", \"disableProgrammaticRipple\", \"rippleTimeout\", \"rippleClassNames\", \"children\", \"indeterminate\"]);\n  var id = props.id,\n    type = props.type;\n  var _h = useInteractionStates({\n      handlers: props,\n      disabled: disabled,\n      className: propToggleClassName,\n      disableRipple: disableRipple,\n      disableProgrammaticRipple: disableProgrammaticRipple,\n      rippleTimeout: rippleTimeout,\n      rippleClassNames: rippleClassNames\n    }),\n    ripples = _h.ripples,\n    handlers = _h.handlers,\n    toggleClassName = _h.className;\n  var _j = __read(useFocusState({\n      onFocus: propOnFocus,\n      onBlur: propOnBlur\n    }), 3),\n    focused = _j[0],\n    onFocus = _j[1],\n    onBlur = _j[2];\n  var labelEl = _jsx(Label, __assign({\n    style: labelStyle,\n    className: labelClassName,\n    htmlFor: id,\n    error: error,\n    disabled: typeof labelDisabled === \"boolean\" ? labelDisabled : disabled\n  }, {\n    children: label\n  }));\n  return _jsxs(ToggleContainer, __assign({\n    style: style,\n    className: className,\n    inline: inline,\n    stacked: stacked\n  }, {\n    children: [iconAfter && labelEl, _jsxs(\"span\", __assign({\n      style: toggleStyle,\n      className: cn(block({\n        focused: focused,\n        disabled: disabled\n      }), toggleClassName)\n    }, {\n      children: [_jsx(\"input\", __assign({}, props, handlers, {\n        ref: ref,\n        style: inputStyle,\n        disabled: disabled,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        className: cn(block(\"input\"), inputClassName)\n      })), _jsx(InputToggleIcon, __assign({\n        circle: !disableIconOverlay && type === \"radio\",\n        disabled: disabled,\n        overlay: !disableIconOverlay,\n        indeterminate: indeterminate,\n        style: iconStyle,\n        className: iconClassName\n      }, {\n        children: icon\n      })), ripples, children]\n    })), !iconAfter && labelEl]\n  }));\n});","map":{"version":3,"mappings":"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","names":["forwardRef","cn","useInteractionStates","bem","Label","useFocusState","ToggleContainer","InputToggleIcon","block","InputToggle","allProps","ref","_a","style","className","iconStyle","iconClassName","toggleStyle","propToggleClassName","inputStyle","inputClassName","icon","propOnFocus","propOnBlur","_b","error","_c","inline","_d","stacked","_e","disabled","label","labelStyle","labelClassName","labelDisabled","_f","iconAfter","_g","disableIconOverlay","disableRipple","disableProgrammaticRipple","rippleTimeout","rippleClassNames","children","indeterminate","props","type","handlers","ripples","toggleClassName","onFocus","onBlur","focused","labelEl","_jsx","htmlFor","id","_jsxs","circle","overlay"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/toggle/InputToggle.tsx"],"sourcesContent":["import type { CSSProperties, InputHTMLAttributes, ReactNode } from \"react\";\nimport { forwardRef } from \"react\";\nimport cn from \"classnames\";\nimport type { InteractionStatesOptions } from \"@react-md/states\";\nimport { useInteractionStates } from \"@react-md/states\";\nimport { bem } from \"@react-md/utils\";\n\nimport { Label } from \"../label/Label\";\nimport { useFocusState } from \"../useFocusState\";\nimport { ToggleContainer } from \"./ToggleContainer\";\nimport { InputToggleIcon } from \"./InputToggleIcon\";\n\n/**\n * The props for a checkbox or radio input element.\n *\n * Note: The `readOnly` attribute is not valid for these input types since they\n * update the `checked` property while `readOnly` is specific to `value` itself.\n */\nexport interface InputToggleProps\n  extends Omit<InputHTMLAttributes<HTMLInputElement>, \"type\" | \"readOnly\">,\n    Pick<\n      InteractionStatesOptions,\n      | \"rippleTimeout\"\n      | \"disableRipple\"\n      | \"disableProgrammaticRipple\"\n      | \"disablePressedFallback\"\n      | \"rippleClassNames\"\n    > {\n  /**\n   * The id for the radio or checkbox. This is required for a11y and will be\n   * used as the `for` attribute if the `label` prop is provided.\n   */\n  id: string;\n\n  /**\n   * The icon to use for either a radio or a checkbox.\n   */\n  icon?: ReactNode;\n\n  /**\n   * An optional style to apply to the `<span>` surrounding the toggle icon.\n   */\n  iconStyle?: CSSProperties;\n\n  /**\n   * An optional className to apply to the `<span>` surrounding the toggle icon.\n   */\n  iconClassName?: string;\n\n  /**\n   * An optional style to apply to the toggle `<span>` element. The `style` prop\n   * will be applied to the container `<div>` element instead.\n   */\n  toggleStyle?: CSSProperties;\n\n  /**\n   * An optional className to apply to the toggle `<span>` element. The\n   * `className` prop will be applied to the container `<div>` element instead.\n   */\n  toggleClassName?: string;\n\n  /**\n   * An optional `style` to provide to the invisible `<input>` element that is\n   * used to toggle the checked state. This prop is only available since the\n   * `style` prop is passed to the container element, but you probably shouldn't\n   * really style this element anyways.\n   *\n   * @remarks \\@since 2.2.0\n   */\n  inputStyle?: CSSProperties;\n\n  /**\n   * An optional `className` to provide to the invisible `<input>` element that\n   * is used to toggle the checked state. This prop does not have many uses and\n   * is really just provided since the `className` is passed to the container\n   * element instead of the `<input>`. However, this can be used to update the\n   * icon styles if needed using the `:checked` state:\n   *\n   * ```scss\n   * .custom-toggle-icon {\n   *   // styles\n   * }\n   *\n   * .custom-input:checked + .custom-toggle-icon {\n   *   // custom checked styles\n   * }\n   * ```\n   *\n   * @remarks \\@since 2.2.0\n   */\n  inputClassName?: string;\n\n  /**\n   * Boolean if the icon's overlay should be disabled. The way the Checkbox and\n   * Radio input elements work is by applying different opacity to the\n   * `::before` and `::after` pseudo selectors and animating it. If you want to\n   * use a custom icon that is not a material-icon checkbox outline or radio\n   * button, you should probably enable this prop.\n   */\n  disableIconOverlay?: boolean;\n\n  /**\n   * Boolean if the input toggle is currently errored. This will update the\n   * label and the input to gain error colors.\n   */\n  error?: boolean;\n\n  /**\n   * Boolean if the container element should be rendered as `inline-flex`\n   * instead of `flex`.\n   */\n  inline?: boolean;\n\n  /**\n   * Boolean if the label should be stacked above/below the input toggle instead\n   * of inline.\n   */\n  stacked?: boolean;\n\n  /**\n   * An optional label to display with the input. If this prop is omitted, you\n   * **should** apply an `aria-label` or `aria-labelledby` for a11y.\n   */\n  label?: ReactNode;\n\n  /**\n   * An optional style to apply to the `<label>` when the `label` prop is used.\n   */\n  labelStyle?: CSSProperties;\n\n  /**\n   * An optional className to apply to the `<label>` when the `label` prop is\n   * used.\n   */\n  labelClassName?: string;\n\n  /**\n   * An optional boolean if the label should gain the disabled style. When this\n   * is `undefined`, the `disabled` prop will be used instead. This is really\n   * just useful when you want to disable the switch from being toggled while\n   * some async action is being called, but not changing styles during the wait.\n   */\n  labelDisabled?: boolean;\n\n  /**\n   * Boolean if the input toggle should appear after the label instead of\n   * before.\n   */\n  iconAfter?: boolean;\n\n  /**\n   * Optional content to render after the icon element.\n   */\n  children?: ReactNode;\n}\n\ntype Props = InputToggleProps &\n  ({ type: \"radio\" } | { type: \"checkbox\"; indeterminate?: boolean });\ntype CheckboxOrRadioProps = InputToggleProps & {\n  type: \"checkbox\" | \"radio\";\n  indeterminate?: boolean;\n};\n\nconst block = bem(\"rmd-toggle\");\n\nexport const InputToggle = forwardRef<HTMLInputElement, Props>(\n  function InputToggle(allProps, ref) {\n    const {\n      style,\n      className,\n      iconStyle,\n      iconClassName,\n      toggleStyle,\n      toggleClassName: propToggleClassName,\n      inputStyle,\n      inputClassName,\n      icon,\n      onFocus: propOnFocus,\n      onBlur: propOnBlur,\n      error = false,\n      inline = false,\n      stacked = false,\n      disabled = false,\n      label,\n      labelStyle,\n      labelClassName,\n      labelDisabled,\n      iconAfter = false,\n      disableIconOverlay = false,\n      disableRipple,\n      disableProgrammaticRipple,\n      rippleTimeout,\n      rippleClassNames,\n      children,\n      indeterminate,\n      ...props\n    } = allProps as CheckboxOrRadioProps;\n\n    const { id, type } = props;\n\n    const {\n      ripples,\n      handlers,\n      className: toggleClassName,\n    } = useInteractionStates({\n      handlers: props,\n      disabled,\n      className: propToggleClassName,\n      disableRipple,\n      disableProgrammaticRipple,\n      rippleTimeout,\n      rippleClassNames,\n    });\n    const [focused, onFocus, onBlur] = useFocusState({\n      onFocus: propOnFocus,\n      onBlur: propOnBlur,\n    });\n\n    const labelEl = (\n      <Label\n        style={labelStyle}\n        className={labelClassName}\n        htmlFor={id}\n        error={error}\n        disabled={typeof labelDisabled === \"boolean\" ? labelDisabled : disabled}\n      >\n        {label}\n      </Label>\n    );\n\n    return (\n      <ToggleContainer\n        style={style}\n        className={className}\n        inline={inline}\n        stacked={stacked}\n      >\n        {iconAfter && labelEl}\n        <span\n          style={toggleStyle}\n          className={cn(\n            block({\n              focused,\n              disabled,\n            }),\n            toggleClassName\n          )}\n        >\n          <input\n            {...props}\n            {...handlers}\n            ref={ref}\n            style={inputStyle}\n            disabled={disabled}\n            onFocus={onFocus}\n            onBlur={onBlur}\n            className={cn(block(\"input\"), inputClassName)}\n          />\n          <InputToggleIcon\n            circle={!disableIconOverlay && type === \"radio\"}\n            disabled={disabled}\n            overlay={!disableIconOverlay}\n            indeterminate={indeterminate}\n            style={iconStyle}\n            className={iconClassName}\n          >\n            {icon}\n          </InputToggleIcon>\n          {ripples}\n          {children}\n        </span>\n        {!iconAfter && labelEl}\n      </ToggleContainer>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}