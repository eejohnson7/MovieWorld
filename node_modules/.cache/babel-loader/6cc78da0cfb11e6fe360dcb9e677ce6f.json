{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useMemo } from \"react\";\nimport { loop } from \"../../loop\";\nimport { useKeyboardSearch } from \"../../search/useKeyboardSearch\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport { getKeyboardConfig, getStringifiedKeyConfig, transformKeys } from \"./utils\";\n/**\n * This is a low-level hook for providing custom keyboard movement based on key\n * configurations.  This normally shouldn't really be used externally since\n * you'll most likely want to use the \"presets\" of `useFocusMovement` and\n * `useActiveDescendantMovement` that implement the main movement types already\n * for you.\n *\n * The way this works is that it will general a list of mutable item refs that\n * should be applied to each DOM node for the corresponding `item` within the\n * `items` list. This list will change and regenerate itself each time the\n * `items` array changes so it'll always be in-sync with the DOM nodes. This\n * means that if you have some items that **should not be rendered**, they\n * should not be included within the items list. The main reason these item refs\n * are required is so that the `aria-activedescendant` movement can scroll the\n * new \"focused\" element into view if needed while the \"true\" focus movement can\n * trigger a `ref.current.focus()` on the new item as needed.\n *\n * Finally, this will create a keydown event handler that will merge in the\n * optionally provided `onKeyDown` prop and check if the pressed key should\n * trigger a custom keyboard movement event.  If it does, an `onChange` event\n * will be fired with the matching data and allows for custom movement with\n * `target.focus()` or updating the `aria-activedescendant` attribute as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useKeyboardMovement(_a) {\n  var onKeyDown = _a.onKeyDown,\n    incrementKeys = _a.incrementKeys,\n    decrementKeys = _a.decrementKeys,\n    jumpToFirstKeys = _a.jumpToFirstKeys,\n    jumpToLastKeys = _a.jumpToLastKeys,\n    _b = _a.stopPropagation,\n    stopPropagation = _b === void 0 ? true : _b,\n    onChange = _a.onChange,\n    items = _a.items,\n    resetTime = _a.resetTime,\n    findMatchIndex = _a.findMatchIndex,\n    focusedIndex = _a.focusedIndex,\n    _c = _a.loopable,\n    loopable = _c === void 0 ? true : _c,\n    _d = _a.searchable,\n    searchable = _d === void 0 ? true : _d,\n    _e = _a.valueKey,\n    valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e,\n    _f = _a.getItemValue,\n    getItemValue = _f === void 0 ? DEFAULT_GET_ITEM_VALUE : _f;\n  var keys = useMemo(function () {\n    return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(transformKeys(incrementKeys, \"increment\")), false), __read(transformKeys(decrementKeys, \"decrement\")), false), __read(transformKeys(jumpToFirstKeys, \"first\")), false), __read(transformKeys(jumpToLastKeys, \"last\")), false);\n  }, [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]);\n  var itemRefs = useMemo(function () {\n    return Array.from(items, function () {\n      return {\n        current: null\n      };\n    });\n  }, [items]);\n  var handleSearch = useKeyboardSearch({\n    items: items,\n    valueKey: valueKey,\n    getItemValue: getItemValue,\n    onChange: function (data) {\n      onChange(data, itemRefs);\n    },\n    searchIndex: focusedIndex,\n    resetTime: resetTime,\n    findMatchIndex: findMatchIndex\n  });\n  var handleKeyDown = useCallback(function (event) {\n    if (searchable) {\n      handleSearch(event);\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    var target = event.target;\n    var keyConfig = getKeyboardConfig(event, keys);\n    if (!keyConfig || !target) {\n      return;\n    }\n    // implementing custom behavior, so prevent default of scrolling or other\n    // things\n    event.preventDefault();\n    if (stopPropagation) {\n      event.stopPropagation();\n    }\n    var type = keyConfig.type;\n    var lastIndex = items.length - 1;\n    var index;\n    switch (type) {\n      case \"first\":\n        index = 0;\n        break;\n      case \"last\":\n        index = lastIndex;\n        break;\n      default:\n        index = loop({\n          value: focusedIndex,\n          max: lastIndex,\n          increment: type === \"increment\",\n          minmax: !loopable\n        });\n    }\n    if (index === focusedIndex) {\n      return;\n    }\n    var data = {\n      index: index,\n      item: items[index],\n      items: items,\n      query: getStringifiedKeyConfig(keyConfig),\n      target: event.currentTarget\n    };\n    onChange(data, itemRefs);\n  }, [onKeyDown, stopPropagation, focusedIndex, keys, items, handleSearch, loopable, searchable, onChange, itemRefs]);\n  return [itemRefs, handleKeyDown];\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","loop","useKeyboardSearch","DEFAULT_GET_ITEM_VALUE","DEFAULT_VALUE_KEY","getKeyboardConfig","getStringifiedKeyConfig","transformKeys","useKeyboardMovement","_a","onKeyDown","incrementKeys","decrementKeys","jumpToFirstKeys","jumpToLastKeys","_b","stopPropagation","onChange","items","resetTime","findMatchIndex","focusedIndex","_c","loopable","_d","searchable","_e","valueKey","_f","getItemValue","keys","itemRefs","from","current","handleSearch","data","searchIndex","handleKeyDown","event","target","keyConfig","preventDefault","lastIndex","length","index","type","value","max","increment","minmax","item","query","currentTarget"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/wia-aria/movement/useKeyboardMovement.ts"],"sourcesContent":["import type { MutableRefObject } from \"react\";\nimport { useCallback, useMemo } from \"react\";\nimport { loop } from \"../../loop\";\nimport type {\n  BaseKeyboardSearchOptions,\n  SearchData,\n} from \"../../search/useKeyboardSearch\";\nimport { useKeyboardSearch } from \"../../search/useKeyboardSearch\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport type { MovementConfig } from \"./types\";\nimport {\n  getKeyboardConfig,\n  getStringifiedKeyConfig,\n  transformKeys,\n} from \"./utils\";\n\nexport type MovementHandler<E extends HTMLElement> =\n  React.KeyboardEventHandler<E>;\n\n/**\n * A mutable ref object that must be applied to each DOM node within the\n * \"focusable\"/\"searchable\" list of elements so that custom focus behavior can\n * be triggered.\n *\n * @typeParam E - the element type of each item within the focusable list.\n */\nexport type ItemRef<E extends HTMLElement> = MutableRefObject<E | null>;\n\nexport type ItemRefList<E extends HTMLElement = HTMLElement> =\n  readonly ItemRef<E>[];\n\nexport interface BaseKeyboardMovementOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends Omit<BaseKeyboardSearchOptions<D, CE>, \"onChange\">,\n    MovementConfig {\n  /**\n   * Boolean if the event should trigger `event.stopPropagation()` when the\n   * custom keyboard movement is triggered. This should generally be kept as\n   * `false` or `undefined` by default, but enabled when creating more complex\n   * 2-dimensional movement cases such as grids.\n   */\n  stopPropagation?: boolean;\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange?: (data: SearchData<D, CE>, itemRefs: ItemRefList<IE>) => void;\n}\n\n/**\n * The options for custom keyboard movement.\n *\n * @typeParam D - the type of each item within the item list\n * @typeParam CE - the type of the DOM element for the keyboard event handler.\n * @typeParam IE - the type of the DOM element for the keyboard event handler.\n */\nexport interface KeyboardMovementOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends BaseKeyboardMovementOptions<D, CE, IE> {\n  /**\n   * The currently focused index within the item list. This will need to be\n   * updated due to the `onChange` callback being called for this hook to work\n   * as it is fully \"controlled\" by a parent hook/component.\n   */\n  focusedIndex: number;\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange: (data: SearchData<D, CE>, itemRefs: ItemRefList<IE>) => void;\n}\n\n/**\n * Returns an ordered list with two items:\n *\n * - itemRefs\n * - onKeyDown event handler\n *\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport type KeyboardMovementProviders<\n  CE extends HTMLElement,\n  IE extends HTMLElement\n> = [\n  /**\n   * A list of mutable ref objects that must be applied to each focusable item\n   * within the list. This list will automatically be generated based on the\n   * number of items provided to the `useKeyboardMovement` hook\n   */\n  ItemRefList<IE>,\n\n  /**\n   * The keydown event handler to apply to a \"container\" element that has custom\n   * keyboard focus.\n   */\n  MovementHandler<CE>\n];\n\n/**\n * This is a low-level hook for providing custom keyboard movement based on key\n * configurations.  This normally shouldn't really be used externally since\n * you'll most likely want to use the \"presets\" of `useFocusMovement` and\n * `useActiveDescendantMovement` that implement the main movement types already\n * for you.\n *\n * The way this works is that it will general a list of mutable item refs that\n * should be applied to each DOM node for the corresponding `item` within the\n * `items` list. This list will change and regenerate itself each time the\n * `items` array changes so it'll always be in-sync with the DOM nodes. This\n * means that if you have some items that **should not be rendered**, they\n * should not be included within the items list. The main reason these item refs\n * are required is so that the `aria-activedescendant` movement can scroll the\n * new \"focused\" element into view if needed while the \"true\" focus movement can\n * trigger a `ref.current.focus()` on the new item as needed.\n *\n * Finally, this will create a keydown event handler that will merge in the\n * optionally provided `onKeyDown` prop and check if the pressed key should\n * trigger a custom keyboard movement event.  If it does, an `onChange` event\n * will be fired with the matching data and allows for custom movement with\n * `target.focus()` or updating the `aria-activedescendant` attribute as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useKeyboardMovement<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n>({\n  onKeyDown,\n  incrementKeys,\n  decrementKeys,\n  jumpToFirstKeys,\n  jumpToLastKeys,\n  stopPropagation = true,\n  onChange,\n  items,\n  resetTime,\n  findMatchIndex,\n  focusedIndex,\n  loopable = true,\n  searchable = true,\n  valueKey = DEFAULT_VALUE_KEY,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n}: KeyboardMovementOptions<D, CE, IE>): KeyboardMovementProviders<CE, IE> {\n  const keys = useMemo(\n    () => [\n      ...transformKeys(incrementKeys, \"increment\"),\n      ...transformKeys(decrementKeys, \"decrement\"),\n      ...transformKeys(jumpToFirstKeys, \"first\"),\n      ...transformKeys(jumpToLastKeys, \"last\"),\n    ],\n    [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]\n  );\n\n  const itemRefs = useMemo<ItemRefList<IE>>(\n    () => Array.from(items, () => ({ current: null })),\n    [items]\n  );\n\n  const handleSearch = useKeyboardSearch<D, CE>({\n    items,\n    valueKey,\n    getItemValue,\n    onChange(data) {\n      onChange(data, itemRefs);\n    },\n    searchIndex: focusedIndex,\n    resetTime,\n    findMatchIndex,\n  });\n\n  const handleKeyDown = useCallback<MovementHandler<CE>>(\n    (event) => {\n      if (searchable) {\n        handleSearch(event);\n      }\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const target = event.target as HTMLElement;\n      const keyConfig = getKeyboardConfig(event, keys);\n      if (!keyConfig || !target) {\n        return;\n      }\n\n      // implementing custom behavior, so prevent default of scrolling or other\n      // things\n      event.preventDefault();\n      if (stopPropagation) {\n        event.stopPropagation();\n      }\n\n      const { type } = keyConfig;\n\n      const lastIndex = items.length - 1;\n      let index: number;\n      switch (type) {\n        case \"first\":\n          index = 0;\n          break;\n        case \"last\":\n          index = lastIndex;\n          break;\n        default:\n          index = loop({\n            value: focusedIndex,\n            max: lastIndex,\n            increment: type === \"increment\",\n            minmax: !loopable,\n          });\n      }\n\n      if (index === focusedIndex) {\n        return;\n      }\n\n      const data: SearchData<D, CE> = {\n        index,\n        item: items[index],\n        items,\n        query: getStringifiedKeyConfig(keyConfig),\n        target: event.currentTarget,\n      };\n      onChange(data, itemRefs);\n    },\n    [\n      onKeyDown,\n      stopPropagation,\n      focusedIndex,\n      keys,\n      items,\n      handleSearch,\n      loopable,\n      searchable,\n      onChange,\n      itemRefs,\n    ]\n  );\n\n  return [itemRefs, handleKeyDown];\n}\n"]},"metadata":{},"sourceType":"module"}