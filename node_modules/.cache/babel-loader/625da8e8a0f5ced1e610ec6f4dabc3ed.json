{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\nexport var TextContainer = forwardRef(function TextContainer(_a, ref) {\n  var propClassName = _a.className,\n    _b = _a.component,\n    Component = _b === void 0 ? \"div\" : _b,\n    _c = _a.size,\n    size = _c === void 0 ? \"auto\" : _c,\n    children = _a.children,\n    clone = _a.clone,\n    props = __rest(_a, [\"className\", \"component\", \"size\", \"children\", \"clone\"]);\n  var className = cn(\"rmd-text-container rmd-text-container--\".concat(size), propClassName);\n  if (clone && isValidElement(children)) {\n    var child = Children.only(children);\n    return cloneElement(child, {\n      className: cn(child.props.className, className)\n    });\n  }\n  if (typeof children === \"function\") {\n    return children({\n      className: className\n    });\n  }\n  return _jsx(Component, __assign({}, props, {\n    className: className,\n    ref: ref\n  }, {\n    children: children\n  }));\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;AAMA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,UAAU,EAAEC,cAAc,QAAQ,OAAO;AAC1E,OAAOC,EAAE,MAAM,YAAY;AA0D3B,OAAO,IAAMC,aAAa,GAAGH,UAAU,CAGrC,SAASG,aAAa,CACtBC,EAOC,EACDC,GAAG;EAPD,IAAWC,aAAa;IACxBC,iBAA4B;IAAjBC,SAAS,mBAAG,KAAK;IAC5BC,YAAa;IAAbC,IAAI,mBAAG,MAAM;IACbC,QAAQ;IACRC,KAAK;IACFC,KAAK,cANV,uDAOC,CADS;EAIV,IAAMC,SAAS,GAAGZ,EAAE,CAClB,iDAA0CQ,IAAI,CAAE,EAChDJ,aAAa,CACd;EACD,IAAIM,KAAK,IAAIX,cAAc,CAACU,QAAQ,CAAC,EAAE;IACrC,IAAMI,KAAK,GAAGjB,QAAQ,CAACkB,IAAI,CAACL,QAAQ,CAAC;IACrC,OAAOZ,YAAY,CAACgB,KAAK,EAAE;MACzBD,SAAS,EAAEZ,EAAE,CAACa,KAAK,CAACF,KAAK,CAACC,SAAS,EAAEA,SAAS;KAC/C,CAAC;;EAGJ,IAAI,OAAOH,QAAQ,KAAK,UAAU,EAAE;IAClC,OAAQA,QAAwC,CAAC;MAAEG,SAAS;IAAA,CAAE,CAAC;;EAGjE,OACEG,KAACT,SAAS,eAAKK,KAAK;IAAEC,SAAS,EAAEA,SAAS;IAAET,GAAG,EAAEA;EAAG;IAAAM,UACjDA;EAAQ,GACC;AAEhB,CAAC,CAAC","names":["Children","cloneElement","forwardRef","isValidElement","cn","TextContainer","_a","ref","propClassName","_b","Component","_c","size","children","clone","props","className","child","only","_jsx"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/typography/src/TextContainer.tsx"],"sourcesContent":["import type {\n  ElementType,\n  HTMLAttributes,\n  ReactElement,\n  ReactNode,\n} from \"react\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\nimport type { ClassNameCloneableChild } from \"@react-md/utils\";\n\n/**\n * A union of the available text container sizes. One of these values must be\n * chosen to help set the max width for text.\n */\nexport type TextContainerSize = \"auto\" | \"mobile\" | \"desktop\";\n\n/**\n * A type describing the text container's children render function. It provides\n * an object containing the correct (and merged) className and expects a\n * renderable element to be returned.\n */\nexport type TextContainerRenderFunction = (props: {\n  className: string;\n}) => ReactElement;\n\n/**\n * The base props for rendering the text component.\n */\nexport interface TextContainerProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * An optional className to merge with typography text container styles.\n   */\n  className?: string;\n\n  /**\n   * The size for the text container. This can usually just be left at the\n   * default of `\"auto\"` since it will automatically transition between\n   * `\"mobile\"` and `\"desktop\"` based on media queries.  However, you can also\n   * manually specify `\"mobile\"` or `\"desktop\"` if needed.\n   */\n  size?: TextContainerSize;\n\n  /**\n   * The component to render as. By default this will just be a div, but\n   * anything can be provided.\n   */\n  component?: ElementType;\n\n  /**\n   * Either a child render function or a react node. If this is not the child\n   * render function, a different wrapper component can be provided using the\n   * `component` prop.\n   */\n  children?: ReactNode | ClassNameCloneableChild | TextContainerRenderFunction;\n\n  /**\n   * Boolean if the `className` should be cloned into the `children` for this\n   * component.\n   *\n   * Note: This will only work if the child component passed the `className`\n   * down to to the DOM element.\n   */\n  clone?: boolean;\n}\n\nexport const TextContainer = forwardRef<\n  HTMLDivElement | ElementType,\n  TextContainerProps\n>(function TextContainer(\n  {\n    className: propClassName,\n    component: Component = \"div\",\n    size = \"auto\",\n    children,\n    clone,\n    ...props\n  },\n  ref\n) {\n  const className = cn(\n    `rmd-text-container rmd-text-container--${size}`,\n    propClassName\n  );\n  if (clone && isValidElement(children)) {\n    const child = Children.only(children);\n    return cloneElement(child, {\n      className: cn(child.props.className, className),\n    });\n  }\n\n  if (typeof children === \"function\") {\n    return (children as TextContainerRenderFunction)({ className });\n  }\n\n  return (\n    <Component {...props} className={className} ref={ref}>\n      {children}\n    </Component>\n  );\n});\n"]},"metadata":{},"sourceType":"module"}