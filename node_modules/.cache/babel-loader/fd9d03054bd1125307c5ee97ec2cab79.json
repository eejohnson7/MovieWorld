{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\nexport function useFieldStates(_a) {\n  var onBlur = _a.onBlur,\n    onFocus = _a.onFocus,\n    onChange = _a.onChange,\n    value = _a.value,\n    defaultValue = _a.defaultValue;\n  var _b = __read(useState(false), 2),\n    focused = _b[0],\n    setFocused = _b[1];\n  var _c = __read(useState(function () {\n      if (typeof value === \"undefined\") {\n        return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n      }\n      return value.length > 0;\n    }), 2),\n    valued = _c[0],\n    setValued = _c[1];\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    setFocused(false);\n    var input = event.currentTarget;\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      setValued(input.validity.badInput || (value !== null && value !== void 0 ? value : input.value).length > 0);\n    }\n  }, [onBlur, value]);\n  var handleFocus = useCallback(function (event) {\n    if (onFocus) {\n      onFocus(event);\n    }\n    setFocused(true);\n  }, [onFocus]);\n  var handleChange = useCallback(function (event) {\n    if (onChange) {\n      onChange(event);\n    }\n    var input = event.currentTarget;\n    if (input.getAttribute(\"type\") === \"number\") {\n      input.checkValidity();\n      /* istanbul ignore next */\n      if (input.validity.badInput) {\n        return;\n      }\n    }\n    setValued(input.value.length > 0);\n  }, [onChange]);\n  // another way to handle this could be to just make the `valued` state derived\n  // based on the `value`, but it gets wonky for number fields. This technically\n  // still fails right now for number fields if you don't use the\n  // `useNumberField` hook since the `value` will be set back to the empty\n  // string on invalid numbers.\n  var prevValue = useRef(value);\n  useEffect(function () {\n    if (prevValue.current !== value && typeof value === \"string\") {\n      prevValue.current = value;\n      setValued(value.length > 0);\n    }\n  }, [value]);\n  return {\n    valued: valued,\n    focused: focused,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onChange: handleChange\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAMA,SAASA,WAAW,EAAEC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AA+ChE;;;;;;;AAOA,OAAM,SAAUC,cAAc,CAAwBC,EAM9B;MALtBC,MAAM;IACNC,OAAO;IACPC,QAAQ;IACRC,KAAK;IACLC,YAAY;EAEN,gBAAwBP,QAAQ,CAAC,KAAK,CAAC;IAAtCQ,OAAO;IAAEC,UAAU,QAAmB;EACvC,gBAAsBT,QAAQ,CAAC;MACnC,IAAI,OAAOM,KAAK,KAAK,WAAW,EAAE;QAChC,OAAO,OAAOC,YAAY,KAAK,WAAW,IAAIA,YAAY,CAACG,MAAM,GAAG,CAAC;;MAGvE,OAAOJ,KAAK,CAACI,MAAM,GAAG,CAAC;IACzB,CAAC,CAAC;IANKC,MAAM;IAAEC,SAAS,QAMtB;EAEF,IAAMC,UAAU,GAAGhB,WAAW,CAC5B,UAACiB,KAAoB;IACnB,IAAIX,MAAM,EAAE;MACVA,MAAM,CAACW,KAAK,CAAC;;IAGfL,UAAU,CAAC,KAAK,CAAC;IACjB,IAAMM,KAAK,GAAGD,KAAK,CAACE,aAAa;IACjC,IAAID,KAAK,CAACE,YAAY,CAAC,MAAM,CAAC,KAAK,QAAQ,EAAE;MAC3CF,KAAK,CAACG,aAAa,EAAE;MACrBN,SAAS,CAACG,KAAK,CAACI,QAAQ,CAACC,QAAQ,IAAI,CAACd,KAAK,aAALA,KAAK,cAALA,KAAK,GAAIS,KAAK,CAACT,KAAK,EAAEI,MAAM,GAAG,CAAC,CAAC;;EAE3E,CAAC,EACD,CAACP,MAAM,EAAEG,KAAK,CAAC,CAChB;EAED,IAAMe,WAAW,GAAGxB,WAAW,CAC7B,UAACiB,KAAoB;IACnB,IAAIV,OAAO,EAAE;MACXA,OAAO,CAACU,KAAK,CAAC;;IAGhBL,UAAU,CAAC,IAAI,CAAC;EAClB,CAAC,EACD,CAACL,OAAO,CAAC,CACV;EAED,IAAMkB,YAAY,GAAGzB,WAAW,CAC9B,UAACiB,KAAqB;IACpB,IAAIT,QAAQ,EAAE;MACZA,QAAQ,CAACS,KAAK,CAAC;;IAGjB,IAAMC,KAAK,GAAGD,KAAK,CAACE,aAAa;IACjC,IAAID,KAAK,CAACE,YAAY,CAAC,MAAM,CAAC,KAAK,QAAQ,EAAE;MAC3CF,KAAK,CAACG,aAAa,EAAE;MACrB;MACA,IAAIH,KAAK,CAACI,QAAQ,CAACC,QAAQ,EAAE;QAC3B;;;IAIJR,SAAS,CAACG,KAAK,CAACT,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC;EACnC,CAAC,EACD,CAACL,QAAQ,CAAC,CACX;EAED;EACA;EACA;EACA;EACA;EACA,IAAMkB,SAAS,GAAGxB,MAAM,CAACO,KAAK,CAAC;EAC/BR,SAAS,CAAC;IACR,IAAIyB,SAAS,CAACC,OAAO,KAAKlB,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC5DiB,SAAS,CAACC,OAAO,GAAGlB,KAAK;MACzBM,SAAS,CAACN,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC;;EAE/B,CAAC,EAAE,CAACJ,KAAK,CAAC,CAAC;EAEX,OAAO;IACLK,MAAM;IACNH,OAAO;IACPL,MAAM,EAAEU,UAAU;IAClBT,OAAO,EAAEiB,WAAW;IACpBhB,QAAQ,EAAEiB;GACX;AACH","names":["useCallback","useEffect","useRef","useState","useFieldStates","_a","onBlur","onFocus","onChange","value","defaultValue","focused","setFocused","length","valued","setValued","handleBlur","event","input","currentTarget","getAttribute","checkValidity","validity","badInput","handleFocus","handleChange","prevValue","current"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/useFieldStates.ts"],"sourcesContent":["import type {\n  ChangeEvent,\n  ChangeEventHandler,\n  FocusEvent,\n  FocusEventHandler,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ntype FormElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface EventHandlers<E extends FormElement> {\n  onBlur?: FocusEventHandler<E>;\n  onFocus?: FocusEventHandler<E>;\n  onChange?: ChangeEventHandler<E>;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface FieldStatesOptions<E extends FormElement> extends EventHandlers<E> {\n  value?: string | readonly string[];\n  defaultValue?: string | readonly string[];\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.2\n */\ninterface ReturnValue<E extends FormElement>\n  extends Required<EventHandlers<E>> {\n  /**\n   * Boolean if the TextField or TextArea current has a value with a `length > 0`\n   * so that any labels will correctly float above the text field. This will\n   * also make sure that number inputs will still be considered valued when\n   * there is a `badInput` validity error.\n   */\n  valued: boolean;\n\n  /**\n   * Boolean if the TextField or TextArea currently has focus.\n   */\n  focused: boolean;\n}\n\n/**\n * This hook is used to handle the different states for the text field based on\n * the current value and user interaction.\n *\n * @internal\n * @remarks \\@since 2.5.2\n */\nexport function useFieldStates<E extends FormElement>({\n  onBlur,\n  onFocus,\n  onChange,\n  value,\n  defaultValue,\n}: FieldStatesOptions<E>): ReturnValue<E> {\n  const [focused, setFocused] = useState(false);\n  const [valued, setValued] = useState(() => {\n    if (typeof value === \"undefined\") {\n      return typeof defaultValue !== \"undefined\" && defaultValue.length > 0;\n    }\n\n    return value.length > 0;\n  });\n\n  const handleBlur = useCallback(\n    (event: FocusEvent<E>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      setFocused(false);\n      const input = event.currentTarget;\n      if (input.getAttribute(\"type\") === \"number\") {\n        input.checkValidity();\n        setValued(input.validity.badInput || (value ?? input.value).length > 0);\n      }\n    },\n    [onBlur, value]\n  );\n\n  const handleFocus = useCallback(\n    (event: FocusEvent<E>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      setFocused(true);\n    },\n    [onFocus]\n  );\n\n  const handleChange = useCallback(\n    (event: ChangeEvent<E>) => {\n      if (onChange) {\n        onChange(event);\n      }\n\n      const input = event.currentTarget;\n      if (input.getAttribute(\"type\") === \"number\") {\n        input.checkValidity();\n        /* istanbul ignore next */\n        if (input.validity.badInput) {\n          return;\n        }\n      }\n\n      setValued(input.value.length > 0);\n    },\n    [onChange]\n  );\n\n  // another way to handle this could be to just make the `valued` state derived\n  // based on the `value`, but it gets wonky for number fields. This technically\n  // still fails right now for number fields if you don't use the\n  // `useNumberField` hook since the `value` will be set back to the empty\n  // string on invalid numbers.\n  const prevValue = useRef(value);\n  useEffect(() => {\n    if (prevValue.current !== value && typeof value === \"string\") {\n      prevValue.current = value;\n      setValued(value.length > 0);\n    }\n  }, [value]);\n\n  return {\n    valued,\n    focused,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    onChange: handleChange,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}