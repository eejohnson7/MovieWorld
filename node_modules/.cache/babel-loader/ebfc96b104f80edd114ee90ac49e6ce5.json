{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useRef } from \"react\";\nimport cn from \"classnames\";\nimport { DEFAULT_SHEET_TIMEOUT } from \"@react-md/sheet\";\nimport { useCSSTransition } from \"@react-md/transition\";\nimport { bem, useIsUserInteractionMode } from \"@react-md/utils\";\nimport { DEFAULT_LAYOUT_MAIN_CLASSNAMES } from \"./constants\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { isTemporaryLayout, isToggleableLayout } from \"./utils\";\nvar styles = bem(\"rmd-layout-main\");\n/**\n * This is the `<main>` element for your app that has some built in styles to be\n * able to update based on the current layout types.\n */\nexport var LayoutMain = forwardRef(function LayoutMain(_a, nodeRef) {\n  var className = _a.className,\n    propTabIndex = _a.tabIndex,\n    _b = _a.component,\n    Component = _b === void 0 ? \"main\" : _b,\n    propNavOffset = _a.navOffset,\n    _c = _a.headerOffset,\n    headerOffset = _c === void 0 ? false : _c,\n    _d = _a.timeout,\n    propTimeout = _d === void 0 ? DEFAULT_SHEET_TIMEOUT : _d,\n    _e = _a.classNames,\n    classNames = _e === void 0 ? DEFAULT_LAYOUT_MAIN_CLASSNAMES : _e,\n    _f = _a.mini,\n    mini = _f === void 0 ? false : _f,\n    _g = _a.miniHidden,\n    miniHidden = _g === void 0 ? false : _g,\n    props = __rest(_a, [\"className\", \"tabIndex\", \"component\", \"navOffset\", \"headerOffset\", \"timeout\", \"classNames\", \"mini\", \"miniHidden\"]);\n  // this makes it so that the SkipToMainContent button can still\n  // focus the `<main>` element, but the `<main>` will no longer be\n  // focused if the user clicks inside. This is super nice since one\n  // of my bigger patterns is to click somewhere then press tab to\n  // focus a specific element. Without this fix, the first element in\n  // the `<main>` tag would be focused instead of the closest focusable\n  // element to the click area.\n  var tabIndex = propTabIndex;\n  if (useIsUserInteractionMode(\"keyboard\") && typeof propTabIndex === \"undefined\") {\n    tabIndex = -1;\n  }\n  var _h = useLayoutConfig(),\n    layout = _h.layout,\n    visible = _h.visible,\n    fixedAppBar = _h.fixedAppBar;\n  var navOffset = propNavOffset;\n  if (typeof navOffset === \"undefined\") {\n    navOffset = visible && !isTemporaryLayout(layout);\n  }\n  var timeout = propTimeout;\n  var prevLayout = useRef(layout);\n  if (prevLayout.current !== layout) {\n    // this is kind of weird and hacky, but this will allow for the required\n    // classnames to be applied to the main element based on the current\n    // layout type without needing a unique `key` for the main content. this\n    // is super nice since we really don't want to remount the full app each\n    // time the layout changes.\n    timeout = 0;\n  }\n  var isMini = mini && (fixedAppBar || miniHidden);\n  var isMiniOffset = mini && navOffset && !fixedAppBar && visible && isToggleableLayout(layout);\n  var elementProps = useCSSTransition({\n    nodeRef: nodeRef,\n    transitionIn: !!navOffset,\n    temporary: false,\n    className: cn(styles({\n      mini: isMini && (isTemporaryLayout(layout) || !visible),\n      \"nav-offset\": isMini,\n      \"mini-offset\": isMiniOffset,\n      \"header-offset\": headerOffset\n    }), className),\n    timeout: timeout,\n    classNames: classNames,\n    onEntered: function () {\n      prevLayout.current = layout;\n    },\n    onExited: function () {\n      prevLayout.current = layout;\n    }\n  }).elementProps;\n  return _jsx(Component, __assign({}, props, elementProps, {\n    tabIndex: tabIndex\n  }));\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;AACA,SAASA,UAAU,EAAEC,MAAM,QAAQ,OAAO;AAC1C,OAAOC,EAAE,MAAM,YAAY;AAC3B,SAASC,qBAAqB,QAAQ,iBAAiB;AAKvD,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,SAASC,GAAG,EAAEC,wBAAwB,QAAQ,iBAAiB;AAE/D,SAASC,8BAA8B,QAAQ,aAAa;AAC5D,SAASC,eAAe,QAAQ,kBAAkB;AAClD,SAASC,iBAAiB,EAAEC,kBAAkB,QAAQ,SAAS;AAuD/D,IAAMC,MAAM,GAAGN,GAAG,CAAC,iBAAiB,CAAC;AAErC;;;;AAIA,OAAO,IAAMO,UAAU,GAAGZ,UAAU,CAClC,SAASY,UAAU,CACjBC,EAWC,EACDC,OAAO;EAXL,aAAS;IACCC,YAAY;IACtBC,iBAA6B;IAAlBC,SAAS,mBAAG,MAAM;IAClBC,aAAa;IACxBC,oBAAoB;IAApBC,YAAY,mBAAG,KAAK;IACpBC,eAA4C;IAAnCC,WAAW,mBAAGnB,qBAAqB;IAC5CoB,kBAA2C;IAA3CC,UAAU,mBAAGjB,8BAA8B;IAC3CkB,YAAY;IAAZC,IAAI,mBAAG,KAAK;IACZC,kBAAkB;IAAlBC,UAAU,mBAAG,KAAK;IACfC,KAAK,cAVV,kHAWC,CADS;EAIV;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIC,QAAQ,GAAGf,YAAY;EAC3B,IACET,wBAAwB,CAAC,UAAU,CAAC,IACpC,OAAOS,YAAY,KAAK,WAAW,EACnC;IACAe,QAAQ,GAAG,CAAC,CAAC;;EAGT,SAAmCtB,eAAe,EAAE;IAAlDuB,MAAM;IAAEC,OAAO;IAAEC,WAAW,iBAAsB;EAC1D,IAAIC,SAAS,GAAGhB,aAAa;EAC7B,IAAI,OAAOgB,SAAS,KAAK,WAAW,EAAE;IACpCA,SAAS,GAAGF,OAAO,IAAI,CAACvB,iBAAiB,CAACsB,MAAM,CAAC;;EAGnD,IAAII,OAAO,GAAGb,WAAW;EACzB,IAAMc,UAAU,GAAGnC,MAAM,CAAC8B,MAAM,CAAC;EACjC,IAAIK,UAAU,CAACC,OAAO,KAAKN,MAAM,EAAE;IACjC;IACA;IACA;IACA;IACA;IACAI,OAAO,GAAG,CAAC;;EAGb,IAAMG,MAAM,GAAGZ,IAAI,KAAKO,WAAW,IAAIL,UAAU,CAAC;EAClD,IAAMW,YAAY,GAChBb,IAAI,IACJQ,SAAS,IACT,CAACD,WAAW,IACZD,OAAO,IACPtB,kBAAkB,CAACqB,MAAM,CAAC;EAEpB,gBAAY,GAAK3B,gBAAgB,CAAiB;IACxDU,OAAO;IACP0B,YAAY,EAAE,CAAC,CAACN,SAAS;IACzBO,SAAS,EAAE,KAAK;IAChBC,SAAS,EAAExC,EAAE,CACXS,MAAM,CAAC;MACLe,IAAI,EAAEY,MAAM,KAAK7B,iBAAiB,CAACsB,MAAM,CAAC,IAAI,CAACC,OAAO,CAAC;MACvD,YAAY,EAAEM,MAAM;MACpB,aAAa,EAAEC,YAAY;MAC3B,eAAe,EAAEnB;KAClB,CAAC,EACFsB,SAAS,CACV;IACDP,OAAO;IACPX,UAAU;IACVmB,SAAS,EAAE;MACTP,UAAU,CAACC,OAAO,GAAGN,MAAM;IAC7B,CAAC;IACDa,QAAQ,EAAE;MACRR,UAAU,CAACC,OAAO,GAAGN,MAAM;IAC7B;GACD,CAAC,aArBkB;EAuBpB,OAAOc,KAAC5B,SAAS,eAAKY,KAAK,EAAMiB,YAAY;IAAEhB,QAAQ,EAAEA;EAAQ,GAAI;AACvE,CAAC,CACF","names":["forwardRef","useRef","cn","DEFAULT_SHEET_TIMEOUT","useCSSTransition","bem","useIsUserInteractionMode","DEFAULT_LAYOUT_MAIN_CLASSNAMES","useLayoutConfig","isTemporaryLayout","isToggleableLayout","styles","LayoutMain","_a","nodeRef","propTabIndex","_b","Component","propNavOffset","_c","headerOffset","_d","propTimeout","_e","classNames","_f","mini","_g","miniHidden","props","tabIndex","layout","visible","fixedAppBar","navOffset","timeout","prevLayout","current","isMini","isMiniOffset","transitionIn","temporary","className","onEntered","onExited","_jsx","elementProps"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/layout/src/LayoutMain.tsx"],"sourcesContent":["import type { HTMLAttributes } from \"react\";\nimport { forwardRef, useRef } from \"react\";\nimport cn from \"classnames\";\nimport { DEFAULT_SHEET_TIMEOUT } from \"@react-md/sheet\";\nimport type {\n  CSSTransitionClassNames,\n  TransitionTimeout,\n} from \"@react-md/transition\";\nimport { useCSSTransition } from \"@react-md/transition\";\nimport { bem, useIsUserInteractionMode } from \"@react-md/utils\";\n\nimport { DEFAULT_LAYOUT_MAIN_CLASSNAMES } from \"./constants\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { isTemporaryLayout, isToggleableLayout } from \"./utils\";\n\nexport interface LayoutMainProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * The component to render the main element as. This should normally stay as\n   * the default of `\"main\"`, but if you want to have multiple `Layout` on the\n   * page for some reason, you'll need to use `\"div\"` for the other `Layout`s\n   * since you can only have one `<main>` per page (unless you set the `hidden`\n   * attribute on all the others).\n   */\n  component?: \"div\" | \"main\";\n\n  /**\n   * Boolean if the main element should be offset by the current navigation\n   * tree's width.\n   */\n  navOffset?: boolean;\n\n  /**\n   * Boolean if the main element should be offset by the `AppBar`'s height\n   */\n  headerOffset?: boolean;\n\n  /**\n   * Boolean of there is a mini nav visible within the layout. This makes sure\n   * that the content if offset by the current nav's width when needed.\n   *\n   * @remarks \\@since 2.7.0\n   */\n  mini?: boolean;\n\n  /**\n   * Boolean if the mini layout is currently hidden to help determine if\n   * specific mini styles should be applied when the {@link LayoutContext.fixedAppBar}\n   * config is `false`.\n   *\n   * @internal\n   * @remarks \\@since 2.8.3\n   */\n  miniHidden?: boolean;\n\n  /**\n   * The transition timeout to use for the toggleable `LayoutNavigation` either\n   * comes into view or expands from mini to full-width. The transition can be\n   * disabled by setting this value to `0`.\n   */\n  timeout?: TransitionTimeout;\n\n  /**\n   * The transition classnames to use for the toggleable `LayoutNavigation`\n   * either comes into view or expands from mini to full-width.\n   */\n  classNames?: CSSTransitionClassNames;\n}\n\nconst styles = bem(\"rmd-layout-main\");\n\n/**\n * This is the `<main>` element for your app that has some built in styles to be\n * able to update based on the current layout types.\n */\nexport const LayoutMain = forwardRef<HTMLDivElement, LayoutMainProps>(\n  function LayoutMain(\n    {\n      className,\n      tabIndex: propTabIndex,\n      component: Component = \"main\",\n      navOffset: propNavOffset,\n      headerOffset = false,\n      timeout: propTimeout = DEFAULT_SHEET_TIMEOUT,\n      classNames = DEFAULT_LAYOUT_MAIN_CLASSNAMES,\n      mini = false,\n      miniHidden = false,\n      ...props\n    },\n    nodeRef\n  ) {\n    // this makes it so that the SkipToMainContent button can still\n    // focus the `<main>` element, but the `<main>` will no longer be\n    // focused if the user clicks inside. This is super nice since one\n    // of my bigger patterns is to click somewhere then press tab to\n    // focus a specific element. Without this fix, the first element in\n    // the `<main>` tag would be focused instead of the closest focusable\n    // element to the click area.\n    let tabIndex = propTabIndex;\n    if (\n      useIsUserInteractionMode(\"keyboard\") &&\n      typeof propTabIndex === \"undefined\"\n    ) {\n      tabIndex = -1;\n    }\n\n    const { layout, visible, fixedAppBar } = useLayoutConfig();\n    let navOffset = propNavOffset;\n    if (typeof navOffset === \"undefined\") {\n      navOffset = visible && !isTemporaryLayout(layout);\n    }\n\n    let timeout = propTimeout;\n    const prevLayout = useRef(layout);\n    if (prevLayout.current !== layout) {\n      // this is kind of weird and hacky, but this will allow for the required\n      // classnames to be applied to the main element based on the current\n      // layout type without needing a unique `key` for the main content. this\n      // is super nice since we really don't want to remount the full app each\n      // time the layout changes.\n      timeout = 0;\n    }\n\n    const isMini = mini && (fixedAppBar || miniHidden);\n    const isMiniOffset =\n      mini &&\n      navOffset &&\n      !fixedAppBar &&\n      visible &&\n      isToggleableLayout(layout);\n\n    const { elementProps } = useCSSTransition<HTMLDivElement>({\n      nodeRef,\n      transitionIn: !!navOffset,\n      temporary: false,\n      className: cn(\n        styles({\n          mini: isMini && (isTemporaryLayout(layout) || !visible),\n          \"nav-offset\": isMini,\n          \"mini-offset\": isMiniOffset,\n          \"header-offset\": headerOffset,\n        }),\n        className\n      ),\n      timeout,\n      classNames,\n      onEntered: () => {\n        prevLayout.current = layout;\n      },\n      onExited: () => {\n        prevLayout.current = layout;\n      },\n    });\n\n    return <Component {...props} {...elementProps} tabIndex={tabIndex} />;\n  }\n);\n"]},"metadata":{},"sourceType":"module"}