{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useState } from \"react\";\nimport { scrollIntoView } from \"../../scrollIntoView\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\nimport { getItemId } from \"./utils\";\n/**\n * This hook allows for custom keyboard \"focus\" movement using the\n * `aria-activedescendant` movement pattern. This is generally used when the DOM\n * focus shouldn't actually change from the container element (like listboxes)\n * but you still need to indicate that another element is \"focused\" due to a key\n * press.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have an `aria-activedescendant={activeId}` attribute and\n * `onKeyDown={onKeyDown}` that are provided by this hook. The\n * `aria-activedescendant` will help screen readers known what element is\n * \"focused\" since the container element should never really lose focus during\n * these keyboard movement events.  Finally, you'll want to update each item\n * have an id that is the result of `getItem(baseId, index)` so that it matches\n * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.\n * Unfortunately, this means that all the child items **must** either be an\n * HTMLElement or the ref is forwarded down to the HTMLElement.\n *\n * The `itemRefs` **must** be applied so that a new \"focused\" item can be\n * scrolled into view as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useActiveDescendantMovement(_a) {\n  var baseId = _a.baseId,\n    _b = _a.getId,\n    getId = _b === void 0 ? getItemId : _b,\n    _c = _a.defaultFocusedIndex,\n    defaultFocusedIndex = _c === void 0 ? -1 : _c,\n    items = _a.items,\n    onChange = _a.onChange,\n    _d = _a.getItemValue,\n    getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d,\n    _e = _a.valueKey,\n    valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e,\n    onKeyDown = _a.onKeyDown,\n    onEnter = _a.onEnter,\n    onSpace = _a.onSpace,\n    options = __rest(_a, [\"baseId\", \"getId\", \"defaultFocusedIndex\", \"items\", \"onChange\", \"getItemValue\", \"valueKey\", \"onKeyDown\", \"onEnter\", \"onSpace\"]);\n  var _f = __read(useState(defaultFocusedIndex), 2),\n    focusedIndex = _f[0],\n    setFocusedIndex = _f[1];\n  var activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : \"\";\n  var _g = __read(useKeyboardMovement(__assign(__assign({}, options), {\n      valueKey: valueKey,\n      getItemValue: getItemValue,\n      focusedIndex: focusedIndex,\n      items: items,\n      onChange: function (data, itemRefs) {\n        if (onChange) {\n          onChange(data, itemRefs);\n        }\n        var index = data.index,\n          target = data.target;\n        var item = itemRefs[index] && itemRefs[index].current;\n        if (item && target && target.scrollHeight > target.offsetHeight) {\n          scrollIntoView(target, item);\n        }\n        setFocusedIndex(index);\n      },\n      onKeyDown: function (event) {\n        if (onKeyDown) {\n          onKeyDown(event);\n        }\n        var ref = itemRefs[focusedIndex] && itemRefs[focusedIndex].current || null;\n        if (onEnter && event.key === \"Enter\") {\n          onEnter(focusedIndex, ref);\n        } else if (onSpace && event.key === \" \") {\n          event.preventDefault();\n          onSpace(focusedIndex, ref);\n        }\n      }\n    })), 2),\n    itemRefs = _g[0],\n    handleKeyDown = _g[1];\n  return {\n    activeId: activeId,\n    itemRefs: itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex: focusedIndex,\n    setFocusedIndex: setFocusedIndex\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,QAAQ,QAAQ,OAAO;AAEhC,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,sBAAsB,EAAEC,iBAAiB,QAAQ,oBAAoB;AAM9E,SAASC,mBAAmB,QAAQ,uBAAuB;AAC3D,SAASC,SAAS,QAAQ,SAAS;AAmEnC;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAM,SAAUC,2BAA2B,CAIzCC,EAYmC;EAXnC,UAAM;IACNC,aAAiB;IAAjBC,KAAK,mBAAGJ,SAAS;IACjBK,2BAAwB;IAAxBC,mBAAmB,mBAAG,CAAC,CAAC;IACxBC,KAAK;IACLC,QAAQ;IACRC,oBAAqC;IAArCC,YAAY,mBAAGb,sBAAsB;IACrCc,gBAA4B;IAA5BC,QAAQ,mBAAGd,iBAAiB;IAC5Be,SAAS;IACTC,OAAO;IACPC,OAAO;IACJC,OAAO,cAXV,8HAYD,CADW;EAKJ,gBAAkCrB,QAAQ,CAACW,mBAAmB,CAAC;IAA9DW,YAAY;IAAEC,eAAe,QAAiC;EACrE,IAAMC,QAAQ,GAAGF,YAAY,KAAK,CAAC,CAAC,GAAGb,KAAK,CAACgB,MAAM,EAAEH,YAAY,CAAC,GAAG,EAAE;EAEjE,gBAA4BlB,mBAAmB,uBAChDiB,OAAO;MACVJ,QAAQ;MACRF,YAAY;MACZO,YAAY;MACZV,KAAK;MACLC,QAAQ,YAACa,IAAI,EAAEC,QAAQ;QACrB,IAAId,QAAQ,EAAE;UACZA,QAAQ,CAACa,IAAI,EAAEC,QAAQ,CAAC;;QAGlB,SAAK,GAAaD,IAAI,MAAjB;UAAEE,MAAM,GAAKF,IAAI,OAAT;QACrB,IAAMG,IAAI,GAAGF,QAAQ,CAACG,KAAK,CAAC,IAAIH,QAAQ,CAACG,KAAK,CAAC,CAACC,OAAO;QACvD,IAAIF,IAAI,IAAID,MAAM,IAAIA,MAAM,CAACI,YAAY,GAAGJ,MAAM,CAACK,YAAY,EAAE;UAC/DhC,cAAc,CAAC2B,MAAM,EAAEC,IAAI,CAAC;;QAG9BN,eAAe,CAACO,KAAK,CAAC;MACxB,CAAC;MACDZ,SAAS,YAACgB,KAAK;QACb,IAAIhB,SAAS,EAAE;UACbA,SAAS,CAACgB,KAAK,CAAC;;QAGlB,IAAMC,GAAG,GACNR,QAAQ,CAACL,YAAY,CAAC,IAAIK,QAAQ,CAACL,YAAY,CAAC,CAACS,OAAO,IAAK,IAAI;QACpE,IAAIZ,OAAO,IAAIe,KAAK,CAACE,GAAG,KAAK,OAAO,EAAE;UACpCjB,OAAO,CAACG,YAAY,EAAEa,GAAG,CAAC;SAC3B,MAAM,IAAIf,OAAO,IAAIc,KAAK,CAACE,GAAG,KAAK,GAAG,EAAE;UACvCF,KAAK,CAACG,cAAc,EAAE;UACtBjB,OAAO,CAACE,YAAY,EAAEa,GAAG,CAAC;;MAE9B;IAAC,GACD;IAjCKR,QAAQ;IAAEW,aAAa,QAiC5B;EAEF,OAAO;IACLd,QAAQ;IACRG,QAAQ;IACRT,SAAS,EAAEoB,aAAa;IACxBhB,YAAY;IACZC,eAAe;GAChB;AACH","names":["useState","scrollIntoView","DEFAULT_GET_ITEM_VALUE","DEFAULT_VALUE_KEY","useKeyboardMovement","getItemId","useActiveDescendantMovement","_a","_b","getId","_c","defaultFocusedIndex","items","onChange","_d","getItemValue","_e","valueKey","onKeyDown","onEnter","onSpace","options","focusedIndex","setFocusedIndex","activeId","baseId","data","itemRefs","target","item","index","current","scrollHeight","offsetHeight","event","ref","key","preventDefault","handleKeyDown"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/wia-aria/movement/useActiveDescendantMovement.ts"],"sourcesContent":["import type { Dispatch, SetStateAction } from \"react\";\nimport { useState } from \"react\";\n\nimport { scrollIntoView } from \"../../scrollIntoView\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport type {\n  BaseKeyboardMovementOptions,\n  ItemRefList,\n  MovementHandler,\n} from \"./useKeyboardMovement\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\nimport { getItemId } from \"./utils\";\n\nexport type ActiveDescendantId = string;\n\n/**\n *\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport interface ActiveDescendantMovementProviders<\n  CE extends HTMLElement,\n  IE extends HTMLElement\n> {\n  itemRefs: ItemRefList<IE>;\n  onKeyDown: MovementHandler<CE>;\n  activeId: ActiveDescendantId;\n  focusedIndex: number;\n  setFocusedIndex: Dispatch<SetStateAction<number>>;\n}\n\ntype KeyHandler<IE extends HTMLElement = HTMLElement> = (\n  focusedIndex: number,\n  itemRef: IE | null\n) => void;\n\ninterface ActiveDescendantOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends BaseKeyboardMovementOptions<D, CE, IE> {\n  /**\n   * The base id that should be used to generate the `aria-activedescendant`\n   * value id. This will be passed into the `getId` option.\n   */\n  baseId: string;\n\n  /**\n   * The function that should generate an id based on the provided `id` and\n   * `index` of the item.\n   */\n  getId?(id: string, index: number): string;\n\n  /**\n   * The default index that should be \"focused\" when the component mounts. This\n   * is set to `-1` by default so that it only gains a new \"focused\" index when\n   * the container element is focused.\n   */\n  defaultFocusedIndex?: (() => number) | number;\n\n  /**\n   * An optional function to call when the enter key has been pressed while the\n   * container element has keyboard focus. This is normally used for triggering\n   * click events for that specific item.\n   */\n  onEnter?: KeyHandler<IE>;\n\n  /**\n   * An optional function to call when the space key has been pressed while the\n   * container element has keyboard focus. This is normally used for triggering\n   * click events for that specific item and will always call\n   * `event.preventDefault()` to prevent the page scrolling behavior.\n   */\n  onSpace?: KeyHandler<IE>;\n}\n\n/**\n * This hook allows for custom keyboard \"focus\" movement using the\n * `aria-activedescendant` movement pattern. This is generally used when the DOM\n * focus shouldn't actually change from the container element (like listboxes)\n * but you still need to indicate that another element is \"focused\" due to a key\n * press.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have an `aria-activedescendant={activeId}` attribute and\n * `onKeyDown={onKeyDown}` that are provided by this hook. The\n * `aria-activedescendant` will help screen readers known what element is\n * \"focused\" since the container element should never really lose focus during\n * these keyboard movement events.  Finally, you'll want to update each item\n * have an id that is the result of `getItem(baseId, index)` so that it matches\n * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.\n * Unfortunately, this means that all the child items **must** either be an\n * HTMLElement or the ref is forwarded down to the HTMLElement.\n *\n * The `itemRefs` **must** be applied so that a new \"focused\" item can be\n * scrolled into view as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useActiveDescendantMovement<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n>({\n  baseId,\n  getId = getItemId,\n  defaultFocusedIndex = -1,\n  items,\n  onChange,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n  valueKey = DEFAULT_VALUE_KEY,\n  onKeyDown,\n  onEnter,\n  onSpace,\n  ...options\n}: ActiveDescendantOptions<D, CE, IE>): ActiveDescendantMovementProviders<\n  CE,\n  IE\n> {\n  const [focusedIndex, setFocusedIndex] = useState(defaultFocusedIndex);\n  const activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : \"\";\n\n  const [itemRefs, handleKeyDown] = useKeyboardMovement<D, CE, IE>({\n    ...options,\n    valueKey,\n    getItemValue,\n    focusedIndex,\n    items,\n    onChange(data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      const { index, target } = data;\n      const item = itemRefs[index] && itemRefs[index].current;\n      if (item && target && target.scrollHeight > target.offsetHeight) {\n        scrollIntoView(target, item);\n      }\n\n      setFocusedIndex(index);\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const ref =\n        (itemRefs[focusedIndex] && itemRefs[focusedIndex].current) || null;\n      if (onEnter && event.key === \"Enter\") {\n        onEnter(focusedIndex, ref);\n      } else if (onSpace && event.key === \" \") {\n        event.preventDefault();\n        onSpace(focusedIndex, ref);\n      }\n    },\n  });\n\n  return {\n    activeId,\n    itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}