{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useEffect, useReducer } from \"react\";\nimport { nanoid } from \"nanoid\";\nimport { omit } from \"@react-md/utils\";\nimport { getFileParser as defaultGetFileParser, FileAccessError, isValidFileName as defaultIsValidFileName, validateFiles as defaultValidateFiles } from \"./utils\";\n/** @internal */\nvar EMPTY_LIST = [];\n/** @internal */\nvar EMPTY_OBJECT = {};\n/**\n * This hook is generally used to upload files **to the browser** in different\n * formats to be previewed `<img>`, `<video>`, `<embed>`, etc tags. However, it\n * can also be used to upload the files as an `ArrayBuffer` and then uploaded to\n * a server.\n *\n * Note: If using the `aws-sdk` to upload files directly to S3, **do not use\n * this hook** since it uses its own upload process.\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @param options - All the {@link FileUploadOptions}\n * @returns the {@link FileUploadHookReturnValue}\n * @remarks \\@since 2.9.0\n */\nexport function useFileUpload(_a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.maxFiles,\n    maxFiles = _c === void 0 ? -1 : _c,\n    _d = _b.extensions,\n    extensions = _d === void 0 ? EMPTY_LIST : _d,\n    _e = _b.minFileSize,\n    minFileSize = _e === void 0 ? -1 : _e,\n    _f = _b.maxFileSize,\n    maxFileSize = _f === void 0 ? -1 : _f,\n    _g = _b.totalFileSize,\n    totalFileSize = _g === void 0 ? -1 : _g,\n    _h = _b.concurrency,\n    concurrency = _h === void 0 ? -1 : _h,\n    propOnDrop = _b.onDrop,\n    propOnChange = _b.onChange,\n    _j = _b.validateFiles,\n    validateFiles = _j === void 0 ? defaultValidateFiles : _j,\n    _k = _b.getFileParser,\n    getFileParser = _k === void 0 ? defaultGetFileParser : _k,\n    _l = _b.isValidFileName,\n    isValidFileName = _l === void 0 ? defaultIsValidFileName : _l;\n  var _m = __read(useReducer(function reducer(state, action) {\n      var _a, _b, _c, _d;\n      switch (action.type) {\n        case \"reset\":\n          // need to reuse constants so that calling reset doesn't cause an\n          // infinite loop in an effect\n          return {\n            stats: EMPTY_OBJECT,\n            errors: EMPTY_LIST,\n            readers: EMPTY_OBJECT\n          };\n        case \"remove\":\n          return __assign(__assign({}, state), {\n            stats: omit(state.stats, action.files)\n          });\n        case \"queue\":\n          return __assign(__assign({}, state), {\n            stats: __assign(__assign({}, state.stats), action.files.reduce(function (files, file) {\n              var key = nanoid();\n              files[key] = {\n                key: key,\n                file: file,\n                progress: 0,\n                status: \"pending\"\n              };\n              return files;\n            }, {})),\n            errors: __spreadArray(__spreadArray([], __read(state.errors), false), __read(action.errors), false)\n          });\n        case \"start\":\n          {\n            var key = action.key,\n              reader = action.reader;\n            /* istanbul ignore next */\n            if (!state.stats[key]) {\n              throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n            }\n            var fileStats = {\n              key: key,\n              file: state.stats[key].file,\n              progress: 0,\n              status: \"uploading\"\n            };\n            return __assign(__assign({}, state), {\n              readers: __assign(__assign({}, state.readers), (_a = {}, _a[key] = reader, _a)),\n              stats: __assign(__assign({}, state.stats), (_b = {}, _b[key] = fileStats, _b))\n            });\n          }\n        case \"progress\":\n          {\n            var key = action.key,\n              progress = action.progress;\n            /* istanbul ignore next */\n            if (!state.stats[key]) {\n              throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n            }\n            return __assign(__assign({}, state), {\n              stats: __assign(__assign({}, state.stats), (_c = {}, _c[key] = __assign(__assign({}, state.stats[key]), {\n                progress: progress\n              }), _c))\n            });\n          }\n        case \"complete\":\n          {\n            var key = action.key,\n              result = action.result;\n            /* istanbul ignore next */\n            if (!state.stats[key]) {\n              throw new Error(\"Missing file with key \\\"\".concat(key, \"\\\"\"));\n            }\n            var file = {\n              key: key,\n              file: state.stats[key].file,\n              status: \"complete\",\n              result: result,\n              progress: 100\n            };\n            var _e = state.readers,\n              _f = key,\n              _reader = _e[_f],\n              readers_1 = __rest(_e, [typeof _f === \"symbol\" ? _f : _f + \"\"]);\n            return __assign(__assign({}, state), {\n              readers: readers_1,\n              stats: __assign(__assign({}, state.stats), (_d = {}, _d[key] = file, _d))\n            });\n          }\n        case \"clearErrors\":\n          return __assign(__assign({}, state), {\n            errors: []\n          });\n        default:\n          /* istanbul ignore next */\n          return state;\n      }\n    }, {\n      stats: EMPTY_OBJECT,\n      errors: EMPTY_LIST,\n      readers: EMPTY_OBJECT\n    }), 2),\n    state = _m[0],\n    dispatch = _m[1];\n  var stats = state.stats,\n    errors = state.errors,\n    readers = state.readers;\n  var statsList = Object.values(stats);\n  var totalFiles = statsList.length;\n  var totalBytes = statsList.reduce(function (result, _a) {\n    var size = _a.file.size;\n    return result + size;\n  }, 0);\n  var queueFiles = useCallback(function (files) {\n    var _a = validateFiles(files, {\n        maxFiles: maxFiles,\n        extensions: extensions,\n        minFileSize: minFileSize,\n        maxFileSize: maxFileSize,\n        totalBytes: totalBytes,\n        totalFiles: totalFiles,\n        totalFileSize: totalFileSize,\n        isValidFileName: isValidFileName\n      }),\n      pending = _a.pending,\n      errors = _a.errors;\n    dispatch({\n      type: \"queue\",\n      errors: errors,\n      files: pending\n    });\n  }, [validateFiles, maxFiles, extensions, minFileSize, maxFileSize, totalBytes, totalFiles, totalFileSize, isValidFileName]);\n  var onDrop = useCallback(function (event) {\n    propOnDrop === null || propOnDrop === void 0 ? void 0 : propOnDrop(event);\n    event.preventDefault();\n    event.stopPropagation();\n    try {\n      var files = event.dataTransfer.files;\n      if (files) {\n        queueFiles(Array.from(files));\n      }\n    } catch (e) {\n      dispatch({\n        type: \"queue\",\n        files: [],\n        errors: [new FileAccessError(e instanceof Error ? e.message : undefined)]\n      });\n    }\n  }, [queueFiles, propOnDrop]);\n  var onChange = useCallback(function (event) {\n    propOnChange === null || propOnChange === void 0 ? void 0 : propOnChange(event);\n    try {\n      var files = event.currentTarget.files;\n      if (files) {\n        queueFiles(Array.from(files));\n      } else {\n        throw new Error();\n      }\n    } catch (e) {\n      dispatch({\n        type: \"queue\",\n        files: [],\n        errors: [new FileAccessError(e instanceof Error ? e.message : undefined)]\n      });\n    }\n  }, [queueFiles, propOnChange]);\n  var remove = useCallback(function (keyOrKeys) {\n    var files = typeof keyOrKeys === \"string\" ? [keyOrKeys] : keyOrKeys;\n    files.forEach(function (fileKey) {\n      var _a;\n      (_a = readers[fileKey]) === null || _a === void 0 ? void 0 : _a.abort();\n    });\n    dispatch({\n      type: \"remove\",\n      files: files\n    });\n  }, [readers]);\n  var reset = useCallback(function () {\n    Object.values(readers).forEach(function (reader) {\n      reader.abort();\n    });\n    dispatch({\n      type: \"reset\"\n    });\n  }, [readers]);\n  var clearErrors = useCallback(function () {\n    dispatch({\n      type: \"clearErrors\"\n    });\n  }, []);\n  var start = useCallback(function (key, reader) {\n    dispatch({\n      type: \"start\",\n      key: key,\n      reader: reader\n    });\n  }, []);\n  var complete = useCallback(function (key, result) {\n    if (result === void 0) {\n      result = null;\n    }\n    dispatch({\n      type: \"complete\",\n      key: key,\n      result: result\n    });\n  }, []);\n  var createProgressEventHandler = useCallback(function (key) {\n    return function (event) {\n      if (event.lengthComputable) {\n        var percentage = Math.round(event.loaded * 100 / event.total);\n        dispatch({\n          type: \"progress\",\n          key: key,\n          progress: percentage\n        });\n      }\n    };\n  }, []);\n  useEffect(function () {\n    var pending = [];\n    var uploading = [];\n    Object.values(stats).forEach(function (file) {\n      if (file.status === \"pending\") {\n        pending.push(file);\n      } else if (file.status === \"uploading\") {\n        uploading.push(file);\n      }\n    });\n    var lastIndex = concurrency === -1 ? pending.length : Math.max(0, concurrency - uploading.length);\n    var queue = pending.slice(0, lastIndex);\n    if (!queue.length) {\n      return;\n    }\n    queue.forEach(function (stats) {\n      var key = stats.key,\n        file = stats.file;\n      var reader = new FileReader();\n      // using `addEventListener` instead of directly setting to\n      // `reader.progress`/`reader.load` so it's easier to test\n      reader.addEventListener(\"progress\", createProgressEventHandler(key));\n      reader.addEventListener(\"load\", function () {\n        complete(key, reader.result);\n      });\n      start(key, reader);\n      var parser = getFileParser(file);\n      /* istanbul ignore next */\n      if (process.env.NODE_ENV !== \"production\" && ![\"readAsText\", \"readAsDataURL\", \"readAsArrayBuffer\", \"readAsBinaryString\"].includes(parser)) {\n        throw new Error(\"Invalid file reader parser\");\n      }\n      reader[parser](file);\n    });\n  }, [concurrency, stats, getFileParser, createProgressEventHandler, start, complete]);\n  var accept = \"\";\n  if (extensions.length) {\n    accept = extensions.reduce(function (s, ext) {\n      return \"\".concat(s ? \"\".concat(s, \",\") : \"\", \".\").concat(ext);\n    }, \"\");\n  }\n  return {\n    stats: statsList,\n    errors: errors,\n    accept: accept,\n    totalBytes: totalBytes,\n    totalFiles: totalFiles,\n    onDrop: onDrop,\n    onChange: onChange,\n    reset: reset,\n    remove: remove,\n    clearErrors: clearErrors\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useReducer","nanoid","omit","getFileParser","defaultGetFileParser","FileAccessError","isValidFileName","defaultIsValidFileName","validateFiles","defaultValidateFiles","EMPTY_LIST","EMPTY_OBJECT","useFileUpload","_a","_b","_c","maxFiles","_d","extensions","_e","minFileSize","_f","maxFileSize","_g","totalFileSize","_h","concurrency","propOnDrop","propOnChange","_j","_k","_l","reducer","state","action","type","stats","errors","readers","files","reduce","file","key","progress","status","reader","Error","fileStats","result","_reader","readers_1","dispatch","statsList","Object","values","totalFiles","length","totalBytes","size","queueFiles","pending","onDrop","event","preventDefault","stopPropagation","dataTransfer","Array","from","e","message","undefined","onChange","currentTarget","remove","keyOrKeys","forEach","fileKey","abort","reset","clearErrors","start","complete","createProgressEventHandler","lengthComputable","percentage","Math","round","loaded","total","uploading","push","lastIndex","max","queue","slice","FileReader","addEventListener","parser","process","env","NODE_ENV","includes","accept","s","ext"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/file-input/useFileUpload.ts"],"sourcesContent":["import type { ChangeEvent, DragEvent } from \"react\";\nimport { useCallback, useEffect, useReducer } from \"react\";\nimport { nanoid } from \"nanoid\";\nimport { omit } from \"@react-md/utils\";\n\nimport type {\n  CompletedFileUploadStats,\n  FileReaderResult,\n  FileUploadHandlers,\n  FileUploadStats,\n  FileValidationError,\n  FilesValidator,\n  GetFileParser,\n  ProcessingFileUploadStats,\n  FileValidationOptions,\n} from \"./utils\";\nimport {\n  getFileParser as defaultGetFileParser,\n  FileAccessError,\n  isValidFileName as defaultIsValidFileName,\n  validateFiles as defaultValidateFiles,\n} from \"./utils\";\n\n/**\n *\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadState<CustomError = never> {\n  /**\n   * All the files that have been validated and are either:\n   * - pending upload\n   * - uploading\n   * - complete\n   *\n   * Each key in this object is the {@link BaseFileUploadStats.key} generated\n   * once the upload starts pending.\n   */\n  stats: Readonly<Record<string, Readonly<FileUploadStats>>>;\n\n  /**\n   * A list of validation errors that have occurred before starting the upload\n   * process.\n   *\n   * @see {@link FileAccessError}\n   * @see {@link TooManyFilesError}\n   * @see {@link FileValidationError}\n   */\n  errors: readonly FileValidationError<CustomError>[];\n}\n\n/**\n *\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n * @internal\n */\nexport interface FileUploadHookState<CustomError = never>\n  extends FileUploadState<CustomError> {\n  /**\n   * All the current readers used for uploading files to the browser.\n   *\n   * Note: Once an upload has completed, the reader will be removed.\n   */\n  readers: Readonly<Record<string, FileReader>>;\n}\n\n/**\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadOptions<E extends HTMLElement, CustomError = never>\n  extends FileUploadHandlers<E>,\n    FileValidationOptions {\n  /**\n   * Setting this value to a number greater than `0` will update the browser\n   * upload process to queue the uploads in chunks instead of all at once. This\n   * can help prevent the browser from freezing if dealing with large files that\n   * are being converted to data urls.\n   *\n   * @defaultValue `-1`\n   */\n  concurrency?: number;\n\n  /** {@inheritDoc FilesValidator} */\n  validateFiles?: FilesValidator<CustomError>;\n  /** {@inheritDoc GetFileParser} */\n  getFileParser?: GetFileParser;\n}\n\n/** @internal */\ntype Action<E = never> =\n  | {\n      type: \"queue\";\n      errors: readonly FileValidationError<E>[];\n      files: readonly File[];\n    }\n  | { type: \"reset\" }\n  | { type: \"remove\"; files: readonly string[] }\n  | { type: \"start\"; key: string; reader: FileReader }\n  | { type: \"progress\"; key: string; progress: number }\n  | { type: \"complete\"; key: string; result: FileReaderResult }\n  | { type: \"clearErrors\" };\n\n/** @remarks \\@since 2.9.0 */\nexport interface FileUploadActions {\n  /**\n   * Reset everything related to uploads ensuring that all file readers have\n   * been aborted.\n   */\n  reset(): void;\n\n  /**\n   * Removes all the errors that exist in state without cancelling any of the\n   * uploads already in progress.\n   */\n  clearErrors(): void;\n\n  /**\n   * This function is used to cancel pending and uploading files or removing\n   * completed files.\n   *\n   * @param keyOrKeys - A single or list of {@link BaseFileUploadStats.key} to\n   * remove from state.\n   */\n  remove(keyOrKeys: string | readonly string[]): void;\n}\n\n/**\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @remarks \\@since 2.9.0\n */\nexport interface FileUploadHookReturnValue<\n  E extends HTMLElement = HTMLElement,\n  CustomError = never\n> extends FileUploadActions,\n    Required<FileUploadHandlers<E>> {\n  /** {@inheritDoc FileUploadState.errors} */\n  errors: readonly FileValidationError<CustomError>[];\n\n  /**\n   * A list of all the {@link FileUploadStats}.\n   *\n   * @see {@link getSplitFileUploads} for separating by status\n   */\n  stats: readonly Readonly<FileUploadStats>[];\n\n  /**\n   * The total number of bytes for all the files that exist in the\n   * {@link stats} list.\n   */\n  totalBytes: number;\n\n  /**\n   * The total number of files in the {@link stats} list.\n   */\n  totalFiles: number;\n\n  /**\n   * An `accept` string that can be passed to the {@link FileInput} component\n   * when the {@link FileValidationOptions.extensions} list has been provided to\n   * limit which files the OS will _attempt_ to allow access to.\n   *\n   * @example\n   * Simple example\n   * ```ts\n   * const extensions = ['pdf', 'docx', 'ppt'];\n   * const { accept } = useFileUpload({ extensions, ...others });\n   *\n   * expect(accept).toBe(\"*.pdf,*.docx,*.ppt\")\n   * ```\n   *\n   * @defaultValue `\"*\"`\n   */\n  accept: string;\n}\n\n/** @internal */\nconst EMPTY_LIST = [] as const;\n/** @internal */\nconst EMPTY_OBJECT = {} as const;\n\n/**\n * This hook is generally used to upload files **to the browser** in different\n * formats to be previewed `<img>`, `<video>`, `<embed>`, etc tags. However, it\n * can also be used to upload the files as an `ArrayBuffer` and then uploaded to\n * a server.\n *\n * Note: If using the `aws-sdk` to upload files directly to S3, **do not use\n * this hook** since it uses its own upload process.\n *\n * @typeParam E - An optional HTMLElement type that is used for the\n * {@link FileUploadHandlers}.\n * @typeParam CustomError - An optional error type that gets returned from the\n * {@link FilesValidator}.\n * @param options - All the {@link FileUploadOptions}\n * @returns the {@link FileUploadHookReturnValue}\n * @remarks \\@since 2.9.0\n */\nexport function useFileUpload<E extends HTMLElement, CustomError = never>({\n  maxFiles = -1,\n  extensions = EMPTY_LIST,\n  minFileSize = -1,\n  maxFileSize = -1,\n  totalFileSize = -1,\n  concurrency = -1,\n  onDrop: propOnDrop,\n  onChange: propOnChange,\n  validateFiles = defaultValidateFiles,\n  getFileParser = defaultGetFileParser,\n  isValidFileName = defaultIsValidFileName,\n}: FileUploadOptions<E, CustomError> = {}): Readonly<\n  FileUploadHookReturnValue<E, CustomError>\n> {\n  const [state, dispatch] = useReducer(\n    function reducer(\n      state: FileUploadHookState<CustomError>,\n      action: Action<CustomError>\n    ) {\n      switch (action.type) {\n        case \"reset\":\n          // need to reuse constants so that calling reset doesn't cause an\n          // infinite loop in an effect\n          return {\n            stats: EMPTY_OBJECT,\n            errors: EMPTY_LIST,\n            readers: EMPTY_OBJECT,\n          };\n        case \"remove\":\n          return {\n            ...state,\n            stats: omit(state.stats, action.files),\n          };\n        case \"queue\":\n          return {\n            ...state,\n            stats: {\n              ...state.stats,\n              ...action.files.reduce<Record<string, ProcessingFileUploadStats>>(\n                (files, file) => {\n                  const key = nanoid();\n                  files[key] = {\n                    key,\n                    file,\n                    progress: 0,\n                    status: \"pending\",\n                  };\n\n                  return files;\n                },\n                {}\n              ),\n            },\n            errors: [...state.errors, ...action.errors],\n          };\n        case \"start\": {\n          const { key, reader } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          const fileStats: ProcessingFileUploadStats = {\n            key,\n            file: state.stats[key].file,\n            progress: 0,\n            status: \"uploading\",\n          };\n\n          return {\n            ...state,\n            readers: {\n              ...state.readers,\n              [key]: reader,\n            },\n            stats: {\n              ...state.stats,\n              [key]: fileStats,\n            },\n          };\n        }\n        case \"progress\": {\n          const { key, progress } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          return {\n            ...state,\n            stats: {\n              ...state.stats,\n              [key]: {\n                ...state.stats[key],\n                progress,\n              },\n            },\n          };\n        }\n        case \"complete\": {\n          const { key, result } = action;\n          /* istanbul ignore next */\n          if (!state.stats[key]) {\n            throw new Error(`Missing file with key \"${key}\"`);\n          }\n\n          const file: CompletedFileUploadStats = {\n            key,\n            file: state.stats[key].file,\n            status: \"complete\",\n            result,\n            progress: 100,\n          };\n          const { [key]: _reader, ...readers } = state.readers;\n\n          return {\n            ...state,\n            readers,\n            stats: {\n              ...state.stats,\n              [key]: file,\n            },\n          };\n        }\n        case \"clearErrors\":\n          return { ...state, errors: [] };\n        default:\n          /* istanbul ignore next */\n          return state;\n      }\n    },\n    {\n      stats: EMPTY_OBJECT,\n      errors: EMPTY_LIST,\n      readers: EMPTY_OBJECT,\n    }\n  );\n  const { stats, errors, readers } = state;\n\n  const statsList = Object.values(stats);\n  const totalFiles = statsList.length;\n  const totalBytes = statsList.reduce(\n    (result, { file: { size } }) => result + size,\n    0\n  );\n  const queueFiles = useCallback(\n    (files: readonly File[]) => {\n      const { pending, errors } = validateFiles(files, {\n        maxFiles,\n        extensions,\n        minFileSize,\n        maxFileSize,\n        totalBytes,\n        totalFiles,\n        totalFileSize,\n        isValidFileName,\n      });\n\n      dispatch({ type: \"queue\", errors, files: pending });\n    },\n    [\n      validateFiles,\n      maxFiles,\n      extensions,\n      minFileSize,\n      maxFileSize,\n      totalBytes,\n      totalFiles,\n      totalFileSize,\n      isValidFileName,\n    ]\n  );\n  const onDrop = useCallback(\n    (event: DragEvent<E>) => {\n      propOnDrop?.(event);\n      event.preventDefault();\n      event.stopPropagation();\n\n      try {\n        const files = event.dataTransfer.files;\n        if (files) {\n          queueFiles(Array.from(files));\n        }\n      } catch (e) {\n        dispatch({\n          type: \"queue\",\n          files: [],\n          errors: [\n            new FileAccessError(e instanceof Error ? e.message : undefined),\n          ],\n        });\n      }\n    },\n    [queueFiles, propOnDrop]\n  );\n  const onChange = useCallback(\n    (event: ChangeEvent<HTMLInputElement>) => {\n      propOnChange?.(event);\n      try {\n        const files = event.currentTarget.files;\n        if (files) {\n          queueFiles(Array.from(files));\n        } else {\n          throw new Error();\n        }\n      } catch (e) {\n        dispatch({\n          type: \"queue\",\n          files: [],\n          errors: [\n            new FileAccessError(e instanceof Error ? e.message : undefined),\n          ],\n        });\n      }\n    },\n    [queueFiles, propOnChange]\n  );\n\n  const remove = useCallback(\n    (keyOrKeys: string | readonly string[]) => {\n      const files = typeof keyOrKeys === \"string\" ? [keyOrKeys] : keyOrKeys;\n      files.forEach((fileKey) => {\n        readers[fileKey]?.abort();\n      });\n\n      dispatch({ type: \"remove\", files });\n    },\n    [readers]\n  );\n  const reset = useCallback(() => {\n    Object.values(readers).forEach((reader) => {\n      reader.abort();\n    });\n\n    dispatch({ type: \"reset\" });\n  }, [readers]);\n  const clearErrors = useCallback(() => {\n    dispatch({ type: \"clearErrors\" });\n  }, []);\n  const start = useCallback((key: string, reader: FileReader) => {\n    dispatch({ type: \"start\", key, reader });\n  }, []);\n  const complete = useCallback(\n    (key: string, result: FileReaderResult = null) => {\n      dispatch({ type: \"complete\", key, result });\n    },\n    []\n  );\n  const createProgressEventHandler = useCallback(\n    (key: string) => (event: ProgressEvent) => {\n      if (event.lengthComputable) {\n        const percentage = Math.round((event.loaded * 100) / event.total);\n        dispatch({ type: \"progress\", key, progress: percentage });\n      }\n    },\n    []\n  );\n\n  useEffect(() => {\n    const pending: ProcessingFileUploadStats[] = [];\n    const uploading: ProcessingFileUploadStats[] = [];\n    Object.values(stats).forEach((file) => {\n      if (file.status === \"pending\") {\n        pending.push(file);\n      } else if (file.status === \"uploading\") {\n        uploading.push(file);\n      }\n    });\n\n    const lastIndex =\n      concurrency === -1\n        ? pending.length\n        : Math.max(0, concurrency - uploading.length);\n    const queue = pending.slice(0, lastIndex);\n    if (!queue.length) {\n      return;\n    }\n\n    queue.forEach((stats) => {\n      const { key, file } = stats;\n      const reader = new FileReader();\n\n      // using `addEventListener` instead of directly setting to\n      // `reader.progress`/`reader.load` so it's easier to test\n      reader.addEventListener(\"progress\", createProgressEventHandler(key));\n      reader.addEventListener(\"load\", () => {\n        complete(key, reader.result);\n      });\n\n      start(key, reader);\n      const parser = getFileParser(file);\n      /* istanbul ignore next */\n      if (\n        process.env.NODE_ENV !== \"production\" &&\n        ![\n          \"readAsText\",\n          \"readAsDataURL\",\n          \"readAsArrayBuffer\",\n          \"readAsBinaryString\",\n        ].includes(parser)\n      ) {\n        throw new Error(\"Invalid file reader parser\");\n      }\n\n      reader[parser](file);\n    });\n  }, [\n    concurrency,\n    stats,\n    getFileParser,\n    createProgressEventHandler,\n    start,\n    complete,\n  ]);\n\n  let accept = \"\";\n  if (extensions.length) {\n    accept = extensions.reduce((s, ext) => `${s ? `${s},` : \"\"}.${ext}`, \"\");\n  }\n\n  return {\n    stats: statsList,\n    errors,\n    accept,\n    totalBytes,\n    totalFiles,\n    onDrop,\n    onChange,\n    reset,\n    remove,\n    clearErrors,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}