{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useRef, useState } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n/**\n * @internal\n */\nvar TOUCH_TIMEOUT = 1200;\n/**\n * This hook helps determine the current interaction mode by attaching the\n * required event listeners to the window. The `mode` will always be defaulted\n * to `mouse` at first since it has the least possibilities of causing errors\n * with styles since the mouse-only styles are normally just `:hover` effects.\n *\n * ## Switching between modes:\n *\n * ### While in `mouse` mode:\n *\n * - any `keydown` event will switch to `keyboard` mode\n *   - this does have the side effect of meta keys also causing the switch over,\n *     but it feels fine since it helps show the current focus in the document\n *     as well\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `keyboard` mode:\n *\n * - any `mousedown` event will switch to `mouse` mode\n *   - it is perfectly okay to move the mouse while in keyboard mode, but still\n *     want to keep the keyboard styles until the user actually starts clicking\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `touch` mode:\n *\n * - any `mousemove` event will switch to `mouse` mode, but **only** if there\n *   hasn't been a `contextmenu` event within the last `1.2s`\n *   - you can really only switch back to `mouse` mode if you are using the\n *     devtools to emulate devices OR using a touch-desktop. I don't know how\n *     common this really is though.\n *   - touching the screen will always fire a `mousemove` event (which is why\n *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even\n *     after the `contextmenu` event. Normally want to go back to `mouse` mode\n *     when the mouse re-enters the `window`\n *\n * Note: It's currently impossible to switch from `touch` to `keyboard`\n * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I\n * don't really know of any use-cases other than the weird touch-desktop stuff\n * and I have no experience using them.\n *\n * @internal\n */\nexport function useInteractionMode() {\n  var _a = __read(useState(\"mouse\"), 2),\n    mode = _a[0],\n    setMode = _a[1];\n  var lastTouchTime = useRef(0);\n  var isTouchContextMenu = useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    var enableMouseMode = function () {\n      return setMode(\"mouse\");\n    };\n    var enableKeyboardMode = function () {\n      return setMode(\"keyboard\");\n    };\n    var handleTouchStart = function () {\n      lastTouchTime.current = Date.now();\n      isTouchContextMenu.current = false;\n      setMode(\"touch\");\n    };\n    var handleMouseMove = function () {\n      if (isTouchContextMenu.current || Date.now() - lastTouchTime.current < TOUCH_TIMEOUT) {\n        isTouchContextMenu.current = false;\n        return;\n      }\n      enableMouseMode();\n    };\n    var handleContextMenu = function () {\n      isTouchContextMenu.current = true;\n    };\n    var className = \"rmd-utils--\".concat(mode);\n    document.body.classList.add(className);\n    window.addEventListener(\"touchstart\", handleTouchStart, true);\n    if (mode === \"mouse\") {\n      window.addEventListener(\"keydown\", enableKeyboardMode, true);\n    } else if (mode === \"keyboard\") {\n      window.addEventListener(\"mousedown\", enableMouseMode, true);\n    } else {\n      window.addEventListener(\"mousemove\", handleMouseMove, true);\n      window.addEventListener(\"contextmenu\", handleContextMenu, true);\n    }\n    return function () {\n      document.body.classList.remove(className);\n      window.removeEventListener(\"touchstart\", handleTouchStart, true);\n      if (mode === \"mouse\") {\n        window.removeEventListener(\"keydown\", enableKeyboardMode, true);\n      } else if (mode === \"keyboard\") {\n        window.removeEventListener(\"mousedown\", enableMouseMode, true);\n      } else {\n        window.removeEventListener(\"mousemove\", handleMouseMove, true);\n        window.removeEventListener(\"contextmenu\", handleContextMenu, true);\n      }\n    };\n  }, [mode]);\n  return mode;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAGxC,SAASC,yBAAyB,QAAQ,8BAA8B;AAExE;;;AAGA,IAAMC,aAAa,GAAG,IAAI;AAE1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA,OAAM,SAAUC,kBAAkB;EAC1B,gBAAkBH,QAAQ,CAAsB,OAAO,CAAC;IAAvDI,IAAI;IAAEC,OAAO,QAA0C;EAC9D,IAAMC,aAAa,GAAGP,MAAM,CAAC,CAAC,CAAC;EAC/B,IAAMQ,kBAAkB,GAAGR,MAAM,CAAC,KAAK,CAAC;EAExCE,yBAAyB,CAAC;IACxB,IAAMO,eAAe,GAAG;MAAY,cAAO,CAAC,OAAO,CAAC;IAAhB,CAAgB;IACpD,IAAMC,kBAAkB,GAAG;MAAY,cAAO,CAAC,UAAU,CAAC;IAAnB,CAAmB;IAE1D,IAAMC,gBAAgB,GAAG;MACvBJ,aAAa,CAACK,OAAO,GAAGC,IAAI,CAACC,GAAG,EAAE;MAClCN,kBAAkB,CAACI,OAAO,GAAG,KAAK;MAClCN,OAAO,CAAC,OAAO,CAAC;IAClB,CAAC;IAED,IAAMS,eAAe,GAAG;MACtB,IACEP,kBAAkB,CAACI,OAAO,IAC1BC,IAAI,CAACC,GAAG,EAAE,GAAGP,aAAa,CAACK,OAAO,GAAGT,aAAa,EAClD;QACAK,kBAAkB,CAACI,OAAO,GAAG,KAAK;QAClC;;MAGFH,eAAe,EAAE;IACnB,CAAC;IACD,IAAMO,iBAAiB,GAAG;MACxBR,kBAAkB,CAACI,OAAO,GAAG,IAAI;IACnC,CAAC;IAED,IAAMK,SAAS,GAAG,qBAAcZ,IAAI,CAAE;IACtCa,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACC,GAAG,CAACJ,SAAS,CAAC;IACtCK,MAAM,CAACC,gBAAgB,CAAC,YAAY,EAAEZ,gBAAgB,EAAE,IAAI,CAAC;IAC7D,IAAIN,IAAI,KAAK,OAAO,EAAE;MACpBiB,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEb,kBAAkB,EAAE,IAAI,CAAC;KAC7D,MAAM,IAAIL,IAAI,KAAK,UAAU,EAAE;MAC9BiB,MAAM,CAACC,gBAAgB,CAAC,WAAW,EAAEd,eAAe,EAAE,IAAI,CAAC;KAC5D,MAAM;MACLa,MAAM,CAACC,gBAAgB,CAAC,WAAW,EAAER,eAAe,EAAE,IAAI,CAAC;MAC3DO,MAAM,CAACC,gBAAgB,CAAC,aAAa,EAAEP,iBAAiB,EAAE,IAAI,CAAC;;IAGjE,OAAO;MACLE,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACI,MAAM,CAACP,SAAS,CAAC;MACzCK,MAAM,CAACG,mBAAmB,CAAC,YAAY,EAAEd,gBAAgB,EAAE,IAAI,CAAC;MAChE,IAAIN,IAAI,KAAK,OAAO,EAAE;QACpBiB,MAAM,CAACG,mBAAmB,CAAC,SAAS,EAAEf,kBAAkB,EAAE,IAAI,CAAC;OAChE,MAAM,IAAIL,IAAI,KAAK,UAAU,EAAE;QAC9BiB,MAAM,CAACG,mBAAmB,CAAC,WAAW,EAAEhB,eAAe,EAAE,IAAI,CAAC;OAC/D,MAAM;QACLa,MAAM,CAACG,mBAAmB,CAAC,WAAW,EAAEV,eAAe,EAAE,IAAI,CAAC;QAC9DO,MAAM,CAACG,mBAAmB,CAAC,aAAa,EAAET,iBAAiB,EAAE,IAAI,CAAC;;IAEtE,CAAC;EACH,CAAC,EAAE,CAACX,IAAI,CAAC,CAAC;EAEV,OAAOA,IAAI;AACb","names":["useRef","useState","useIsomorphicLayoutEffect","TOUCH_TIMEOUT","useInteractionMode","mode","setMode","lastTouchTime","isTouchContextMenu","enableMouseMode","enableKeyboardMode","handleTouchStart","current","Date","now","handleMouseMove","handleContextMenu","className","document","body","classList","add","window","addEventListener","remove","removeEventListener"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/mode/useInteractionMode.ts"],"sourcesContent":["import { useRef, useState } from \"react\";\n\nimport type { UserInteractionMode } from \"./types\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n\n/**\n * @internal\n */\nconst TOUCH_TIMEOUT = 1200;\n\n/**\n * This hook helps determine the current interaction mode by attaching the\n * required event listeners to the window. The `mode` will always be defaulted\n * to `mouse` at first since it has the least possibilities of causing errors\n * with styles since the mouse-only styles are normally just `:hover` effects.\n *\n * ## Switching between modes:\n *\n * ### While in `mouse` mode:\n *\n * - any `keydown` event will switch to `keyboard` mode\n *   - this does have the side effect of meta keys also causing the switch over,\n *     but it feels fine since it helps show the current focus in the document\n *     as well\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `keyboard` mode:\n *\n * - any `mousedown` event will switch to `mouse` mode\n *   - it is perfectly okay to move the mouse while in keyboard mode, but still\n *     want to keep the keyboard styles until the user actually starts clicking\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `touch` mode:\n *\n * - any `mousemove` event will switch to `mouse` mode, but **only** if there\n *   hasn't been a `contextmenu` event within the last `1.2s`\n *   - you can really only switch back to `mouse` mode if you are using the\n *     devtools to emulate devices OR using a touch-desktop. I don't know how\n *     common this really is though.\n *   - touching the screen will always fire a `mousemove` event (which is why\n *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even\n *     after the `contextmenu` event. Normally want to go back to `mouse` mode\n *     when the mouse re-enters the `window`\n *\n * Note: It's currently impossible to switch from `touch` to `keyboard`\n * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I\n * don't really know of any use-cases other than the weird touch-desktop stuff\n * and I have no experience using them.\n *\n * @internal\n */\nexport function useInteractionMode(): UserInteractionMode {\n  const [mode, setMode] = useState<UserInteractionMode>(\"mouse\");\n  const lastTouchTime = useRef(0);\n  const isTouchContextMenu = useRef(false);\n\n  useIsomorphicLayoutEffect(() => {\n    const enableMouseMode = (): void => setMode(\"mouse\");\n    const enableKeyboardMode = (): void => setMode(\"keyboard\");\n\n    const handleTouchStart = (): void => {\n      lastTouchTime.current = Date.now();\n      isTouchContextMenu.current = false;\n      setMode(\"touch\");\n    };\n\n    const handleMouseMove = (): void => {\n      if (\n        isTouchContextMenu.current ||\n        Date.now() - lastTouchTime.current < TOUCH_TIMEOUT\n      ) {\n        isTouchContextMenu.current = false;\n        return;\n      }\n\n      enableMouseMode();\n    };\n    const handleContextMenu = (): void => {\n      isTouchContextMenu.current = true;\n    };\n\n    const className = `rmd-utils--${mode}`;\n    document.body.classList.add(className);\n    window.addEventListener(\"touchstart\", handleTouchStart, true);\n    if (mode === \"mouse\") {\n      window.addEventListener(\"keydown\", enableKeyboardMode, true);\n    } else if (mode === \"keyboard\") {\n      window.addEventListener(\"mousedown\", enableMouseMode, true);\n    } else {\n      window.addEventListener(\"mousemove\", handleMouseMove, true);\n      window.addEventListener(\"contextmenu\", handleContextMenu, true);\n    }\n\n    return () => {\n      document.body.classList.remove(className);\n      window.removeEventListener(\"touchstart\", handleTouchStart, true);\n      if (mode === \"mouse\") {\n        window.removeEventListener(\"keydown\", enableKeyboardMode, true);\n      } else if (mode === \"keyboard\") {\n        window.removeEventListener(\"mousedown\", enableMouseMode, true);\n      } else {\n        window.removeEventListener(\"mousemove\", handleMouseMove, true);\n        window.removeEventListener(\"contextmenu\", handleContextMenu, true);\n      }\n    };\n  }, [mode]);\n\n  return mode;\n}\n"]},"metadata":{},"sourceType":"module"}