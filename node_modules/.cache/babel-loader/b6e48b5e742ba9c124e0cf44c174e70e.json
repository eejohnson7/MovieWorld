{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef } from \"react\";\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { useFocusOnMount } from \"./useFocusOnMount\";\nimport { usePreviousFocus } from \"./usePreviousFocus\";\nimport { useTabFocusWrap } from \"./useTabFocusWrap\";\n/**\n * The `FocusContainer` is a wrapper for a few of the accessibility hooks to\n * maintain focus within an element.\n */\nexport var FocusContainer = forwardRef(function FocusContainer(_a, forwardedRef) {\n  var children = _a.children,\n    onKeyDown = _a.onKeyDown,\n    _b = _a.component,\n    Component = _b === void 0 ? \"div\" : _b,\n    _c = _a.defaultFocus,\n    defaultFocus = _c === void 0 ? \"first\" : _c,\n    _d = _a.disableFocusCache,\n    disableFocusCache = _d === void 0 ? false : _d,\n    _e = _a.disableFocusOnMount,\n    disableFocusOnMount = _e === void 0 ? false : _e,\n    _f = _a.disableFocusOnMountScroll,\n    disableFocusOnMountScroll = _f === void 0 ? false : _f,\n    _g = _a.disableFocusOnUnmount,\n    disableFocusOnUnmount = _g === void 0 ? false : _g,\n    _h = _a.disableTabFocusWrap,\n    disableTabFocusWrap = _h === void 0 ? false : _h,\n    _j = _a.unmountFocusFallback,\n    unmountFocusFallback = _j === void 0 ? \"\" : _j,\n    props = __rest(_a, [\"children\", \"onKeyDown\", \"component\", \"defaultFocus\", \"disableFocusCache\", \"disableFocusOnMount\", \"disableFocusOnMountScroll\", \"disableFocusOnUnmount\", \"disableTabFocusWrap\", \"unmountFocusFallback\"]);\n  var _k = __read(useEnsuredRef(forwardedRef), 2),\n    ref = _k[0],\n    refHandler = _k[1];\n  usePreviousFocus(disableFocusOnUnmount, unmountFocusFallback);\n  useFocusOnMount(ref, defaultFocus, disableFocusOnMountScroll, false, disableFocusOnMount);\n  var handleKeyDown = useTabFocusWrap({\n    disabled: disableTabFocusWrap,\n    disableFocusCache: disableFocusCache,\n    onKeyDown: onKeyDown\n  });\n  return _jsx(Component, __assign({}, props, {\n    onKeyDown: handleKeyDown,\n    ref: refHandler\n  }, {\n    children: children\n  }));\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,UAAU,QAAQ,OAAO;AAElC,SAASC,aAAa,QAAQ,kBAAkB;AAChD,SAASC,eAAe,QAAQ,mBAAmB;AAEnD,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,SAASC,eAAe,QAAQ,mBAAmB;AAmFnD;;;;AAIA,OAAO,IAAMC,cAAc,GAAGL,UAAU,CACtC,SAASK,cAAc,CACrBC,EAYC,EACDC,YAAY;EAZV,YAAQ;IACRC,SAAS;IACTC,iBAA4B;IAAjBC,SAAS,mBAAG,KAAK;IAC5BC,oBAAsB;IAAtBC,YAAY,mBAAG,OAAO;IACtBC,yBAAyB;IAAzBC,iBAAiB,mBAAG,KAAK;IACzBC,2BAA2B;IAA3BC,mBAAmB,mBAAG,KAAK;IAC3BC,iCAAiC;IAAjCC,yBAAyB,mBAAG,KAAK;IACjCC,6BAA6B;IAA7BC,qBAAqB,mBAAG,KAAK;IAC7BC,2BAA2B;IAA3BC,mBAAmB,mBAAG,KAAK;IAC3BC,4BAAyB;IAAzBC,oBAAoB,mBAAG,EAAE;IACtBC,KAAK,cAXV,uMAYC,CADS;EAIJ,gBAAoBxB,aAAa,CAACM,YAAY,CAAC;IAA9CmB,GAAG;IAAEC,UAAU,QAA+B;EAErDxB,gBAAgB,CAACiB,qBAAqB,EAAEI,oBAAoB,CAAC;EAC7DtB,eAAe,CACbwB,GAAG,EACHd,YAAY,EACZM,yBAAyB,EACzB,KAAK,EACLF,mBAAmB,CACpB;EACD,IAAMY,aAAa,GAAGxB,eAAe,CAAC;IACpCyB,QAAQ,EAAEP,mBAAmB;IAC7BR,iBAAiB;IACjBN,SAAS;GACV,CAAC;EAEF,OACEsB,KAACpB,SAAS,eAAKe,KAAK;IAAEjB,SAAS,EAAEoB,aAAa;IAAEF,GAAG,EAAEC;EAAU;IAAAI,UAC5DA;EAAQ,GACC;AAEhB,CAAC,CACF","names":["forwardRef","useEnsuredRef","useFocusOnMount","usePreviousFocus","useTabFocusWrap","FocusContainer","_a","forwardedRef","onKeyDown","_b","Component","_c","defaultFocus","_d","disableFocusCache","_e","disableFocusOnMount","_f","disableFocusOnMountScroll","_g","disableFocusOnUnmount","_h","disableTabFocusWrap","_j","unmountFocusFallback","props","ref","refHandler","handleKeyDown","disabled","_jsx","children"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/wia-aria/FocusContainer.tsx"],"sourcesContent":["import type { ElementType, HTMLAttributes, ReactElement } from \"react\";\nimport { forwardRef } from \"react\";\n\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { useFocusOnMount } from \"./useFocusOnMount\";\nimport type { FocusFallback } from \"./usePreviousFocus\";\nimport { usePreviousFocus } from \"./usePreviousFocus\";\nimport { useTabFocusWrap } from \"./useTabFocusWrap\";\n\nexport interface FocusContainerOptionsProps {\n  /**\n   * By default, the focus container will try to maintain a cache of the\n   * focusable elements that is updated only when this component re-renders. If\n   * the children are extremely dynamic and focusable elements can be\n   * removed/added without this component updating, you should disable the cache\n   * so that the focusable elements are updated each time the tab key is\n   * pressed. Disabling the cache will be slightly slower for larger focusable\n   * areas, but it might not be too bad.\n   *\n   * NOTE: The only important elements are the *first* and *last* elements in\n   * this list.  So if your children aren't changing the first and last\n   * elements, there's no need to disable the cache.\n   */\n  disableFocusCache?: boolean;\n\n  /**\n   * The default behavior for the focus container is to focus an element once it\n   * is mounted and the `disabled` prop is not enabled. This behavior can be\n   * disabled if this is not wanted for some reason.\n   */\n  disableFocusOnMount?: boolean;\n\n  /**\n   * Boolean if the focus behavior should be disabled. This should really be\n   * used if you are using nested focus containers for temporary material (such\n   * as dialogs or menus).\n   */\n  disableTabFocusWrap?: boolean;\n\n  /**\n   * Boolean if the element that gets focused on mount should try to not scroll\n   * the focused element into view which is the default behavior. This should\n   * normally remain `false`, but it is useful to set to `true` if the\n   * `FocusContainer` is within a transition that appears offscreen.\n   */\n  disableFocusOnMountScroll?: boolean;\n\n  /**\n   * The default behavior for the focus container is to attempt to focus the\n   * element that was focused before the focus container was mounted since it is\n   * generally used for temporary material. If there are cases where this\n   * behavior is not wanted, you can enable this prop.\n   */\n  disableFocusOnUnmount?: boolean;\n\n  /**\n   * This is the element that should be focused by default when the component is\n   * mounted.  This can either be the first or last focusable item or a query\n   * selector string that is run against this component to focus.\n   */\n  defaultFocus?: \"first\" | \"last\" | string;\n\n  /**\n   * When the focus container unmounts, it will attempt to re-focus the element\n   * that was focused before the focus container was mounted unless the\n   * `disableFocusOnUnmount` prop is enabled. There might be cases where\n   * unmounting the focus container causes the page to re-render and the\n   * previous element no longer exists. When this happens keyboard users _might_\n   * have a problem navigating through the page again depending on how the\n   * browser implemented the native tab behavior so this prop allows you to\n   * ensure that a specific element is focused in these cases.\n   *\n   * This can either be a query selector string, a specific HTMLElement, or a\n   * function that finds a specific HTMLElement to focus.\n   */\n  unmountFocusFallback?: FocusFallback;\n}\n\nexport interface FocusContainerProps\n  extends FocusContainerOptionsProps,\n    HTMLAttributes<HTMLElement> {\n  /**\n   * The component to render the focus container as. This should really not be\n   * used as it is more for internal usage. The only base requirements for this\n   * prop is that it must either be a element string (`\"div\"`, `\"span\"`, etc) or\n   * a custom component that has forwarded the ref to the DOM node.\n   */\n  component?: ElementType;\n}\n\n/**\n * The `FocusContainer` is a wrapper for a few of the accessibility hooks to\n * maintain focus within an element.\n */\nexport const FocusContainer = forwardRef<HTMLDivElement, FocusContainerProps>(\n  function FocusContainer(\n    {\n      children,\n      onKeyDown,\n      component: Component = \"div\",\n      defaultFocus = \"first\",\n      disableFocusCache = false,\n      disableFocusOnMount = false,\n      disableFocusOnMountScroll = false,\n      disableFocusOnUnmount = false,\n      disableTabFocusWrap = false,\n      unmountFocusFallback = \"\",\n      ...props\n    },\n    forwardedRef\n  ): ReactElement {\n    const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n    usePreviousFocus(disableFocusOnUnmount, unmountFocusFallback);\n    useFocusOnMount(\n      ref,\n      defaultFocus,\n      disableFocusOnMountScroll,\n      false,\n      disableFocusOnMount\n    );\n    const handleKeyDown = useTabFocusWrap({\n      disabled: disableTabFocusWrap,\n      disableFocusCache,\n      onKeyDown,\n    });\n\n    return (\n      <Component {...props} onKeyDown={handleKeyDown} ref={refHandler}>\n        {children}\n      </Component>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}