{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useMemo } from \"react\";\nimport { useTempValue } from \"../useTempValue\";\nimport { findMatchIndex as DEFAULT_FIND_MATCH_INDEX } from \"./findMatchIndex\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_SEARCH_RESET_TIME, DEFAULT_VALUE_KEY } from \"./utils\";\n/**\n * Adds the accessibility functionality to search a list of items as the user\n * types to trigger `aria-activedescendant` focus or manual DOM focus events.\n */\nexport function useKeyboardSearch(_a) {\n  var items = _a.items,\n    onChange = _a.onChange,\n    onKeyDown = _a.onKeyDown,\n    _b = _a.resetTime,\n    resetTime = _b === void 0 ? DEFAULT_SEARCH_RESET_TIME : _b,\n    searchIndex = _a.searchIndex,\n    _c = _a.valueKey,\n    valueKey = _c === void 0 ? DEFAULT_VALUE_KEY : _c,\n    _d = _a.getItemValue,\n    getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d,\n    _e = _a.findMatchIndex,\n    findMatchIndex = _e === void 0 ? DEFAULT_FIND_MATCH_INDEX : _e;\n  var _f = __read(useTempValue(\"\", resetTime), 2),\n    value = _f[0],\n    setValue = _f[1];\n  var values = useMemo(function () {\n    return items.map(function (item) {\n      return getItemValue(item, valueKey);\n    });\n  }, [items, getItemValue, valueKey]);\n  var handleKeyDown = useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    var key = event.key,\n      altKey = event.altKey,\n      ctrlKey = event.ctrlKey,\n      metaKey = event.metaKey;\n    if (altKey || ctrlKey || metaKey || key.length > 1 || !value.current && key === \" \") {\n      // might need to change this later if other languages have non-meta keys\n      // that are more than 1 letter\n      return;\n    }\n    var nextValue = key;\n    if (value.current !== key) {\n      nextValue = \"\".concat(value.current).concat(key);\n    }\n    setValue(nextValue);\n    var index = findMatchIndex(nextValue, values, searchIndex, true);\n    // don't want to trigger change events if the search didn't match anything\n    // since you normally don't really care about failed matches\n    if (index === searchIndex || index === -1) {\n      return;\n    }\n    var data = {\n      index: index,\n      item: items[index],\n      items: items,\n      query: nextValue,\n      target: event.currentTarget\n    };\n    onChange(data);\n  }, [searchIndex, findMatchIndex, items, onChange, onKeyDown, setValue, value, values]);\n  return handleKeyDown;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAW,EAAEC,OAAO,QAAQ,OAAO;AAE5C,SAASC,YAAY,QAAQ,iBAAiB;AAE9C,SAASC,cAAc,IAAIC,wBAAwB,QAAQ,kBAAkB;AAE7E,SACEC,sBAAsB,EACtBC,yBAAyB,EACzBC,iBAAiB,QACZ,SAAS;AAgGhB;;;;AAIA,OAAM,SAAUC,iBAAiB,CAG/BC,EAS4B;MAR5BC,KAAK;IACLC,QAAQ;IACRC,SAAS;IACTC,iBAAqC;IAArCC,SAAS,mBAAGR,yBAAyB;IACrCS,WAAW;IACXC,gBAA4B;IAA5BC,QAAQ,mBAAGV,iBAAiB;IAC5BW,oBAAqC;IAArCC,YAAY,mBAAGd,sBAAsB;IACrCe,sBAAyC;IAAzCjB,cAAc,mBAAGC,wBAAwB;EAEnC,gBAAoBF,YAAY,CAAC,EAAE,EAAEY,SAAS,CAAC;IAA9CO,KAAK;IAAEC,QAAQ,QAA+B;EACrD,IAAMC,MAAM,GAAGtB,OAAO,CACpB;IAAM,YAAK,CAACuB,GAAG,CAAC,UAACC,IAAI;MAAK,mBAAY,CAACA,IAAI,EAAER,QAAQ,CAAC;IAA5B,CAA4B,CAAC;EAAjD,CAAiD,EACvD,CAACP,KAAK,EAAES,YAAY,EAAEF,QAAQ,CAAC,CAChC;EAED,IAAMS,aAAa,GAAG1B,WAAW,CAC/B,UAAC2B,KAAK;IACJ,IAAIf,SAAS,EAAE;MACbA,SAAS,CAACe,KAAK,CAAC;;IAGV,OAAG,GAA+BA,KAAK,IAApC;MAAEC,MAAM,GAAuBD,KAAK,OAA5B;MAAEE,OAAO,GAAcF,KAAK,QAAnB;MAAEG,OAAO,GAAKH,KAAK,QAAV;IACrC,IACEC,MAAM,IACNC,OAAO,IACPC,OAAO,IACPC,GAAG,CAACC,MAAM,GAAG,CAAC,IACb,CAACX,KAAK,CAACY,OAAO,IAAIF,GAAG,KAAK,GAAI,EAC/B;MACA;MACA;MACA;;IAGF,IAAIG,SAAS,GAAGH,GAAG;IACnB,IAAIV,KAAK,CAACY,OAAO,KAAKF,GAAG,EAAE;MACzBG,SAAS,GAAG,UAAGb,KAAK,CAACY,OAAO,SAAGF,GAAG,CAAE;;IAEtCT,QAAQ,CAACY,SAAS,CAAC;IAEnB,IAAMC,KAAK,GAAGhC,cAAc,CAAC+B,SAAS,EAAEX,MAAM,EAAER,WAAW,EAAE,IAAI,CAAC;IAClE;IACA;IACA,IAAIoB,KAAK,KAAKpB,WAAW,IAAIoB,KAAK,KAAK,CAAC,CAAC,EAAE;MACzC;;IAGF,IAAMC,IAAI,GAAqB;MAC7BD,KAAK;MACLV,IAAI,EAAEf,KAAK,CAACyB,KAAK,CAAC;MAClBzB,KAAK;MACL2B,KAAK,EAAEH,SAAS;MAChBI,MAAM,EAAEX,KAAK,CAACY;KACf;IAED5B,QAAQ,CAACyB,IAAI,CAAC;EAChB,CAAC,EACD,CACErB,WAAW,EACXZ,cAAc,EACdO,KAAK,EACLC,QAAQ,EACRC,SAAS,EACTU,QAAQ,EACRD,KAAK,EACLE,MAAM,CACP,CACF;EAED,OAAOG,aAAa;AACtB","names":["useCallback","useMemo","useTempValue","findMatchIndex","DEFAULT_FIND_MATCH_INDEX","DEFAULT_GET_ITEM_VALUE","DEFAULT_SEARCH_RESET_TIME","DEFAULT_VALUE_KEY","useKeyboardSearch","_a","items","onChange","onKeyDown","_b","resetTime","searchIndex","_c","valueKey","_d","getItemValue","_e","value","setValue","values","map","item","handleKeyDown","event","altKey","ctrlKey","metaKey","key","length","current","nextValue","index","data","query","target","currentTarget"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/search/useKeyboardSearch.ts"],"sourcesContent":["import { useCallback, useMemo } from \"react\";\n\nimport { useTempValue } from \"../useTempValue\";\nimport type { FindMatchIndex } from \"./findMatchIndex\";\nimport { findMatchIndex as DEFAULT_FIND_MATCH_INDEX } from \"./findMatchIndex\";\nimport type { BaseSearchOptions } from \"./utils\";\nimport {\n  DEFAULT_GET_ITEM_VALUE,\n  DEFAULT_SEARCH_RESET_TIME,\n  DEFAULT_VALUE_KEY,\n} from \"./utils\";\n\n/**\n * The data that is provided to the `onChange` handler when searching. This will\n * be triggered whenever the user types a letter that causes the current search\n * result to change.\n */\nexport interface SearchData<D = unknown, E extends HTMLElement = HTMLElement> {\n  /**\n   * The item that was matched from the latest search.\n   */\n  readonly item: D;\n\n  /**\n   * The current list of items that were provided to be searched.\n   */\n  readonly items: readonly D[];\n\n  /**\n   * The index in the `items` array that the found item appears at. This is\n   * super useful when extending this hook to be used with\n   * `aria-activedescendant` focus movement or manual focus behavior since the\n   * `items` array should normally be the same indexes as the DOM nodes.\n   */\n  readonly index: number;\n\n  /**\n   * The search value that was used to find this item and trigger the change\n   * event.\n   */\n  readonly query: string;\n\n  /**\n   * The current target for the search keydown event.\n   */\n  readonly target: E;\n}\n\nexport type SearchChangeEvent<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> = (data: SearchData<D, E>) => void;\n\nexport interface BaseKeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseSearchOptions<D> {\n  /**\n   * The list of items that should be searched whenever the user types a letter.\n   */\n  items: readonly D[];\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange: SearchChangeEvent<D, E>;\n\n  /**\n   * An optional `onKeyDown` event handler that should be merged with the search\n   * functionality.\n   *\n   * Note: This will be called **before** the search functionality is triggered.\n   */\n  onKeyDown?: React.KeyboardEventHandler<E>;\n\n  /**\n   * The amount of time that a \"search\" value should be kept before resetting.\n   * The default value works for most cases, but it might be nice to configure\n   * it based on your use case.\n   */\n  resetTime?: number;\n\n  /**\n   * The function used to find a match index within the `items` list. You most\n   * likely won't want to change this.\n   */\n  findMatchIndex?: FindMatchIndex;\n}\n\nexport interface KeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseKeyboardSearchOptions<D, E> {\n  /**\n   * The current index that should be \"focused\" due to a keyboard search. This\n   * should be updated whenever the `onChange` callback is fired.\n   */\n  searchIndex: number;\n}\n\ntype ReturnValue<E extends HTMLElement = HTMLElement> =\n  React.KeyboardEventHandler<E>;\n\n/**\n * Adds the accessibility functionality to search a list of items as the user\n * types to trigger `aria-activedescendant` focus or manual DOM focus events.\n */\nexport function useKeyboardSearch<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n>({\n  items,\n  onChange,\n  onKeyDown,\n  resetTime = DEFAULT_SEARCH_RESET_TIME,\n  searchIndex,\n  valueKey = DEFAULT_VALUE_KEY,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n  findMatchIndex = DEFAULT_FIND_MATCH_INDEX,\n}: KeyboardSearchOptions<D, E>): ReturnValue<E> {\n  const [value, setValue] = useTempValue(\"\", resetTime);\n  const values = useMemo(\n    () => items.map((item) => getItemValue(item, valueKey)),\n    [items, getItemValue, valueKey]\n  );\n\n  const handleKeyDown = useCallback<React.KeyboardEventHandler<E>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key, altKey, ctrlKey, metaKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        key.length > 1 ||\n        (!value.current && key === \" \")\n      ) {\n        // might need to change this later if other languages have non-meta keys\n        // that are more than 1 letter\n        return;\n      }\n\n      let nextValue = key;\n      if (value.current !== key) {\n        nextValue = `${value.current}${key}`;\n      }\n      setValue(nextValue);\n\n      const index = findMatchIndex(nextValue, values, searchIndex, true);\n      // don't want to trigger change events if the search didn't match anything\n      // since you normally don't really care about failed matches\n      if (index === searchIndex || index === -1) {\n        return;\n      }\n\n      const data: SearchData<D, E> = {\n        index,\n        item: items[index],\n        items,\n        query: nextValue,\n        target: event.currentTarget,\n      };\n\n      onChange(data);\n    },\n    [\n      searchIndex,\n      findMatchIndex,\n      items,\n      onChange,\n      onKeyDown,\n      setValue,\n      value,\n      values,\n    ]\n  );\n\n  return handleKeyDown;\n}\n"]},"metadata":{},"sourceType":"module"}