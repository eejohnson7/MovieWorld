{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { ListItemAddon } from \"./ListItemAddon\";\nimport { ListItemText } from \"./ListItemText\";\n/**\n * The `ListItemChildren` component is used to create a styled list item that\n * can have optional addons to the left or right of the children in the form of\n * icons, avatars, or media. The `children` can be replaced by the `primaryText`\n * and `secondaryText` props to create stacked text spanning two or more lines\n * with the default behavior of using `line-clamp` at three lines.\n *\n * Note: This will return a `React.Fragment` of the children and does not wrap\n * in a DOM node for styling. The parent component should normally have\n * `display: flex` for the styling to work.\n */\nexport function ListItemChildren(_a) {\n  var textClassName = _a.textClassName,\n    secondaryTextClassName = _a.secondaryTextClassName,\n    textChildren = _a.textChildren,\n    primaryText = _a.primaryText,\n    secondaryText = _a.secondaryText,\n    leftAddon = _a.leftAddon,\n    _b = _a.leftAddonType,\n    leftAddonType = _b === void 0 ? \"icon\" : _b,\n    _c = _a.leftAddonPosition,\n    leftAddonPosition = _c === void 0 ? \"middle\" : _c,\n    rightAddon = _a.rightAddon,\n    _d = _a.rightAddonType,\n    rightAddonType = _d === void 0 ? \"icon\" : _d,\n    _e = _a.rightAddonPosition,\n    rightAddonPosition = _e === void 0 ? \"middle\" : _e,\n    forceAddonWrap = _a.forceAddonWrap,\n    propChildren = _a.children;\n  var stringifiedChildren = typeof propChildren === \"number\" ? \"\".concat(propChildren) : propChildren;\n  var children = stringifiedChildren;\n  if (primaryText || secondaryText || textChildren) {\n    children = _jsx(ListItemText, __assign({\n      className: textClassName,\n      secondaryText: secondaryText,\n      secondaryTextClassName: secondaryTextClassName\n    }, {\n      children: textChildren && children || primaryText\n    }));\n  }\n  children = _jsx(ListItemAddon, __assign({\n    addon: leftAddon,\n    type: leftAddonType,\n    position: leftAddonPosition,\n    forceAddonWrap: forceAddonWrap\n  }, {\n    children: children\n  }));\n  children = _jsx(ListItemAddon, __assign({\n    addon: rightAddon,\n    addonAfter: true,\n    type: rightAddonType,\n    position: rightAddonPosition,\n    forceAddonWrap: forceAddonWrap\n  }, {\n    children: children\n  }));\n  return _jsxs(_Fragment, {\n    children: [children, primaryText && stringifiedChildren || null]\n  });\n}","map":{"version":3,"mappings":";;;;;;;;;;;AAGA,SAASA,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,YAAY,QAAQ,gBAAgB;AAkG7C;;;;;;;;;;;AAWA,OAAM,SAAUC,gBAAgB,CAACC,EAcT;MAbtBC,aAAa;IACbC,sBAAsB;IACtBC,YAAY;IACZC,WAAW;IACXC,aAAa;IACbC,SAAS;IACTC,qBAAsB;IAAtBC,aAAa,mBAAG,MAAM;IACtBC,yBAA4B;IAA5BC,iBAAiB,mBAAG,QAAQ;IAC5BC,UAAU;IACVC,sBAAuB;IAAvBC,cAAc,mBAAG,MAAM;IACvBC,0BAA6B;IAA7BC,kBAAkB,mBAAG,QAAQ;IAC7BC,cAAc;IACJC,YAAY;EAEtB,IAAMC,mBAAmB,GACvB,OAAOD,YAAY,KAAK,QAAQ,GAAG,UAAGA,YAAY,CAAE,GAAGA,YAAY;EAErE,IAAIE,QAAQ,GAAGD,mBAAmB;EAClC,IAAId,WAAW,IAAIC,aAAa,IAAIF,YAAY,EAAE;IAChDgB,QAAQ,GACNC,KAACtB,YAAY;MACXuB,SAAS,EAAEpB,aAAa;MACxBI,aAAa,EAAEA,aAAa;MAC5BH,sBAAsB,EAAEA;IAAsB;MAAAiB,UAE5ChB,YAAY,IAAIgB,QAAQ,IAAKf;IAAW,GAE7C;;EAGHe,QAAQ,GACNC,KAACvB,aAAa;IACZyB,KAAK,EAAEhB,SAAS;IAChBiB,IAAI,EAAEf,aAAa;IACnBgB,QAAQ,EAAEd,iBAAiB;IAC3BM,cAAc,EAAEA;EAAc;IAAAG,UAE7BA;EAAQ,GAEZ;EACDA,QAAQ,GACNC,KAACvB,aAAa;IACZyB,KAAK,EAAEX,UAAU;IACjBc,UAAU;IACVF,IAAI,EAAEV,cAAc;IACpBW,QAAQ,EAAET,kBAAkB;IAC5BC,cAAc,EAAEA;EAAc;IAAAG,UAE7BA;EAAQ,GAEZ;EAED,OACEO;IAAAP,WACGA,QAAQ,EACPf,WAAW,IAAIc,mBAAmB,IAAK,IAAI;EAAA,EAC5C;AAEP","names":["ListItemAddon","ListItemText","ListItemChildren","_a","textClassName","secondaryTextClassName","textChildren","primaryText","secondaryText","leftAddon","_b","leftAddonType","_c","leftAddonPosition","rightAddon","_d","rightAddonType","_e","rightAddonPosition","forceAddonWrap","propChildren","stringifiedChildren","children","_jsx","className","addon","type","position","addonAfter","_jsxs"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/list/src/ListItemChildren.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\n\nimport type { ListItemAddonPosition, ListItemAddonType } from \"./ListItemAddon\";\nimport { ListItemAddon } from \"./ListItemAddon\";\nimport { ListItemText } from \"./ListItemText\";\n\nexport interface ListItemChildrenProps {\n  /**\n   * The main content to display. When the `textChildren` prop is enabled and\n   * there is child content, it will be treated as primary text and update the\n   * styles automatically.\n   */\n  children?: ReactNode;\n\n  /**\n   * An optional className to apply to the `<span>` that surrounds the\n   * `primaryText` and optionally `secondaryText` within the list item.\n   */\n  textClassName?: string;\n\n  /**\n   * An optional className to apply to the `<span>` that surrounds the\n   * `secondaryText` within the list item.\n   */\n  secondaryTextClassName?: string;\n\n  /**\n   * Boolean if the children should be treated as the `primaryText` prop. This\n   * will wrap them in an additional class so that they have ellipsis for text\n   * overflow.\n   *\n   * If you want to have more \"freedom\" within the `ListItem`, you can disable\n   * this prop so that the height will grow depending on content.\n   *\n   * NOTE: If the `secondaryText` prop is provided, this will always be\n   * considered `true`.\n   */\n  textChildren?: boolean;\n\n  /**\n   * An optional element that should be rendered as the `primaryText` within the\n   * list item. It is most likely easier to use the `children` prop instead, but\n   * this allows you to create more complex components with the `ListItem` since\n   * you can provided `children` and have the styles for the `primaryText` still\n   * applied. By default, this will only allow one line of text and add ellipsis\n   * for any text overflow.\n   */\n  primaryText?: ReactNode;\n\n  /**\n   * An optional element that should be rendered as the `secondaryText` within\n   * the list item. By default, this will only span one line and add ellipsis\n   * for overflow.\n   */\n  secondaryText?: ReactNode;\n\n  /**\n   * An optional addon to display to the left of the `primaryText` or\n   * `children` and should be used with the `leftAddonType` prop to adjust\n   * spacing.\n   */\n  leftAddon?: ReactNode;\n\n  /**\n   * The type of the addon that appears to the left of the `primaryText` or\n   * `children`.\n   */\n  leftAddonType?: ListItemAddonType;\n\n  /**\n   * The vertical position the left icon, avatar, media, or large media\n   * should be placed.\n   */\n  leftAddonPosition?: ListItemAddonPosition;\n\n  /**\n   * An optional addon to display to the right of the `primaryText` or\n   * `children` and should be used with the `rightAddonType` prop to adjust\n   * spacing.\n   */\n  rightAddon?: ReactNode;\n\n  /**\n   * The type of the addon that appears to the right of the `primaryText` or\n   * `children`.\n   */\n  rightAddonType?: ListItemAddonType;\n\n  /**\n   * The vertical position the right icon, avatar, media, or large media\n   * should be placed.\n   */\n  rightAddonPosition?: ListItemAddonPosition;\n\n  /**\n   * Boolean if the left and/or right addons should be \"forcefully\" wrapped in a\n   * `<span>` with the spacing class names applied instead of attempting to\n   * clone it into the provided icon element.\n   */\n  forceAddonWrap?: boolean;\n}\n\n/**\n * The `ListItemChildren` component is used to create a styled list item that\n * can have optional addons to the left or right of the children in the form of\n * icons, avatars, or media. The `children` can be replaced by the `primaryText`\n * and `secondaryText` props to create stacked text spanning two or more lines\n * with the default behavior of using `line-clamp` at three lines.\n *\n * Note: This will return a `React.Fragment` of the children and does not wrap\n * in a DOM node for styling. The parent component should normally have\n * `display: flex` for the styling to work.\n */\nexport function ListItemChildren({\n  textClassName,\n  secondaryTextClassName,\n  textChildren,\n  primaryText,\n  secondaryText,\n  leftAddon,\n  leftAddonType = \"icon\",\n  leftAddonPosition = \"middle\",\n  rightAddon,\n  rightAddonType = \"icon\",\n  rightAddonPosition = \"middle\",\n  forceAddonWrap,\n  children: propChildren,\n}: ListItemChildrenProps): ReactElement {\n  const stringifiedChildren =\n    typeof propChildren === \"number\" ? `${propChildren}` : propChildren;\n\n  let children = stringifiedChildren;\n  if (primaryText || secondaryText || textChildren) {\n    children = (\n      <ListItemText\n        className={textClassName}\n        secondaryText={secondaryText}\n        secondaryTextClassName={secondaryTextClassName}\n      >\n        {(textChildren && children) || primaryText}\n      </ListItemText>\n    );\n  }\n\n  children = (\n    <ListItemAddon\n      addon={leftAddon}\n      type={leftAddonType}\n      position={leftAddonPosition}\n      forceAddonWrap={forceAddonWrap}\n    >\n      {children}\n    </ListItemAddon>\n  );\n  children = (\n    <ListItemAddon\n      addon={rightAddon}\n      addonAfter\n      type={rightAddonType}\n      position={rightAddonPosition}\n      forceAddonWrap={forceAddonWrap}\n    >\n      {children}\n    </ListItemAddon>\n  );\n\n  return (\n    <>\n      {children}\n      {(primaryText && stringifiedChildren) || null}\n    </>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}