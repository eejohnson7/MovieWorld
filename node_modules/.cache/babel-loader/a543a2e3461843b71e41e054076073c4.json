{"ast":null,"code":"import { useRef } from \"react\";\nimport { useUserInteractionMode } from \"../mode/UserInteractionModeListener\";\nimport { findMatchIndex } from \"../search/findMatchIndex\";\nimport { useKeyboardFocusContext } from \"./movementContext\";\nimport { focusElement, getFirstFocusableIndex, getLastFocusableIndex, getNextFocusableIndex, isNotFocusable } from \"./utils\";\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nvar noop = function () {\n  // do nothing\n};\n/**\n * @remarks \\@since 5.0.0\n */\nexport function useKeyboardFocus(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = options.onFocus,\n    onFocus = _a === void 0 ? noop : _a,\n    _b = options.onKeyDown,\n    onKeyDown = _b === void 0 ? noop : _b,\n    _c = options.onSearch,\n    onSearch = _c === void 0 ? noop : _c,\n    _d = options.onIncrement,\n    onIncrement = _d === void 0 ? noop : _d,\n    _e = options.onDecrement,\n    onDecrement = _e === void 0 ? noop : _e,\n    _f = options.onJumpToFirst,\n    onJumpToFirst = _f === void 0 ? noop : _f,\n    _g = options.onJumpToLast,\n    onJumpToLast = _g === void 0 ? noop : _g,\n    _h = options.onFocusChange,\n    onFocusChange = _h === void 0 ? focusElement : _h,\n    getDefaultFocusIndex = options.getDefaultFocusIndex;\n  var mode = useUserInteractionMode();\n  var focusIndex = useRef(-1);\n  var _j = useKeyboardFocusContext(),\n    config = _j.config,\n    loopable = _j.loopable,\n    searchable = _j.searchable,\n    watching = _j.watching,\n    includeDisabled = _j.includeDisabled;\n  return {\n    focusIndex: focusIndex,\n    onFocus: function (event) {\n      var _a;\n      onFocus(event);\n      if (event.isPropagationStopped()) {\n        return;\n      }\n      if (event.target !== event.currentTarget) {\n        var i = watching.current.findIndex(function (_a) {\n          var element = _a.element;\n          return element === event.target;\n        });\n        if (i !== -1) {\n          focusIndex.current = i;\n        }\n        return;\n      }\n      var defaultFocusIndex;\n      if (getDefaultFocusIndex) {\n        defaultFocusIndex = getDefaultFocusIndex(watching.current.map(function (_a) {\n          var element = _a.element;\n          return element;\n        }), event.currentTarget);\n      } else {\n        defaultFocusIndex = getFirstFocusableIndex(watching.current, includeDisabled);\n      }\n      // this makes it so that if you click the container element without\n      // clicking any child, it doesn't focus the first element again\n      if (defaultFocusIndex === -1 || mode !== \"keyboard\") {\n        return;\n      }\n      focusIndex.current = defaultFocusIndex;\n      var element = (_a = watching.current[focusIndex.current]) === null || _a === void 0 ? void 0 : _a.element;\n      element && onFocusChange(element, focusIndex.current);\n    },\n    onKeyDown: function (event) {\n      onKeyDown(event);\n      if (event.isPropagationStopped()) {\n        return;\n      }\n      var key = event.key,\n        altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey;\n      var _a = config.current,\n        incrementKeys = _a.incrementKeys,\n        decrementKeys = _a.decrementKeys,\n        jumpToFirstKeys = _a.jumpToFirstKeys,\n        jumpToLastKeys = _a.jumpToLastKeys;\n      var update = function (index) {\n        var _a;\n        event.preventDefault();\n        event.stopPropagation();\n        if (focusIndex.current === index) {\n          return;\n        }\n        focusIndex.current = index;\n        var element = (_a = watching.current[index]) === null || _a === void 0 ? void 0 : _a.element;\n        element && onFocusChange(element, focusIndex.current);\n      };\n      if (searchable && key.length === 1 &&\n      // can't search with space since it is generally a click event\n      key !== \" \" && !altKey && !ctrlKey && !metaKey && !shiftKey) {\n        onSearch({\n          key: key,\n          event: event\n        });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        var values = watching.current.map(function (_a) {\n          var content = _a.content,\n            element = _a.element;\n          if (isNotFocusable(element, includeDisabled)) {\n            return \"\";\n          }\n          return content;\n        });\n        update(findMatchIndex(key, values, focusIndex.current));\n      } else if (jumpToFirstKeys.includes(key)) {\n        onJumpToFirst({\n          key: key,\n          event: event\n        });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        update(getFirstFocusableIndex(watching.current, includeDisabled));\n      } else if (jumpToLastKeys.includes(key)) {\n        onJumpToLast({\n          key: key,\n          event: event\n        });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        update(getLastFocusableIndex(watching.current, includeDisabled));\n      } else if (incrementKeys.includes(key)) {\n        onIncrement({\n          key: key,\n          event: event\n        });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        update(getNextFocusableIndex({\n          loopable: loopable,\n          watching: watching.current,\n          increment: true,\n          includeDisabled: includeDisabled,\n          currentFocusIndex: focusIndex.current\n        }));\n      } else if (decrementKeys.includes(key)) {\n        onDecrement({\n          key: key,\n          event: event\n        });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        update(getNextFocusableIndex({\n          loopable: loopable,\n          watching: watching.current,\n          increment: false,\n          includeDisabled: includeDisabled,\n          currentFocusIndex: focusIndex.current\n        }));\n      }\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useRef","useUserInteractionMode","findMatchIndex","useKeyboardFocusContext","focusElement","getFirstFocusableIndex","getLastFocusableIndex","getNextFocusableIndex","isNotFocusable","noop","useKeyboardFocus","options","onFocus","_b","onKeyDown","_c","onSearch","_d","onIncrement","_e","onDecrement","_f","onJumpToFirst","_g","onJumpToLast","_h","onFocusChange","getDefaultFocusIndex","mode","focusIndex","config","loopable","searchable","watching","includeDisabled","event","isPropagationStopped","target","currentTarget","i","current","findIndex","_a","element","defaultFocusIndex","map","altKey","ctrlKey","metaKey","shiftKey","incrementKeys","decrementKeys","jumpToFirstKeys","jumpToLastKeys","update","index","preventDefault","stopPropagation","key","length","values","content","includes","increment","currentFocusIndex"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/keyboardMovement/useKeyboardFocus.ts"],"sourcesContent":["import type {\n  FocusEventHandler,\n  KeyboardEvent,\n  KeyboardEventHandler,\n  MutableRefObject,\n} from \"react\";\nimport { useRef } from \"react\";\nimport { useUserInteractionMode } from \"../mode/UserInteractionModeListener\";\n\nimport { findMatchIndex } from \"../search/findMatchIndex\";\nimport { useKeyboardFocusContext } from \"./movementContext\";\nimport {\n  focusElement,\n  getFirstFocusableIndex,\n  getLastFocusableIndex,\n  getNextFocusableIndex,\n  isNotFocusable,\n} from \"./utils\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface KeyboardFocusArg<E extends HTMLElement> {\n  /**\n   * The keyboard key/letter that was pressed. (`event.key`).\n   */\n  key: string;\n\n  /**\n   * The keyboard event.\n   */\n  event: KeyboardEvent<E>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport type KeyboardFocusHandler<E extends HTMLElement> = (\n  arg: KeyboardFocusArg<E>\n) => void;\n\n/**\n * Optional event handlers that can be called for specific custom focus\n * behavior. If any of these functions call `event.stopPropagation()`, the\n * default focus behavior will not occur.\n *\n * @remarks \\@since 5.0.0\n */\nexport interface KeyboardFocusCallbacks<E extends HTMLElement> {\n  onFocus?: FocusEventHandler<E>;\n  onKeyDown?: KeyboardEventHandler<E>;\n\n  /**\n   * This is called whenever a single letter has been pressed and\n   * {@link KeyboardMovementBehavior.searchable} is `true`.\n   */\n  onSearch?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.incrementKeys} are pressed.\n   */\n  onIncrement?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.decrementKeys} are pressed.\n   */\n  onDecrement?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.jumpToFirstKeys} are pressed.\n   */\n  onJumpToFirst?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.jumpToLastKeys} are pressed.\n   */\n  onJumpToLast?: KeyboardFocusHandler<E>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface KeyboardFocusHookOptions<E extends HTMLElement>\n  extends KeyboardFocusCallbacks<E> {\n  /**\n   * A function that can be used to get the default focus index when the\n   * container element first gains focus. If this returns `-1`, no child element\n   * will be focused and the container will maintain focus instead.\n   *\n   * @param elements - The current list of elements that can be focused within\n   * the container element\n   * @param container - The container element that gained focus\n   */\n  getDefaultFocusIndex?(elements: readonly HTMLElement[], container: E): number;\n\n  /**\n   * An optional function to call when the custom focused element should change.\n   * The default value is just to call `element.focus()`.\n   *\n   * @param element - The element that should gain custom focus\n   * @param nextFocusIndex - The next focus index which can be used for\n   * additional movement behavior.\n   */\n  onFocusChange?(element: HTMLElement, nextFocusIndex: number): void;\n}\n\n/** @remarks \\@since 5.0.0 */\nexport interface KeyboardFocusHookReturnValue<E extends HTMLElement> {\n  onFocus: FocusEventHandler<E>;\n  onKeyDown: KeyboardEventHandler<E>;\n  focusIndex: MutableRefObject<number>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport function useKeyboardFocus<E extends HTMLElement>(\n  options: KeyboardFocusHookOptions<E> = {}\n): KeyboardFocusHookReturnValue<E> {\n  const {\n    onFocus = noop,\n    onKeyDown = noop,\n    onSearch = noop,\n    onIncrement = noop,\n    onDecrement = noop,\n    onJumpToFirst = noop,\n    onJumpToLast = noop,\n    onFocusChange = focusElement,\n    getDefaultFocusIndex,\n  } = options;\n  const mode = useUserInteractionMode();\n  const focusIndex = useRef(-1);\n  const { config, loopable, searchable, watching, includeDisabled } =\n    useKeyboardFocusContext();\n\n  return {\n    focusIndex,\n    onFocus(event) {\n      onFocus(event);\n      if (event.isPropagationStopped()) {\n        return;\n      }\n\n      if (event.target !== event.currentTarget) {\n        const i = watching.current.findIndex(\n          ({ element }) => element === event.target\n        );\n        if (i !== -1) {\n          focusIndex.current = i;\n        }\n        return;\n      }\n\n      let defaultFocusIndex: number;\n      if (getDefaultFocusIndex) {\n        defaultFocusIndex = getDefaultFocusIndex(\n          watching.current.map(({ element }) => element),\n          event.currentTarget\n        );\n      } else {\n        defaultFocusIndex = getFirstFocusableIndex(\n          watching.current,\n          includeDisabled\n        );\n      }\n\n      // this makes it so that if you click the container element without\n      // clicking any child, it doesn't focus the first element again\n      if (defaultFocusIndex === -1 || mode !== \"keyboard\") {\n        return;\n      }\n\n      focusIndex.current = defaultFocusIndex;\n      const element = watching.current[focusIndex.current]?.element;\n      element && onFocusChange(element, focusIndex.current);\n    },\n    onKeyDown(event) {\n      onKeyDown(event);\n      if (event.isPropagationStopped()) {\n        return;\n      }\n\n      const { key, altKey, ctrlKey, metaKey, shiftKey } = event;\n      const { incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys } =\n        config.current;\n\n      const update = (index: number): void => {\n        event.preventDefault();\n        event.stopPropagation();\n        if (focusIndex.current === index) {\n          return;\n        }\n\n        focusIndex.current = index;\n\n        const element = watching.current[index]?.element;\n        element && onFocusChange(element, focusIndex.current);\n      };\n\n      if (\n        searchable &&\n        key.length === 1 &&\n        // can't search with space since it is generally a click event\n        key !== \" \" &&\n        !altKey &&\n        !ctrlKey &&\n        !metaKey &&\n        !shiftKey\n      ) {\n        onSearch({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        const values = watching.current.map(({ content, element }) => {\n          if (isNotFocusable(element, includeDisabled)) {\n            return \"\";\n          }\n\n          return content;\n        });\n\n        update(findMatchIndex(key, values, focusIndex.current));\n      } else if (jumpToFirstKeys.includes(key)) {\n        onJumpToFirst({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(getFirstFocusableIndex(watching.current, includeDisabled));\n      } else if (jumpToLastKeys.includes(key)) {\n        onJumpToLast({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(getLastFocusableIndex(watching.current, includeDisabled));\n      } else if (incrementKeys.includes(key)) {\n        onIncrement({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(\n          getNextFocusableIndex({\n            loopable,\n            watching: watching.current,\n            increment: true,\n            includeDisabled,\n            currentFocusIndex: focusIndex.current,\n          })\n        );\n      } else if (decrementKeys.includes(key)) {\n        onDecrement({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(\n          getNextFocusableIndex({\n            loopable,\n            watching: watching.current,\n            increment: false,\n            includeDisabled,\n            currentFocusIndex: focusIndex.current,\n          })\n        );\n      }\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}