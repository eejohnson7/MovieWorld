{"ast":null,"code":"import { getPercentage, nearest } from \"@react-md/utils\";\n/**\n * Gets the number of steps in the allowed range of values.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var getSteps = function (min, max, step) {\n  return Math.abs(max - min) / step;\n};\n/**\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var getJumpValue = function (min, max, step, jump) {\n  var steps = getSteps(min, max, step);\n  var value = jump !== null && jump !== void 0 ? jump : steps / 10 * step;\n  if (Number.isInteger(step)) {\n    return Math.ceil(value);\n  }\n  return value;\n};\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var isMouseEvent = function (event) {\n  return event.type === \"mousedown\" || event.type === \"mousemove\" || event.type === \"mouseup\";\n};\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var isTouchEvent = function (event) {\n  return event.type === \"touchstart\" || event.type === \"touchmove\" || event.type === \"touchend\";\n};\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var isRangeSlider = function (controls) {\n  return Array.isArray(controls.value);\n};\n/**\n * This is used to get the next value for the slider while being dragged via\n * mouse or touch.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var getDragValue = function (_a) {\n  var min = _a.min,\n    max = _a.max,\n    step = _a.step,\n    vertical = _a.vertical,\n    clientX = _a.clientX,\n    clientY = _a.clientY,\n    left = _a.left,\n    top = _a.top,\n    height = _a.height,\n    width = _a.width,\n    isRtl = _a.isRtl,\n    minValue = _a.minValue,\n    maxValue = _a.maxValue;\n  var sliderSize = vertical ? height : width;\n  var sliderPosition = vertical ? top + height : left;\n  var cursorPosition = vertical ? clientY : clientX;\n  var difference = vertical ? sliderPosition - cursorPosition : cursorPosition - sliderPosition;\n  var distanceDragged = Math.min(Math.max(0, difference), sliderSize);\n  var percentageDragged = distanceDragged / sliderSize;\n  if (isRtl && !vertical) {\n    percentageDragged = 1 - percentageDragged;\n  }\n  var range = max - min;\n  var steps = getSteps(min, max, step);\n  var value = percentageDragged * range + min;\n  var rounded = nearest(value, minValue, maxValue, steps, range);\n  return {\n    value: rounded,\n    current: percentageDragged\n  };\n};\n/**\n * Small util to get the drag percentage for the thumbs within a slider. This\n * makes sure to use the current `dragValue` when possible so that the thumb\n * moves with the mouse/touch instead of only for the current values. See\n * {@link getDragValue} for more examples.\n *\n * @remarks \\@since 2.5.0\n * @internal\n */\nexport var getDragPercentage = function (_a) {\n  var min = _a.min,\n    max = _a.max,\n    dragging = _a.dragging,\n    dragValue = _a.dragValue,\n    draggingIndex = _a.draggingIndex,\n    thumb1Value = _a.thumb1Value,\n    thumb2Value = _a.thumb2Value;\n  var thumb1Percentage = dragging && draggingIndex === 0 ? dragValue : getPercentage({\n    min: min,\n    max: max,\n    value: thumb1Value,\n    validate: false\n  });\n  var thumb2Percentage;\n  if (typeof thumb2Value === \"number\") {\n    var percentage = getPercentage({\n      min: min,\n      max: max,\n      value: thumb2Value,\n      validate: false\n    });\n    thumb1Percentage = Math.min(thumb1Percentage, percentage);\n    thumb2Percentage = dragging && draggingIndex === 1 ? Math.max(thumb1Percentage, dragValue) : percentage;\n  }\n  return {\n    thumb1Percentage: \"\".concat(thumb1Percentage * 100, \"%\"),\n    thumb2Percentage: typeof thumb2Percentage === \"number\" ? \"\".concat(thumb2Percentage * 100, \"%\") : undefined\n  };\n};","map":{"version":3,"mappings":"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","names":["getPercentage","nearest","getSteps","min","max","step","abs","getJumpValue","jump","steps","value","Number","isInteger","Math","ceil","isMouseEvent","event","type","isTouchEvent","isRangeSlider","controls","isArray","getDragValue","_a","vertical","clientX","clientY","left","top","height","width","isRtl","minValue","maxValue","sliderSize","sliderPosition","cursorPosition","difference","distanceDragged","percentageDragged","range","rounded","current","getDragPercentage","dragging","dragValue","draggingIndex","thumb1Value","thumb2Value","thumb1Percentage","validate","thumb2Percentage","percentage","undefined"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/slider/utils.ts"],"sourcesContent":["import { getPercentage, nearest } from \"@react-md/utils\";\n\nimport type {\n  DefinedSliderValueOptions,\n  RangeSliderControls,\n  RangeSliderValue,\n  SliderControls,\n  SliderValue,\n  ThumbIndex,\n} from \"./types\";\n\n/**\n * Gets the number of steps in the allowed range of values.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const getSteps = (min: number, max: number, step: number): number =>\n  Math.abs(max - min) / step;\n\n/**\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const getJumpValue = (\n  min: number,\n  max: number,\n  step: number,\n  jump: number | undefined\n): number => {\n  const steps = getSteps(min, max, step);\n  const value = jump ?? (steps / 10) * step;\n  if (Number.isInteger(step)) {\n    return Math.ceil(value);\n  }\n\n  return value;\n};\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport type SliderDragEvent =\n  | MouseEvent\n  | TouchEvent\n  | React.MouseEvent\n  | React.TouchEvent;\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const isMouseEvent = (\n  event: SliderDragEvent\n): event is MouseEvent & { type: \"mousedown\" | \"mousemove\" | \"mouseup\" } =>\n  event.type === \"mousedown\" ||\n  event.type === \"mousemove\" ||\n  event.type === \"mouseup\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const isTouchEvent = (\n  event: SliderDragEvent\n): event is TouchEvent & { type: \"touchstart\" | \"touchmove\" | \"touchend\" } =>\n  event.type === \"touchstart\" ||\n  event.type === \"touchmove\" ||\n  event.type === \"touchend\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport interface SimpleSliderControls extends SliderControls {\n  value: SliderValue;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport interface ComplexSliderControls extends RangeSliderControls {\n  value: RangeSliderValue;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport type CombinedSliderControls =\n  | SimpleSliderControls\n  | ComplexSliderControls;\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const isRangeSlider = (\n  controls: CombinedSliderControls\n): controls is ComplexSliderControls => Array.isArray(controls.value);\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport interface SliderDragValues extends DefinedSliderValueOptions {\n  clientX: number;\n  clientY: number;\n  top: number;\n  height: number;\n  left: number;\n  width: number;\n  isRtl: boolean;\n  vertical: boolean;\n  minValue: number;\n  maxValue: number;\n}\n\n/**\n * @remarks \\@since 2.5.0\n * @internal\n */\nexport interface SliderDragValue {\n  /**\n   * This is the current value for the slider that is completely \"valid\" and\n   * within the provided range.\n   */\n  value: number;\n\n  /**\n   * The current percentage dragged number (`> 0` and `< 1`). This is used only\n   * while dragging with the mouse or touch since it makes the drag experience\n   * smoother. If this is omitted and there is a small number of \"steps\" in the\n   * range, the mouse/touch won't align with the thumb since it will only move\n   * when the value is updated as well.\n   *\n   * Example:\n   * - slider has width of 1000px, min value is 0, max value is 100, step is 20\n   * - formula:\n   *   - range = max - min\n   *   - steps = range / step\n   *   - new-value-at = slider-width / steps\n   *   - new-value-at = slider-width / ((max - min) / step)\n   * - so:\n   *   - new-value-at = 1000px / ((100 - 0) / 20)\n   *   - new-value-at = 1000px / (100 / 20)\n   *   - new-value-at = 1000px / 5\n   *   - new-value-at = 200px\n   * - user drags from `0px -> 10px`\n   *   - no visual change\n   * - user drags from `10px -> 190px`\n   *   - no visual change\n   * - user drags from `190px -> 200px`\n   *   - visual change to first step\n   *\n   * The current value allows for a visual change while the user drags, but the\n   * thumb will move to the correct value once the user stops dragging.\n   */\n  current: number;\n}\n\n/**\n * This is used to get the next value for the slider while being dragged via\n * mouse or touch.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const getDragValue = ({\n  min,\n  max,\n  step,\n  vertical,\n  clientX,\n  clientY,\n  left,\n  top,\n  height,\n  width,\n  isRtl,\n  minValue,\n  maxValue,\n}: SliderDragValues): SliderDragValue => {\n  const sliderSize = vertical ? height : width;\n  const sliderPosition = vertical ? top + height : left;\n  const cursorPosition = vertical ? clientY : clientX;\n  const difference = vertical\n    ? sliderPosition - cursorPosition\n    : cursorPosition - sliderPosition;\n\n  const distanceDragged = Math.min(Math.max(0, difference), sliderSize);\n  let percentageDragged = distanceDragged / sliderSize;\n  if (isRtl && !vertical) {\n    percentageDragged = 1 - percentageDragged;\n  }\n\n  const range = max - min;\n  const steps = getSteps(min, max, step);\n  const value = percentageDragged * range + min;\n  const rounded = nearest(value, minValue, maxValue, steps, range);\n\n  return {\n    value: rounded,\n    current: percentageDragged,\n  };\n};\n\n/**\n * @remarks \\@since 2.5.0\n * @internal\n */\ninterface DragPercentageOptions {\n  min: number;\n  max: number;\n  thumb1Value: number;\n  thumb2Value?: number;\n  dragging: boolean;\n  dragValue: number;\n  draggingIndex: ThumbIndex | null;\n}\n\ninterface DragPercentage {\n  thumb1Percentage: string;\n  thumb2Percentage: string | undefined;\n}\n\n/**\n * Small util to get the drag percentage for the thumbs within a slider. This\n * makes sure to use the current `dragValue` when possible so that the thumb\n * moves with the mouse/touch instead of only for the current values. See\n * {@link getDragValue} for more examples.\n *\n * @remarks \\@since 2.5.0\n * @internal\n */\nexport const getDragPercentage = ({\n  min,\n  max,\n  dragging,\n  dragValue,\n  draggingIndex,\n  thumb1Value,\n  thumb2Value,\n}: DragPercentageOptions): DragPercentage => {\n  let thumb1Percentage =\n    dragging && draggingIndex === 0\n      ? dragValue\n      : getPercentage({\n          min,\n          max,\n          value: thumb1Value,\n          validate: false,\n        });\n\n  let thumb2Percentage: number | undefined;\n  if (typeof thumb2Value === \"number\") {\n    const percentage = getPercentage({\n      min,\n      max,\n      value: thumb2Value,\n      validate: false,\n    });\n    thumb1Percentage = Math.min(thumb1Percentage, percentage);\n    thumb2Percentage =\n      dragging && draggingIndex === 1\n        ? Math.max(thumb1Percentage, dragValue)\n        : percentage;\n  }\n\n  return {\n    thumb1Percentage: `${thumb1Percentage * 100}%`,\n    thumb2Percentage:\n      typeof thumb2Percentage === \"number\"\n        ? `${thumb2Percentage * 100}%`\n        : undefined,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}