{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { BELOW_CENTER_ANCHOR, getFixedPosition, useEnsuredRef, useResizeListener, useScrollListener } from \"@react-md/utils\";\nimport { isWithinViewport } from \"./utils\";\n/**\n * This hook is used to attach a temporary (fixed) element to another element\n * within the page. In other words, this is a way to have an element with\n * `position: fixed` as if it were `position: absolute` to a parent element that\n * had `position: relative`.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useRef, useState } from \"react\";\n * import { Button } from \"@react-md/button\";\n * import { useCSSTransition, useFixedPositioning } from \"@react-md/transition\";\n *\n * function Example(): ReactElement {\n *   const fixedTo = useRef<HTMLButtonElement>(null);\n *   const [transitionIn, setTransitionIn] = useState(false);\n *   const { style, transitionOptions } = useFixedPositioning({\n *     fixedTo,\n *   });\n *   const { elementProps, rendered } = useCSSTransition({\n *     ...transitionOptions,\n *     transitionIn,\n *     temporary: true,\n *     timeout: {\n *       enter: 200,\n *       exit: 150,\n *     },\n *     classNames: {\n *       enter: \"enter\",\n *       enterActive: \"enter--active\",\n *       exit: \"exit\",\n *       exitActive: \"exit--active\",\n *     },\n *   });\n *\n *   return (\n *     <>\n *       <Button\n *         ref={fixedTo}\n *         onClick={() => setTransitionIn(!transitionIn)}\n *       >\n *         Toggle\n *       </Button>\n *       {rendered && (\n *         <div {...elementProps} style={style}>\n *           Fixed Temporary Element\n *         </div>\n *       )}\n *     </>\n *   );\n * }\n * ```\n *\n * @typeParam FixedToElement - An HTMLElement type for the static element.\n * @typeParam FixedElement - An HTMLElement type for the fixed element.\n * @remarks \\@since 4.0.0\n */\nexport function useFixedPositioning(_a) {\n  var propStyle = _a.style,\n    nodeRef = _a.nodeRef,\n    fixedTo = _a.fixedTo,\n    onEnter = _a.onEnter,\n    onEntering = _a.onEntering,\n    onEntered = _a.onEntered,\n    onExited = _a.onExited,\n    _b = _a.anchor,\n    anchor = _b === void 0 ? BELOW_CENTER_ANCHOR : _b,\n    disableSwapping = _a.disableSwapping,\n    disableVHBounds = _a.disableVHBounds,\n    initialX = _a.initialX,\n    initialY = _a.initialY,\n    preventOverlap = _a.preventOverlap,\n    transformOrigin = _a.transformOrigin,\n    vhMargin = _a.vhMargin,\n    vwMargin = _a.vwMargin,\n    width = _a.width,\n    xMargin = _a.xMargin,\n    yMargin = _a.yMargin,\n    getFixedPositionOptions = _a.getFixedPositionOptions,\n    onScroll = _a.onScroll,\n    onResize = _a.onResize;\n  var _c = __read(useState(), 2),\n    style = _c[0],\n    setStyle = _c[1];\n  var _d = __read(useState(false), 2),\n    active = _d[0],\n    setActive = _d[1];\n  var _e = __read(useEnsuredRef(nodeRef), 2),\n    ref = _e[0],\n    refHandler = _e[1];\n  var options = {\n    ref: ref,\n    fixedTo: fixedTo,\n    anchor: anchor,\n    disableSwapping: disableSwapping,\n    disableVHBounds: disableVHBounds,\n    preventOverlap: preventOverlap,\n    transformOrigin: transformOrigin,\n    vhMargin: vhMargin,\n    vwMargin: vwMargin,\n    width: width,\n    xMargin: xMargin,\n    yMargin: yMargin,\n    getFixedPositionOptions: getFixedPositionOptions\n  };\n  var optionsRef = useRef(options);\n  optionsRef.current = options;\n  var updateStyle = useCallback(function () {\n    var _a = optionsRef.current,\n      ref = _a.ref,\n      fixedTo = _a.fixedTo,\n      anchor = _a.anchor,\n      disableSwapping = _a.disableSwapping,\n      disableVHBounds = _a.disableVHBounds,\n      preventOverlap = _a.preventOverlap,\n      transformOrigin = _a.transformOrigin,\n      vhMargin = _a.vhMargin,\n      vwMargin = _a.vwMargin,\n      width = _a.width,\n      xMargin = _a.xMargin,\n      yMargin = _a.yMargin,\n      getFixedPositionOptions = _a.getFixedPositionOptions;\n    var element = ref.current;\n    var container = fixedTo.current;\n    var style = getFixedPosition(__assign({\n      container: container,\n      element: element,\n      anchor: anchor,\n      disableSwapping: disableSwapping,\n      disableVHBounds: disableVHBounds,\n      initialX: initialX,\n      initialY: initialY,\n      preventOverlap: preventOverlap,\n      transformOrigin: transformOrigin,\n      vhMargin: vhMargin,\n      vwMargin: vwMargin,\n      width: width,\n      xMargin: xMargin,\n      yMargin: yMargin\n    }, getFixedPositionOptions === null || getFixedPositionOptions === void 0 ? void 0 : getFixedPositionOptions())).style;\n    setStyle(style);\n    setActive(!!element && !element.hidden);\n    // Only changing the initialX and initialY should cause the useEffect below\n    // to trigger, which is why everything else is set in a ref.\n  }, [initialX, initialY]);\n  useResizeListener({\n    enabled: active,\n    onResize: function (event) {\n      onResize === null || onResize === void 0 ? void 0 : onResize(event);\n      updateStyle();\n    }\n  });\n  useScrollListener({\n    enabled: active,\n    onScroll: function (event) {\n      var fixedElement = ref.current;\n      var fixedToElement = fixedTo.current;\n      if (onScroll && fixedElement && fixedToElement) {\n        onScroll(event, {\n          visible: isWithinViewport({\n            fixedElement: fixedElement,\n            fixedToElement: fixedToElement\n          }),\n          fixedElement: fixedElement,\n          fixedToElement: fixedToElement\n        });\n      }\n      updateStyle();\n    }\n  });\n  useEffect(function () {\n    if (!ref.current || !ref.current.hidden) {\n      updateStyle();\n    }\n  }, [ref, updateStyle]);\n  var callbacks = {\n    onEnter: function (appearing) {\n      onEnter === null || onEnter === void 0 ? void 0 : onEnter(appearing);\n      updateStyle();\n    },\n    onEntering: function (appearing) {\n      onEntering === null || onEntering === void 0 ? void 0 : onEntering(appearing);\n      updateStyle();\n    },\n    onEntered: function (appearing) {\n      onEntered === null || onEntered === void 0 ? void 0 : onEntered(appearing);\n      updateStyle();\n    },\n    onExited: function () {\n      onExited === null || onExited === void 0 ? void 0 : onExited();\n      setActive(false);\n    }\n  };\n  return {\n    ref: refHandler,\n    style: __assign(__assign({}, style), propStyle),\n    callbacks: callbacks,\n    updateStyle: updateStyle,\n    transitionOptions: __assign(__assign({}, callbacks), {\n      nodeRef: refHandler\n    })\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","BELOW_CENTER_ANCHOR","getFixedPosition","useEnsuredRef","useResizeListener","useScrollListener","isWithinViewport","useFixedPositioning","_a","propStyle","nodeRef","fixedTo","onEnter","onEntering","onEntered","onExited","_b","anchor","disableSwapping","disableVHBounds","initialX","initialY","preventOverlap","transformOrigin","vhMargin","vwMargin","width","xMargin","yMargin","getFixedPositionOptions","onScroll","onResize","style","setStyle","active","setActive","ref","refHandler","options","optionsRef","current","updateStyle","element","container","hidden","enabled","event","fixedElement","fixedToElement","visible","callbacks","appearing","transitionOptions"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/transition/src/useFixedPositioning.ts"],"sourcesContent":["import type { CSSProperties, RefCallback, RefObject } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { CalculateFixedPositionOptions } from \"@react-md/utils\";\nimport {\n  BELOW_CENTER_ANCHOR,\n  getFixedPosition,\n  useEnsuredRef,\n  useResizeListener,\n  useScrollListener,\n} from \"@react-md/utils\";\n\nimport type {\n  FixedPositioningTransitionCallbacks,\n  FixedPositioningTransitionOptions,\n  TransitionScrollCallback,\n} from \"./types\";\nimport { isWithinViewport } from \"./utils\";\n\n/**\n * @typeParam FixedToElement - An HTMLElement type for the static element.\n * @typeParam FixedElement - An HTMLElement type for the fixed element.\n * @remarks \\@since 4.0.0\n */\nexport interface FixedPositioningOptions<\n  FixedToElement extends HTMLElement,\n  FixedElement extends HTMLElement\n> extends FixedPositioningTransitionOptions<FixedElement>,\n    CalculateFixedPositionOptions {\n  /**\n   * An optional style that will be merged with the fixed positioning required\n   * styles.\n   *\n   * @see {@link FixedPositionStyle}\n   */\n  style?: CSSProperties;\n\n  /**\n   * A ref pointing to an element that another element should be fixed to. This\n   * **must** be provided for the positioning to work.\n   */\n  fixedTo: RefObject<FixedToElement>;\n\n  /**\n   * An optional function that can be used to override positioning options if\n   * some options require the element to be in the DOM for specific\n   * calculations.\n   */\n  getFixedPositionOptions?(): CalculateFixedPositionOptions;\n\n  /**\n   * An optional function to call if the page resizes while the\n   * {@link FixedElement} is visible.\n   */\n  onResize?: EventListener;\n  /** {@inheritDoc TransitionScrollCallback} */\n  onScroll?: TransitionScrollCallback<FixedToElement, FixedElement>;\n}\n\n/**\n * @typeParam E - An HTMLElement type for the fixed element.\n * @remarks \\@since 4.0.0\n */\nexport interface FixedPositioningHookReturnValue<E extends HTMLElement> {\n  /**\n   * A ref that should be passed to a component for the fixed positioning\n   * behavior to work correctly.\n   *\n   * This should really only be used if the {@link transitionOptions} is not\n   * being used.\n   */\n  ref: RefCallback<E>;\n\n  /**\n   * @see {@link FixedPositionStyle}\n   */\n  style: CSSProperties;\n\n  /**\n   * This should really only be used if the {@link transitionOptions} is not\n   * being used.\n   */\n  callbacks: Readonly<Required<FixedPositioningTransitionCallbacks>>;\n\n  /**\n   * A function that can be called to update the style for the fixed element.\n   */\n  updateStyle(): void;\n\n  /** {@inheritDoc FixedPositioningTransitionOptions} */\n  transitionOptions: Readonly<Required<FixedPositioningTransitionOptions<E>>>;\n}\n\n/**\n * This hook is used to attach a temporary (fixed) element to another element\n * within the page. In other words, this is a way to have an element with\n * `position: fixed` as if it were `position: absolute` to a parent element that\n * had `position: relative`.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useRef, useState } from \"react\";\n * import { Button } from \"@react-md/button\";\n * import { useCSSTransition, useFixedPositioning } from \"@react-md/transition\";\n *\n * function Example(): ReactElement {\n *   const fixedTo = useRef<HTMLButtonElement>(null);\n *   const [transitionIn, setTransitionIn] = useState(false);\n *   const { style, transitionOptions } = useFixedPositioning({\n *     fixedTo,\n *   });\n *   const { elementProps, rendered } = useCSSTransition({\n *     ...transitionOptions,\n *     transitionIn,\n *     temporary: true,\n *     timeout: {\n *       enter: 200,\n *       exit: 150,\n *     },\n *     classNames: {\n *       enter: \"enter\",\n *       enterActive: \"enter--active\",\n *       exit: \"exit\",\n *       exitActive: \"exit--active\",\n *     },\n *   });\n *\n *   return (\n *     <>\n *       <Button\n *         ref={fixedTo}\n *         onClick={() => setTransitionIn(!transitionIn)}\n *       >\n *         Toggle\n *       </Button>\n *       {rendered && (\n *         <div {...elementProps} style={style}>\n *           Fixed Temporary Element\n *         </div>\n *       )}\n *     </>\n *   );\n * }\n * ```\n *\n * @typeParam FixedToElement - An HTMLElement type for the static element.\n * @typeParam FixedElement - An HTMLElement type for the fixed element.\n * @remarks \\@since 4.0.0\n */\nexport function useFixedPositioning<\n  FixedToElement extends HTMLElement,\n  FixedElement extends HTMLElement\n>({\n  style: propStyle,\n  nodeRef,\n  fixedTo,\n  onEnter,\n  onEntering,\n  onEntered,\n  onExited,\n  anchor = BELOW_CENTER_ANCHOR,\n  disableSwapping,\n  disableVHBounds,\n  initialX,\n  initialY,\n  preventOverlap,\n  transformOrigin,\n  vhMargin,\n  vwMargin,\n  width,\n  xMargin,\n  yMargin,\n  getFixedPositionOptions,\n  onScroll,\n  onResize,\n}: FixedPositioningOptions<\n  FixedToElement,\n  FixedElement\n>): FixedPositioningHookReturnValue<FixedElement> {\n  const [style, setStyle] = useState<CSSProperties | undefined>();\n  const [active, setActive] = useState(false);\n  const [ref, refHandler] = useEnsuredRef(nodeRef);\n  const options = {\n    ref,\n    fixedTo,\n    anchor,\n    disableSwapping,\n    disableVHBounds,\n    preventOverlap,\n    transformOrigin,\n    vhMargin,\n    vwMargin,\n    width,\n    xMargin,\n    yMargin,\n    getFixedPositionOptions,\n  } as const;\n  const optionsRef = useRef(options);\n  optionsRef.current = options;\n\n  const updateStyle = useCallback(() => {\n    const {\n      ref,\n      fixedTo,\n      anchor,\n      disableSwapping,\n      disableVHBounds,\n      preventOverlap,\n      transformOrigin,\n      vhMargin,\n      vwMargin,\n      width,\n      xMargin,\n      yMargin,\n      getFixedPositionOptions,\n    } = optionsRef.current;\n    const element = ref.current;\n    const container = fixedTo.current;\n    const { style } = getFixedPosition({\n      container,\n      element,\n      anchor,\n      disableSwapping,\n      disableVHBounds,\n      initialX,\n      initialY,\n      preventOverlap,\n      transformOrigin,\n      vhMargin,\n      vwMargin,\n      width,\n      xMargin,\n      yMargin,\n      ...getFixedPositionOptions?.(),\n    });\n\n    setStyle(style);\n    setActive(!!element && !element.hidden);\n\n    // Only changing the initialX and initialY should cause the useEffect below\n    // to trigger, which is why everything else is set in a ref.\n  }, [initialX, initialY]);\n\n  useResizeListener({\n    enabled: active,\n    onResize(event) {\n      onResize?.(event);\n      updateStyle();\n    },\n  });\n\n  useScrollListener({\n    enabled: active,\n    onScroll(event) {\n      const fixedElement = ref.current;\n      const fixedToElement = fixedTo.current;\n      if (onScroll && fixedElement && fixedToElement) {\n        onScroll(event, {\n          visible: isWithinViewport({ fixedElement, fixedToElement }),\n          fixedElement,\n          fixedToElement,\n        });\n      }\n\n      updateStyle();\n    },\n  });\n\n  useEffect(() => {\n    if (!ref.current || !ref.current.hidden) {\n      updateStyle();\n    }\n  }, [ref, updateStyle]);\n\n  const callbacks: Required<FixedPositioningTransitionCallbacks> = {\n    onEnter(appearing) {\n      onEnter?.(appearing);\n      updateStyle();\n    },\n    onEntering(appearing) {\n      onEntering?.(appearing);\n      updateStyle();\n    },\n    onEntered(appearing) {\n      onEntered?.(appearing);\n      updateStyle();\n    },\n    onExited() {\n      onExited?.();\n      setActive(false);\n    },\n  };\n\n  return {\n    ref: refHandler,\n    style: { ...style, ...propStyle },\n    callbacks,\n    updateStyle,\n    transitionOptions: {\n      ...callbacks,\n      nodeRef: refHandler,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}