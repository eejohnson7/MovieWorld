{"ast":null,"code":"import { getAboveCoord, getBelowCoord, getBottomCoord, getCenterYCoord, getTopCoord } from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredAbove(config) {\n  var yMargin = config.yMargin,\n    vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    containerRect = config.containerRect,\n    preventOverlap = config.preventOverlap,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getAboveCoord(config);\n  var actualY = \"above\";\n  if (disableVHBounds) {\n    // can't actually allow a top value as a negative number since browsers\n    // won't scroll upwards pas the normal page top\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n  if (top > vhMargin) {\n    // don't need to do anything else since the top is still in the viewport and\n    // since it's positioned above, we already know it can't overlap the\n    // container element\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  var swappedTop = getBelowCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, vhMargin);\n  } else {\n    actualY = \"below\";\n    top = swappedTop;\n  }\n  var bottom;\n  if (preventOverlap &&\n  // can't overlap if it's positioned below\n  actualY === \"above\" && top + elHeight > containerRect.top) {\n    bottom = window.innerHeight - containerRect.top + yMargin;\n  }\n  return {\n    actualY: actualY,\n    top: top,\n    bottom: bottom\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredTop(config) {\n  var vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getTopCoord(config);\n  var actualY = \"top\";\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  var swappedTop = getBottomCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, vhMargin);\n  } else {\n    actualY = \"bottom\";\n    top = swappedTop;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\nexport function createAnchoredCenter(config) {\n  var vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    disableVHBounds = config.disableVHBounds;\n  var top = getCenterYCoord(config);\n  var actualY = \"center\";\n  if (disableVHBounds) {\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n  top = Math.max(vhMargin, top);\n  if (top + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBottom(config) {\n  var vhMargin = config.vhMargin,\n    screenBottom = config.screenBottom,\n    elHeight = config.elHeight,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getBottomCoord(config);\n  var actualY = \"bottom\";\n  if (disableVHBounds || top > vhMargin) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  var swappedTop = getTopCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, screenBottom - elHeight);\n  } else {\n    actualY = \"top\";\n    top = swappedTop;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBelow(config) {\n  var yMargin = config.yMargin,\n    vhMargin = config.vhMargin,\n    elHeight = config.elHeight,\n    screenBottom = config.screenBottom,\n    containerRect = config.containerRect,\n    preventOverlap = config.preventOverlap,\n    disableSwapping = config.disableSwapping,\n    disableVHBounds = config.disableVHBounds;\n  var top = getBelowCoord(config);\n  var actualY = \"below\";\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n  if (preventOverlap) {\n    var availableTop = containerRect.top - yMargin;\n    if (disableSwapping || availableTop < screenBottom - top) {\n      return {\n        actualY: actualY,\n        top: top,\n        bottom: vhMargin\n      };\n    }\n    return {\n      actualY: \"above\",\n      top: Math.max(vhMargin, availableTop - elHeight),\n      // this makes it so that the bottom of the fixed element is the top of the container\n      // element. this ensures that it won't ever overlap the container element\n      bottom: getViewportSize(\"height\") - availableTop\n    };\n  }\n  var swappedTop = getAboveCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, screenBottom - elHeight);\n  } else {\n    actualY = \"above\";\n    top = swappedTop;\n  }\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\nexport function createVerticalPosition(_a) {\n  var y = _a.y,\n    vh = _a.vh,\n    vhMargin = _a.vhMargin,\n    yMargin = _a.yMargin,\n    elHeight = _a.elHeight,\n    initialY = _a.initialY,\n    containerRect = _a.containerRect,\n    disableSwapping = _a.disableSwapping,\n    preventOverlap = _a.preventOverlap,\n    disableVHBounds = _a.disableVHBounds;\n  if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n    // the element is too big to be displayed in the viewport, so just span the\n    // full viewport excluding margins\n    return {\n      top: vhMargin,\n      bottom: vhMargin,\n      actualY: \"center\"\n    };\n  }\n  var config = {\n    vhMargin: vhMargin,\n    yMargin: yMargin,\n    elHeight: elHeight,\n    initialY: initialY,\n    containerRect: containerRect,\n    screenBottom: vh - vhMargin,\n    preventOverlap: preventOverlap,\n    disableSwapping: disableSwapping,\n    disableVHBounds: disableVHBounds\n  };\n  switch (y) {\n    case \"above\":\n      return createAnchoredAbove(config);\n    case \"top\":\n      return createAnchoredTop(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"bottom\":\n      return createAnchoredBottom(config);\n    case \"below\":\n      return createAnchoredBelow(config);\n  }\n}","map":{"version":3,"mappings":"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","names":["getAboveCoord","getBelowCoord","getBottomCoord","getCenterYCoord","getTopCoord","getViewportSize","createAnchoredAbove","config","vhMargin","screenBottom","elHeight","containerRect","preventOverlap","disableSwapping","disableVHBounds","top","actualY","Math","max","swappedTop","min","bottom","window","innerHeight","yMargin","createAnchoredTop","createAnchoredCenter","createAnchoredBottom","createAnchoredBelow","availableTop","createVerticalPosition","_a","y","vh","initialY"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/positioning/createVerticalPosition.ts"],"sourcesContent":["import type { YCoordConfig } from \"./getCoord\";\nimport {\n  getAboveCoord,\n  getBelowCoord,\n  getBottomCoord,\n  getCenterYCoord,\n  getTopCoord,\n} from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\nimport type { FixedPositionOptions, VerticalPosition } from \"./types\";\n\n/**\n * @internal\n */\ninterface YPosition {\n  top: number;\n  bottom?: number;\n  actualY: VerticalPosition;\n}\n\n/**\n * @internal\n */\nexport interface FixConfig extends YCoordConfig {\n  vhMargin: number;\n  screenBottom: number;\n  preventOverlap: boolean;\n  disableSwapping: boolean;\n  disableVHBounds: boolean;\n}\n\n/**\n * @internal\n */\ninterface Options\n  extends Required<\n    Pick<\n      FixedPositionOptions,\n      | \"yMargin\"\n      | \"vhMargin\"\n      | \"preventOverlap\"\n      | \"disableSwapping\"\n      | \"disableVHBounds\"\n    >\n  > {\n  y: VerticalPosition;\n  vh: number;\n  initialY?: number;\n  elHeight: number;\n  containerRect: DOMRect;\n}\n\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredAbove(config: FixConfig): YPosition {\n  const {\n    yMargin,\n    vhMargin,\n    screenBottom,\n    elHeight,\n    containerRect,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  } = config;\n  let top = getAboveCoord(config);\n  let actualY: VerticalPosition = \"above\";\n\n  if (disableVHBounds) {\n    // can't actually allow a top value as a negative number since browsers\n    // won't scroll upwards pas the normal page top\n    return { actualY, top: Math.max(0, top) };\n  }\n\n  if (top > vhMargin) {\n    // don't need to do anything else since the top is still in the viewport and\n    // since it's positioned above, we already know it can't overlap the\n    // container element\n    return { actualY, top };\n  }\n\n  const swappedTop = getBelowCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, vhMargin);\n  } else {\n    actualY = \"below\";\n    top = swappedTop;\n  }\n\n  let bottom: number | undefined;\n  if (\n    preventOverlap &&\n    // can't overlap if it's positioned below\n    actualY === \"above\" &&\n    top + elHeight > containerRect.top\n  ) {\n    bottom = window.innerHeight - containerRect.top + yMargin;\n  }\n\n  return { actualY, top, bottom };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredTop(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableSwapping, disableVHBounds } =\n    config;\n  let top = getTopCoord(config);\n  let actualY: VerticalPosition = \"top\";\n\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return { actualY, top };\n  }\n\n  const swappedTop = getBottomCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, vhMargin);\n  } else {\n    actualY = \"bottom\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\nexport function createAnchoredCenter(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableVHBounds } = config;\n  let top = getCenterYCoord(config);\n  const actualY: VerticalPosition = \"center\";\n  if (disableVHBounds) {\n    return { actualY, top: Math.max(0, top) };\n  }\n\n  top = Math.max(vhMargin, top);\n  if (top + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBottom(config: FixConfig): YPosition {\n  const { vhMargin, screenBottom, elHeight, disableSwapping, disableVHBounds } =\n    config;\n  let top = getBottomCoord(config);\n  let actualY: VerticalPosition = \"bottom\";\n  if (disableVHBounds || top > vhMargin) {\n    return { actualY, top };\n  }\n\n  const swappedTop = getTopCoord(config);\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = Math.min(top, screenBottom - elHeight);\n  } else {\n    actualY = \"top\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBelow(config: FixConfig): YPosition {\n  const {\n    yMargin,\n    vhMargin,\n    elHeight,\n    screenBottom,\n    containerRect,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  } = config;\n  let top = getBelowCoord(config);\n  let actualY: VerticalPosition = \"below\";\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return { actualY, top };\n  }\n\n  if (preventOverlap) {\n    const availableTop = containerRect.top - yMargin;\n    if (disableSwapping || availableTop < screenBottom - top) {\n      return {\n        actualY,\n        top,\n        bottom: vhMargin,\n      };\n    }\n\n    return {\n      actualY: \"above\",\n      top: Math.max(vhMargin, availableTop - elHeight),\n      // this makes it so that the bottom of the fixed element is the top of the container\n      // element. this ensures that it won't ever overlap the container element\n      bottom: getViewportSize(\"height\") - availableTop,\n    };\n  }\n\n  const swappedTop = getAboveCoord(config);\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = Math.max(top, screenBottom - elHeight);\n  } else {\n    actualY = \"above\";\n    top = swappedTop;\n  }\n\n  return { actualY, top };\n}\n\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\nexport function createVerticalPosition({\n  y,\n  vh,\n  vhMargin,\n  yMargin,\n  elHeight,\n  initialY,\n  containerRect,\n  disableSwapping,\n  preventOverlap,\n  disableVHBounds,\n}: Options): YPosition {\n  if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n    // the element is too big to be displayed in the viewport, so just span the\n    // full viewport excluding margins\n    return {\n      top: vhMargin,\n      bottom: vhMargin,\n      actualY: \"center\",\n    };\n  }\n\n  const config: FixConfig = {\n    vhMargin,\n    yMargin,\n    elHeight,\n    initialY,\n    containerRect,\n    screenBottom: vh - vhMargin,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  };\n\n  switch (y) {\n    case \"above\":\n      return createAnchoredAbove(config);\n    case \"top\":\n      return createAnchoredTop(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"bottom\":\n      return createAnchoredBottom(config);\n    case \"below\":\n      return createAnchoredBelow(config);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}