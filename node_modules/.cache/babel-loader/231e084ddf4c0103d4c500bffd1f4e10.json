{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useTimeout, useToggle } from \"@react-md/utils\";\nimport { DEFAULT_MESSAGE_QUEUE_TIMEOUT } from \"./MessageQueueContext\";\nimport { useWindowBlurPause } from \"./useWindowBlurPause\";\nexport var ADD_MESSAGE = \"ADD_MESSAGE\";\nexport var POP_MESSAGE = \"POP_MESSAGE\";\nexport var RESET_QUEUE = \"RESET_QUEUE\";\n/**\n * @internal\n */\nexport function addMessage(message, duplicates) {\n  return {\n    type: ADD_MESSAGE,\n    message: message,\n    duplicates: duplicates\n  };\n}\n/**\n * @internal\n */\nexport var popMessage = function () {\n  return {\n    type: POP_MESSAGE\n  };\n};\n/**\n * @internal\n */\nexport var resetQueue = function () {\n  return {\n    type: RESET_QUEUE\n  };\n};\n/**\n * This function is used to update the message queue state by adding a new\n * message when needed.\n *\n * @internal\n */\nexport function handleAddMessage(state, message, duplicates) {\n  if (state.length === 0) {\n    return [message];\n  }\n  var messageId = message.messageId,\n    _a = message.messagePriority,\n    messagePriority = _a === void 0 ? \"normal\" : _a;\n  var i = state.findIndex(function (mes) {\n    return mes.messageId === messageId;\n  });\n  var isNext = messagePriority === \"next\";\n  var isNormal = messagePriority === \"normal\";\n  var isReplace = messagePriority === \"replace\";\n  var isImmediate = messagePriority === \"immediate\";\n  var isDuplicable = duplicates === \"allow\";\n  var isRestart = duplicates === \"restart\";\n  if (isNext || isImmediate) {\n    var nextState = state.slice();\n    // remove the existing message if duplicated messages aren't allowed. This\n    // will kind of act like a replace + next behavior\n    if (!isDuplicable && i > 0) {\n      nextState.splice(i, 1);\n    }\n    var _b = __read(nextState),\n      current = _b[0],\n      remaining = _b.slice(1);\n    if (isImmediate && current.messagePriority !== \"immediate\") {\n      return __spreadArray([current, message, current], __read(remaining), false);\n    }\n    return __spreadArray([current, message], __read(remaining), false);\n  }\n  if (i === -1 || isDuplicable && isNormal) {\n    return __spreadArray(__spreadArray([], __read(state), false), [message], false);\n  }\n  if (isNormal) {\n    if (isRestart) {\n      // creating a new state so that the queue visibility hook can still be\n      // triggered which will restart the timer\n      return state.slice();\n    }\n    return state;\n  }\n  if (isReplace) {\n    var nextState = state.slice();\n    nextState[i] = message;\n    return nextState;\n  }\n  return __spreadArray(__spreadArray([], __read(state), false), [message], false);\n}\n/**\n * @internal\n */\nexport function reducer(state, action) {\n  switch (action.type) {\n    case ADD_MESSAGE:\n      return handleAddMessage(state, action.message, action.duplicates);\n    case POP_MESSAGE:\n      return state.length ? state.slice(1) : state;\n    case RESET_QUEUE:\n      return state.length ? [] : state;\n    default:\n      return state;\n  }\n}\n/**\n * This is the main logic for the message queue behavior that will handle:\n *\n * - creating timeouts as needed to show/hide toasts within the `SnackbarQueue`\n *   component\n * - create a way to push messages with optional priority onto the queue\n *\n * @internal\n */\nexport function useMessageQueue(_a) {\n  var _b = _a.timeout,\n    timeout = _b === void 0 ? DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b,\n    _c = _a.duplicates,\n    duplicates = _c === void 0 ? \"allow\" : _c,\n    _d = _a.defaultQueue,\n    defaultQueue = _d === void 0 ? [] : _d;\n  var _e = __read(useReducer(function (state, action) {\n      return reducer(state, action);\n    }, defaultQueue), 2),\n    queue = _e[0],\n    dispatch = _e[1];\n  var queueRef = useRef(queue);\n  var addMessageDispatch = useCallback(function (message) {\n    if (duplicates !== \"allow\" && !message.messageId) {\n      throw new Error(\"A messageId is required when the \\\"\".concat(duplicates, \"\\\" duplicate behavior is enabled but it was not provided in the current message.\"));\n    }\n    dispatch({\n      type: ADD_MESSAGE,\n      message: message,\n      duplicates: duplicates\n    });\n  }, [duplicates]);\n  var popMessageDispatch = useCallback(function () {\n    dispatch(popMessage());\n  }, []);\n  var resetQueueDispatch = useCallback(function () {\n    dispatch(resetQueue());\n    return queueRef.current;\n  }, []);\n  var _f = __read(useToggle(defaultQueue.length > 0), 3),\n    visible = _f[0],\n    showMessage = _f[1],\n    hideMessage = _f[2];\n  var _g = __read(useTimeout(hideMessage, timeout), 3),\n    startTimer = _g[0],\n    stopTimer = _g[1],\n    restartTimer = _g[2];\n  useEffect(function () {\n    // this effect will handle all the \"logic\" for transitioning between each\n    // message along with the message priority updates.\n    var _a = __read(queue, 2),\n      message = _a[0],\n      nextMessage = _a[1];\n    if (!message) {\n      return;\n    }\n    var prevQueue = queueRef.current;\n    var _b = __read(prevQueue, 1),\n      prevMessage = _b[0];\n    if (message.messagePriority !== \"immediate\" && nextMessage && nextMessage.messagePriority === \"immediate\") {\n      stopTimer();\n      if (!visible) {\n        popMessageDispatch();\n        return;\n      }\n      hideMessage();\n      return;\n    }\n    if (!visible) {\n      showMessage();\n    }\n    if (queue.length === prevQueue.length && message === prevMessage) {\n      restartTimer();\n    }\n    // only want to run this on queue changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queue]);\n  useWindowBlurPause({\n    startTimer: startTimer,\n    stopTimer: stopTimer,\n    visible: visible,\n    message: queue[0]\n  });\n  useEffect(function () {\n    queueRef.current = queue;\n  });\n  return {\n    queue: queue,\n    resetQueue: resetQueueDispatch,\n    visible: visible,\n    hideMessage: hideMessage,\n    addMessage: addMessageDispatch,\n    popMessage: popMessageDispatch,\n    startTimer: startTimer,\n    stopTimer: stopTimer,\n    restartTimer: restartTimer\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useReducer","useRef","useTimeout","useToggle","DEFAULT_MESSAGE_QUEUE_TIMEOUT","useWindowBlurPause","ADD_MESSAGE","POP_MESSAGE","RESET_QUEUE","addMessage","message","duplicates","type","popMessage","resetQueue","handleAddMessage","state","length","_a","messagePriority","i","findIndex","mes","messageId","isNext","isNormal","isReplace","isImmediate","isDuplicable","isRestart","nextState","slice","splice","current","remaining","reducer","action","useMessageQueue","_b","timeout","_c","_d","defaultQueue","queue","dispatch","queueRef","addMessageDispatch","Error","popMessageDispatch","resetQueueDispatch","visible","showMessage","hideMessage","startTimer","stopTimer","restartTimer","nextMessage","prevQueue","prevMessage"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/alert/src/useMessageQueue.ts"],"sourcesContent":["import type { Reducer } from \"react\";\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { useTimeout, useToggle } from \"@react-md/utils\";\n\nimport type {\n  AddMessage,\n  DuplicateBehavior,\n  Message,\n  MessageQueueActions,\n  PopMessage,\n  ResetQueue,\n  ToastMessage,\n} from \"./MessageQueueContext\";\nimport { DEFAULT_MESSAGE_QUEUE_TIMEOUT } from \"./MessageQueueContext\";\nimport { useWindowBlurPause } from \"./useWindowBlurPause\";\n\nexport const ADD_MESSAGE = \"ADD_MESSAGE\";\nexport const POP_MESSAGE = \"POP_MESSAGE\";\nexport const RESET_QUEUE = \"RESET_QUEUE\";\n\n/**\n * @internal\n */\nexport interface AddMessageAction<M extends Message = ToastMessage> {\n  type: typeof ADD_MESSAGE;\n  message: M;\n  duplicates: DuplicateBehavior;\n}\n\n/**\n * @internal\n */\nexport function addMessage<M extends Message = ToastMessage>(\n  message: M,\n  duplicates: DuplicateBehavior\n): AddMessageAction {\n  return { type: ADD_MESSAGE, message, duplicates };\n}\n\n/**\n * @internal\n */\nexport interface PopMessageAction {\n  type: typeof POP_MESSAGE;\n}\n\n/**\n * @internal\n */\nexport const popMessage = (): PopMessageAction => ({ type: POP_MESSAGE });\n\n/**\n * @internal\n */\nexport interface ResetQueueAction {\n  type: typeof RESET_QUEUE;\n}\n\n/**\n * @internal\n */\nexport const resetQueue = (): ResetQueueAction => ({ type: RESET_QUEUE });\n\n/**\n * @internal\n */\nexport type MessageActions<M extends Message = ToastMessage> =\n  | AddMessageAction<M>\n  | PopMessageAction\n  | ResetQueueAction;\n\n/**\n * This function is used to update the message queue state by adding a new\n * message when needed.\n *\n * @internal\n */\nexport function handleAddMessage<M extends Message = ToastMessage>(\n  state: readonly M[],\n  message: M,\n  duplicates: DuplicateBehavior\n): readonly M[] {\n  if (state.length === 0) {\n    return [message];\n  }\n\n  const { messageId, messagePriority = \"normal\" } = message;\n  const i = state.findIndex((mes) => mes.messageId === messageId);\n  const isNext = messagePriority === \"next\";\n  const isNormal = messagePriority === \"normal\";\n  const isReplace = messagePriority === \"replace\";\n  const isImmediate = messagePriority === \"immediate\";\n  const isDuplicable = duplicates === \"allow\";\n  const isRestart = duplicates === \"restart\";\n  if (isNext || isImmediate) {\n    const nextState = state.slice();\n\n    // remove the existing message if duplicated messages aren't allowed. This\n    // will kind of act like a replace + next behavior\n    if (!isDuplicable && i > 0) {\n      nextState.splice(i, 1);\n    }\n\n    const [current, ...remaining] = nextState;\n    if (isImmediate && current.messagePriority !== \"immediate\") {\n      return [current, message, current, ...remaining];\n    }\n\n    return [current, message, ...remaining];\n  }\n\n  if (i === -1 || (isDuplicable && isNormal)) {\n    return [...state, message];\n  }\n\n  if (isNormal) {\n    if (isRestart) {\n      // creating a new state so that the queue visibility hook can still be\n      // triggered which will restart the timer\n      return state.slice();\n    }\n\n    return state;\n  }\n\n  if (isReplace) {\n    const nextState = state.slice();\n    nextState[i] = message;\n    return nextState;\n  }\n\n  return [...state, message];\n}\n\ntype MessageQueueReducer<M extends Message = ToastMessage> = Reducer<\n  readonly M[],\n  MessageActions<M>\n>;\n\n/**\n * @internal\n */\nexport function reducer<M extends Message = ToastMessage>(\n  state: readonly M[],\n  action: MessageActions<M>\n): readonly M[] {\n  switch (action.type) {\n    case ADD_MESSAGE:\n      return handleAddMessage(state, action.message, action.duplicates);\n    case POP_MESSAGE:\n      return state.length ? state.slice(1) : state;\n    case RESET_QUEUE:\n      return state.length ? [] : state;\n    default:\n      return state;\n  }\n}\n\nexport interface MessageQueueOptions<M extends Message = ToastMessage> {\n  timeout?: number;\n  duplicates?: DuplicateBehavior;\n  defaultQueue?: readonly M[];\n}\n\nexport interface MessageQueueResult<M extends Message = ToastMessage>\n  extends MessageQueueActions<M> {\n  queue: readonly M[];\n  visible: boolean;\n  addMessage: AddMessage<M>;\n}\n\n/**\n * This is the main logic for the message queue behavior that will handle:\n *\n * - creating timeouts as needed to show/hide toasts within the `SnackbarQueue`\n *   component\n * - create a way to push messages with optional priority onto the queue\n *\n * @internal\n */\nexport function useMessageQueue<M extends Message = ToastMessage>({\n  timeout = DEFAULT_MESSAGE_QUEUE_TIMEOUT,\n  duplicates = \"allow\",\n  defaultQueue = [],\n}: MessageQueueOptions<M>): MessageQueueResult<M> {\n  const [queue, dispatch] = useReducer<MessageQueueReducer<M>>(\n    (state, action) => reducer<M>(state, action),\n    defaultQueue\n  );\n  const queueRef = useRef(queue);\n\n  const addMessageDispatch = useCallback<AddMessage<M>>(\n    (message) => {\n      if (duplicates !== \"allow\" && !message.messageId) {\n        throw new Error(\n          `A messageId is required when the \"${duplicates}\" duplicate behavior is enabled but it was not provided in the current message.`\n        );\n      }\n\n      dispatch({ type: ADD_MESSAGE, message, duplicates });\n    },\n    [duplicates]\n  );\n\n  const popMessageDispatch = useCallback<PopMessage>(() => {\n    dispatch(popMessage());\n  }, []);\n\n  const resetQueueDispatch = useCallback<ResetQueue<M>>(() => {\n    dispatch(resetQueue());\n    return queueRef.current;\n  }, []);\n  const [visible, showMessage, hideMessage] = useToggle(\n    defaultQueue.length > 0\n  );\n  const [startTimer, stopTimer, restartTimer] = useTimeout(\n    hideMessage,\n    timeout\n  );\n\n  useEffect(() => {\n    // this effect will handle all the \"logic\" for transitioning between each\n    // message along with the message priority updates.\n    const [message, nextMessage] = queue;\n    if (!message) {\n      return;\n    }\n\n    const prevQueue = queueRef.current;\n    const [prevMessage] = prevQueue;\n    if (\n      message.messagePriority !== \"immediate\" &&\n      nextMessage &&\n      nextMessage.messagePriority === \"immediate\"\n    ) {\n      stopTimer();\n      if (!visible) {\n        popMessageDispatch();\n        return;\n      }\n\n      hideMessage();\n      return;\n    }\n\n    if (!visible) {\n      showMessage();\n    }\n\n    if (queue.length === prevQueue.length && message === prevMessage) {\n      restartTimer();\n    }\n\n    // only want to run this on queue changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [queue]);\n\n  useWindowBlurPause({\n    startTimer,\n    stopTimer,\n    visible,\n    message: queue[0],\n  });\n  useEffect(() => {\n    queueRef.current = queue;\n  });\n\n  return {\n    queue,\n    resetQueue: resetQueueDispatch,\n    visible,\n    hideMessage,\n    addMessage: addMessageDispatch,\n    popMessage: popMessageDispatch,\n    startTimer,\n    stopTimer,\n    restartTimer,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}