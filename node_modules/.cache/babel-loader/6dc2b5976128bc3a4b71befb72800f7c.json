{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useReducer } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\nimport { createRippleState, getType, isBubbled, isRippleable } from \"./utils\";\nexport var CREATE = \"CREATE\";\nexport var CANCEL = \"CANCEL\";\nexport var RELEASE = \"RELEASE\";\nexport var ENTERED = \"ENTERED\";\nexport var REMOVE = \"REMOVE\";\n/**\n * This function will create a simplified version of the create event\n * that only includes the parts that are needed to trigger a ripple.\n * This is really only required since `event.persist()` crashed a lot\n * when spamming the trigger events and it threw warnings when not\n * persisting the event.\n */\nexport function createRippleAction(event, disableSpacebarClick) {\n  var _a = event,\n    type = _a.type,\n    target = _a.target,\n    currentTarget = _a.currentTarget,\n    touches = _a.touches,\n    pageX = _a.pageX,\n    pageY = _a.pageY,\n    button = _a.button,\n    key = _a.key;\n  return {\n    type: CREATE,\n    disableSpacebarClick: disableSpacebarClick,\n    event: {\n      type: type,\n      key: key,\n      target: target,\n      button: button,\n      currentTarget: currentTarget,\n      touches: touches,\n      pageX: pageX,\n      pageY: pageY\n    }\n  };\n}\nfunction createRipple(state, event, disableSpacebarClick) {\n  if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {\n    return state;\n  }\n  if (state.find(function (r) {\n    return r.holding;\n  }) || getType(event) !== \"touch\" && state.find(function (r) {\n    return r.type === \"touch\";\n  })) {\n    // keyboard events are a bit different than the others since it is actually\n    // spammable since the space or enter key can be held down which triggers click\n    // events infinitely until they release. There's also the fun fact that mouse\n    // events are triggered after touch events, so we need to make sure duplicate\n    // ripples aren't created for these\n    return state;\n  }\n  var ripple = createRippleState(event);\n  return __spreadArray(__spreadArray([], __read(state), false), [ripple], false);\n}\nfunction enteredRipple(state, ripple) {\n  var i = state.findIndex(function (r) {\n    return r === ripple;\n  });\n  if (i === -1 || ripple.exiting) {\n    return state;\n  }\n  var nextState = state.slice();\n  var exiting = !ripple.holding || Date.now() - ripple.startTime > 300;\n  nextState[i] = __assign(__assign({}, ripple), {\n    exiting: exiting,\n    entered: true\n  });\n  return nextState;\n}\nfunction releaseRipple(state) {\n  var i = state.findIndex(function (r) {\n    return r.holding && !r.exiting;\n  });\n  if (i === -1) {\n    return state;\n  }\n  var ripple = state[i];\n  var exiting = ripple.entered || Date.now() - ripple.startTime > 300;\n  var nextState = state.slice();\n  nextState[i] = __assign(__assign({}, ripple), {\n    exiting: exiting,\n    holding: false\n  });\n  return nextState;\n}\nfunction removeRipple(state, ripple) {\n  var i = state.findIndex(function (r) {\n    return r.startTime === ripple.startTime;\n  });\n  if (i === -1) {\n    return state;\n  }\n  var nextState = state.slice();\n  nextState.splice(i, 1);\n  return nextState;\n}\nfunction cancelRipples(state, ease) {\n  if (ease) {\n    return state.map(function (r) {\n      return __assign(__assign({}, r), {\n        exiting: true,\n        mounted: true,\n        holding: false\n      });\n    });\n  }\n  return [];\n}\nexport function reducer(state, action) {\n  if (state === void 0) {\n    state = [];\n  }\n  switch (action.type) {\n    case CREATE:\n      return createRipple(state, action.event, action.disableSpacebarClick);\n    case RELEASE:\n      return releaseRipple(state);\n    case CANCEL:\n      return cancelRipples(state, action.ease);\n    case ENTERED:\n      return enteredRipple(state, action.ripple);\n    case REMOVE:\n      return removeRipple(state, action.ripple);\n    default:\n      return state;\n  }\n}\n/**\n * This hook creates memoized callbacks for each part of the ripple transition\n * as well as returning the current list of ripples.\n */\nexport function useRippleTransition(disableSpacebarClick) {\n  if (disableSpacebarClick === void 0) {\n    disableSpacebarClick = false;\n  }\n  var _a = __read(useReducer(reducer, []), 2),\n    state = _a[0],\n    dispatch = _a[1];\n  var spacebarRef = useRefCache(disableSpacebarClick);\n  var create = useCallback(function (event) {\n    var disableSpacebarClick = spacebarRef.current;\n    dispatch(createRippleAction(event, disableSpacebarClick));\n    // disabled since useRefCache\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var release = useCallback(function (event) {\n    dispatch({\n      type: RELEASE,\n      event: event\n    });\n  }, []);\n  var entered = useCallback(function (ripple) {\n    dispatch({\n      type: ENTERED,\n      ripple: ripple\n    });\n  }, []);\n  var cancel = useCallback(function (ease) {\n    if (ease === void 0) {\n      ease = false;\n    }\n    dispatch({\n      type: CANCEL,\n      ease: ease\n    });\n  }, []);\n  var remove = useCallback(function (ripple) {\n    dispatch({\n      type: REMOVE,\n      ripple: ripple\n    });\n  }, []);\n  return {\n    state: state,\n    create: create,\n    release: release,\n    entered: entered,\n    remove: remove,\n    cancel: cancel\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useReducer","useRefCache","createRippleState","getType","isBubbled","isRippleable","CREATE","CANCEL","RELEASE","ENTERED","REMOVE","createRippleAction","event","disableSpacebarClick","type","target","currentTarget","touches","pageX","pageY","button","key","createRipple","state","find","r","holding","ripple","enteredRipple","i","findIndex","exiting","nextState","slice","Date","now","startTime","entered","releaseRipple","removeRipple","splice","cancelRipples","ease","map","mounted","reducer","action","useRippleTransition","dispatch","spacebarRef","create","current","release","cancel","remove"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/states/src/ripples/reducer.ts"],"sourcesContent":["import type { Reducer } from \"react\";\nimport { useCallback, useReducer } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\n\nimport type { RippleEvent, RipplesState, RippleState } from \"./types\";\nimport { createRippleState, getType, isBubbled, isRippleable } from \"./utils\";\n\nexport const CREATE = \"CREATE\";\nexport const CANCEL = \"CANCEL\";\nexport const RELEASE = \"RELEASE\";\nexport const ENTERED = \"ENTERED\";\nexport const REMOVE = \"REMOVE\";\n\nexport interface CreateAction<E extends HTMLElement> {\n  type: typeof CREATE;\n  event: RippleEvent<E>;\n  disableSpacebarClick: boolean;\n}\nexport interface ReleaseAction<E extends HTMLElement> {\n  type: typeof RELEASE;\n  event: RippleEvent<E>;\n}\nexport interface EnteredAction {\n  type: typeof ENTERED;\n  ripple: RippleState;\n}\nexport interface RemoveAction {\n  type: typeof REMOVE;\n  ripple: RippleState;\n}\n\nexport interface CancelAction {\n  type: typeof CANCEL;\n  ease: boolean;\n}\ntype RippleStateAction<E extends HTMLElement> =\n  | CreateAction<E>\n  | ReleaseAction<E>\n  | CancelAction\n  | EnteredAction\n  | RemoveAction;\ntype RippleStateReducer<E extends HTMLElement> = Reducer<\n  RipplesState,\n  RippleStateAction<E>\n>;\n\n/**\n * This function will create a simplified version of the create event\n * that only includes the parts that are needed to trigger a ripple.\n * This is really only required since `event.persist()` crashed a lot\n * when spamming the trigger events and it threw warnings when not\n * persisting the event.\n */\nexport function createRippleAction<E extends HTMLElement>(\n  event: RippleEvent<E>,\n  disableSpacebarClick: boolean\n): CreateAction<E> {\n  const { type, target, currentTarget, touches, pageX, pageY, button, key } =\n    event as React.MouseEvent<E> & React.TouchEvent<E> & React.KeyboardEvent<E>;\n\n  return {\n    type: CREATE,\n    disableSpacebarClick,\n    event: {\n      type,\n      key,\n      target,\n      button,\n      currentTarget,\n      touches,\n      pageX,\n      pageY,\n    },\n  };\n}\n\nfunction createRipple(\n  state: RipplesState,\n  event: RippleEvent<HTMLElement>,\n  disableSpacebarClick: boolean\n): RipplesState {\n  if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {\n    return state;\n  }\n\n  if (\n    state.find((r) => r.holding) ||\n    (getType(event) !== \"touch\" && state.find((r) => r.type === \"touch\"))\n  ) {\n    // keyboard events are a bit different than the others since it is actually\n    // spammable since the space or enter key can be held down which triggers click\n    // events infinitely until they release. There's also the fun fact that mouse\n    // events are triggered after touch events, so we need to make sure duplicate\n    // ripples aren't created for these\n    return state;\n  }\n\n  const ripple = createRippleState(event);\n  return [...state, ripple];\n}\n\nfunction enteredRipple(state: RipplesState, ripple: RippleState): RipplesState {\n  const i = state.findIndex((r) => r === ripple);\n  if (i === -1 || ripple.exiting) {\n    return state;\n  }\n\n  const nextState = state.slice();\n  const exiting = !ripple.holding || Date.now() - ripple.startTime > 300;\n  nextState[i] = {\n    ...ripple,\n    exiting,\n    entered: true,\n  };\n  return nextState;\n}\n\nfunction releaseRipple(state: RipplesState): RipplesState {\n  const i = state.findIndex((r) => r.holding && !r.exiting);\n  if (i === -1) {\n    return state;\n  }\n\n  const ripple = state[i];\n  const exiting = ripple.entered || Date.now() - ripple.startTime > 300;\n  const nextState = state.slice();\n  nextState[i] = {\n    ...ripple,\n    exiting,\n    holding: false,\n  };\n  return nextState;\n}\n\nfunction removeRipple(state: RipplesState, ripple: RippleState): RipplesState {\n  const i = state.findIndex((r) => r.startTime === ripple.startTime);\n  if (i === -1) {\n    return state;\n  }\n\n  const nextState = state.slice();\n  nextState.splice(i, 1);\n  return nextState;\n}\n\nfunction cancelRipples(state: RipplesState, ease: boolean): RipplesState {\n  if (ease) {\n    return state.map((r) => ({\n      ...r,\n      exiting: true,\n      mounted: true,\n      holding: false,\n    }));\n  }\n\n  return [];\n}\n\nexport function reducer<E extends HTMLElement>(\n  state: RipplesState = [],\n  action: RippleStateAction<E>\n): RipplesState {\n  switch (action.type) {\n    case CREATE:\n      return createRipple(state, action.event, action.disableSpacebarClick);\n    case RELEASE:\n      return releaseRipple(state);\n    case CANCEL:\n      return cancelRipples(state, action.ease);\n    case ENTERED:\n      return enteredRipple(state, action.ripple);\n    case REMOVE:\n      return removeRipple(state, action.ripple);\n    default:\n      return state;\n  }\n}\n\ninterface ReturnValue<E extends HTMLElement> {\n  state: RipplesState;\n  create: (event: RippleEvent<E>) => void;\n  release: (event: RippleEvent<E>) => void;\n  entered: (ripple: RippleState) => void;\n  cancel: (ease?: boolean) => void;\n  remove: (ripple: RippleState) => void;\n}\n\n/**\n * This hook creates memoized callbacks for each part of the ripple transition\n * as well as returning the current list of ripples.\n */\nexport function useRippleTransition<E extends HTMLElement = HTMLElement>(\n  disableSpacebarClick = false\n): ReturnValue<E> {\n  const [state, dispatch] = useReducer<RippleStateReducer<E>>(reducer, []);\n  const spacebarRef = useRefCache(disableSpacebarClick);\n  const create = useCallback((event: RippleEvent<E>) => {\n    const disableSpacebarClick = spacebarRef.current;\n    dispatch(createRippleAction(event, disableSpacebarClick));\n    // disabled since useRefCache\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const release = useCallback((event: RippleEvent<E>) => {\n    dispatch({ type: RELEASE, event });\n  }, []);\n  const entered = useCallback((ripple: RippleState) => {\n    dispatch({ type: ENTERED, ripple });\n  }, []);\n  const cancel = useCallback((ease = false) => {\n    dispatch({ type: CANCEL, ease });\n  }, []);\n  const remove = useCallback((ripple: RippleState) => {\n    dispatch({ type: REMOVE, ripple });\n  }, []);\n\n  return { state, create, release, entered, remove, cancel };\n}\n"]},"metadata":{},"sourceType":"module"}