{"ast":null,"code":"import { useEffect, useRef } from \"react\";\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\nexport function usePreviousFocus(disabled, fallback, previousElement) {\n  if (fallback === void 0) {\n    fallback = undefined;\n  }\n  if (previousElement === void 0) {\n    previousElement = null;\n  }\n  var options = useRef({\n    disabled: disabled,\n    fallback: fallback\n  });\n  useEffect(function () {\n    options.current = {\n      disabled: disabled,\n      fallback: fallback\n    };\n  });\n  useEffect(function () {\n    if (disabled) {\n      return;\n    }\n    var element = previousElement || document.activeElement;\n    // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n    var menu = element.closest('[role=\"menu\"]');\n    var menuButton = null;\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-delimitated\n        // string of ids, have to check each one\n        var labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        var query = labelledBy.split(\" \").map(function (id) {\n          return \"#\".concat(id, \"[tabindex]\");\n        }).join(\",\");\n        menuButton = query ? document.querySelector(query) : null;\n      }\n    }\n    return function () {\n      var _a = options.current,\n        fallback = _a.fallback,\n        disabled = _a.disabled;\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n      if (menu && menuButton && !previousElement && !fallback && !document.contains(element) && document.contains(menuButton)) {\n        menuButton.focus();\n        return;\n      }\n      var el = element;\n      if (!document.contains(el)) {\n        el = previousElement && document.contains(previousElement) ? previousElement : null;\n      }\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector(fallback);\n            break;\n          case \"function\":\n            el = fallback();\n            break;\n          default:\n            el = fallback;\n        }\n      }\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n      if (el) {\n        el.focus();\n      }\n    };\n    // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAazC;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAM,SAAUC,gBAAgB,CAC9BC,QAAiB,EACjBC,QAAmC,EACnCC,eAA0C;EAD1C;IAAAD,oBAAmC;EAAA;EACnC;IAAAC,sBAA0C;EAAA;EAE1C,IAAMC,OAAO,GAAGL,MAAM,CAAC;IACrBE,QAAQ;IACRC,QAAQ;GACT,CAAC;EAEFJ,SAAS,CAAC;IACRM,OAAO,CAACC,OAAO,GAAG;MAChBJ,QAAQ;MACRC,QAAQ;KACT;EACH,CAAC,CAAC;EAEFJ,SAAS,CAAC;IACR,IAAIG,QAAQ,EAAE;MACZ;;IAGF,IAAMK,OAAO,GAAGH,eAAe,IAAKI,QAAQ,CAACC,aAA6B;IAE1E;IACA;IACA;IACA;IACA,IAAMC,IAAI,GAAGH,OAAO,CAACI,OAAO,CAAC,eAAe,CAAC;IAC7C,IAAIC,UAAU,GAAuB,IAAI;IACzC,IAAIF,IAAI,EAAE;MACR;MACA;MACAE,UAAU,GAAGJ,QAAQ,CAACK,cAAc,CAACH,IAAI,CAACI,EAAE,CAACC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;MACnE,IAAI,CAACH,UAAU,EAAE;QACf;QACA;QACA;QACA,IAAMI,UAAU,GAAGN,IAAI,CAACO,YAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE;QAC7D,IAAMC,KAAK,GAAGF,UAAU,CACrBG,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAAC,UAACN,EAAE;UAAK,kBAAIA,EAAE,eAAY;QAAlB,CAAkB,CAAC,CAC/BO,IAAI,CAAC,GAAG,CAAC;QAEZT,UAAU,GAAGM,KAAK,GAAGV,QAAQ,CAACc,aAAa,CAAcJ,KAAK,CAAC,GAAG,IAAI;;;IAI1E,OAAO;MACC,SAAyBb,OAAO,CAACC,OAAO;QAAtCH,QAAQ;QAAED,QAAQ,cAAoB;MAC9C,IAAIA,QAAQ,EAAE;QACZ;QACA;QACA;QACA;QACA;;MAGF,IACEQ,IAAI,IACJE,UAAU,IACV,CAACR,eAAe,IAChB,CAACD,QAAQ,IACT,CAACK,QAAQ,CAACe,QAAQ,CAAChB,OAAO,CAAC,IAC3BC,QAAQ,CAACe,QAAQ,CAACX,UAAU,CAAC,EAC7B;QACAA,UAAU,CAACY,KAAK,EAAE;QAClB;;MAGF,IAAIC,EAAE,GAAuBlB,OAAO;MACpC,IAAI,CAACC,QAAQ,CAACe,QAAQ,CAACE,EAAE,CAAC,EAAE;QAC1BA,EAAE,GACArB,eAAe,IAAII,QAAQ,CAACe,QAAQ,CAACnB,eAAe,CAAC,GACjDA,eAAe,GACf,IAAI;;MAGZ,IAAI,CAACqB,EAAE,IAAItB,QAAQ,EAAE;QACnB,QAAQ,OAAOA,QAAQ;UACrB,KAAK,QAAQ;YACXsB,EAAE,GAAGjB,QAAQ,CAACc,aAAa,CAAcnB,QAAQ,CAAC;YAClD;UACF,KAAK,UAAU;YACbsB,EAAE,GAAGtB,QAAQ,EAAE;YACf;UACF;YACEsB,EAAE,GAAGtB,QAAQ;QAAC;;MAIpB,IAAIsB,EAAE,IAAI,CAACjB,QAAQ,CAACe,QAAQ,CAACE,EAAE,CAAC,EAAE;QAChCA,EAAE,GAAG,IAAI;;MAGX,IAAIA,EAAE,EAAE;QACNA,EAAE,CAACD,KAAK,EAAE;;IAEd,CAAC;IACD;IACA;EACF,CAAC,EAAE,EAAE,CAAC;AACR","names":["useEffect","useRef","usePreviousFocus","disabled","fallback","previousElement","options","current","element","document","activeElement","menu","closest","menuButton","getElementById","id","replace","labelledBy","getAttribute","query","split","map","join","querySelector","contains","focus","el"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/wia-aria/usePreviousFocus.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\n\n/**\n * This can either be a query selector string, a specific HTMLElement, or a\n * function that finds a specific HTMLElement to focus.\n */\nexport type FocusFallback =\n  | string\n  | HTMLElement\n  | (() => HTMLElement | null)\n  | null\n  | undefined;\n\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\nexport function usePreviousFocus(\n  disabled: boolean,\n  fallback: FocusFallback = undefined,\n  previousElement: HTMLElement | null = null\n): void {\n  const options = useRef({\n    disabled,\n    fallback,\n  });\n\n  useEffect(() => {\n    options.current = {\n      disabled,\n      fallback,\n    };\n  });\n\n  useEffect(() => {\n    if (disabled) {\n      return;\n    }\n\n    const element = previousElement || (document.activeElement as HTMLElement);\n\n    // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n    const menu = element.closest('[role=\"menu\"]');\n    let menuButton: HTMLElement | null = null;\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-delimitated\n        // string of ids, have to check each one\n        const labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        const query = labelledBy\n          .split(\" \")\n          .map((id) => `#${id}[tabindex]`)\n          .join(\",\");\n\n        menuButton = query ? document.querySelector<HTMLElement>(query) : null;\n      }\n    }\n\n    return () => {\n      const { fallback, disabled } = options.current;\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n\n      if (\n        menu &&\n        menuButton &&\n        !previousElement &&\n        !fallback &&\n        !document.contains(element) &&\n        document.contains(menuButton)\n      ) {\n        menuButton.focus();\n        return;\n      }\n\n      let el: HTMLElement | null = element;\n      if (!document.contains(el)) {\n        el =\n          previousElement && document.contains(previousElement)\n            ? previousElement\n            : null;\n      }\n\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector<HTMLElement>(fallback);\n            break;\n          case \"function\":\n            el = fallback();\n            break;\n          default:\n            el = fallback;\n        }\n      }\n\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n\n      if (el) {\n        el.focus();\n      }\n    };\n    // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n"]},"metadata":{},"sourceType":"module"}