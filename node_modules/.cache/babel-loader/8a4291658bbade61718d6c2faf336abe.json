{"ast":null,"code":"var cached = {\n  height: undefined,\n  width: undefined\n};\n/**\n * This is used to reset the cached value for each test and verify the cached\n * behavior is working\n * @internal\n */\nexport var reset = function () {\n  cached.height = undefined;\n  cached.width = undefined;\n};\n/**\n * This will return the scrollbar size for a specific OS by creating a\n * temporary element to compare the height/width between it's inner element and\n * it's own height/width when scrollbars are enabled. This is useful when your\n * height/width calculations need to exclude scrollbars since they are included\n * by default but content can't be shown underneath them for for static\n * elements.\n *\n * Note: This will return `0` on Mac OS with the default \"Only show scrollbars\n * when scrolling\" which is to be expected. These scrollbars overlay the content\n * and actually don't take up height/width real estate.\n *\n * @see https://stackoverflow.com/a/13382873\n * @param type - Either the string \"height\" or \"width\" to determine which size\n * to get\n * @param forced - Boolean if the scrollbar height/width should be force\n * updated. When this is false, the \"cached\" value will be returned immediately\n * instead\n * @returns the current scrollbar width or -1 if running this on the server\n */\nexport function scrollbarSize(type, forced) {\n  if (type === void 0) {\n    type = \"width\";\n  }\n  if (forced === void 0) {\n    forced = false;\n  }\n  /* istanbul ignore if */\n  if (typeof window === \"undefined\") {\n    return -1;\n  }\n  var value = cached[type];\n  if (!forced && typeof value === \"number\") {\n    return value;\n  }\n  var outer = document.createElement(\"div\");\n  outer.style.visibility = \"hidden\";\n  outer.style.overflow = \"scroll\";\n  document.body.appendChild(outer);\n  var inner = document.createElement(\"div\");\n  outer.appendChild(inner);\n  var offsetType = type === \"width\" ? \"offsetWidth\" : \"offsetHeight\";\n  // the scrollbar width can be determined by comparing the width of the parent\n  // element that has scrollbars to the child element that does not.\n  value = outer[offsetType] - inner[offsetType];\n  cached[type] = value;\n  document.body.removeChild(outer);\n  return value;\n}","map":{"version":3,"mappings":"AAOA,IAAMA,MAAM,GAAU;EACpBC,MAAM,EAAEC,SAAS;EACjBC,KAAK,EAAED;CACR;AAED;;;;;AAKA,OAAO,IAAME,KAAK,GAAG;EACnBJ,MAAM,CAACC,MAAM,GAAGC,SAAS;EACzBF,MAAM,CAACG,KAAK,GAAGD,SAAS;AAC1B,CAAC;AAED;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUG,aAAa,CAC3BC,IAA0B,EAC1BC,MAAc;EADd;IAAAD,cAA0B;EAAA;EAC1B;IAAAC,cAAc;EAAA;EAEd;EACA,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IACjC,OAAO,CAAC,CAAC;;EAGX,IAAIC,KAAK,GAAGT,MAAM,CAACM,IAAI,CAAC;EACxB,IAAI,CAACC,MAAM,IAAI,OAAOE,KAAK,KAAK,QAAQ,EAAE;IACxC,OAAOA,KAAK;;EAGd,IAAMC,KAAK,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EAC3CF,KAAK,CAACG,KAAK,CAACC,UAAU,GAAG,QAAQ;EACjCJ,KAAK,CAACG,KAAK,CAACE,QAAQ,GAAG,QAAQ;EAC/BJ,QAAQ,CAACK,IAAI,CAACC,WAAW,CAACP,KAAK,CAAC;EAEhC,IAAMQ,KAAK,GAAGP,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EAC3CF,KAAK,CAACO,WAAW,CAACC,KAAK,CAAC;EAExB,IAAMC,UAAU,GAAGb,IAAI,KAAK,OAAO,GAAG,aAAa,GAAG,cAAc;EAEpE;EACA;EACAG,KAAK,GAAGC,KAAK,CAACS,UAAU,CAAC,GAAGD,KAAK,CAACC,UAAU,CAAC;EAC7CnB,MAAM,CAACM,IAAI,CAAC,GAAGG,KAAK;EACpBE,QAAQ,CAACK,IAAI,CAACI,WAAW,CAACV,KAAK,CAAC;EAEhC,OAAOD,KAAK;AACd","names":["cached","height","undefined","width","reset","scrollbarSize","type","forced","window","value","outer","document","createElement","style","visibility","overflow","body","appendChild","inner","offsetType","removeChild"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/layout/scrollbarSize.ts"],"sourcesContent":["interface Cache {\n  height: number | undefined;\n  width: number | undefined;\n}\n\ntype SizingType = \"height\" | \"width\";\n\nconst cached: Cache = {\n  height: undefined,\n  width: undefined,\n};\n\n/**\n * This is used to reset the cached value for each test and verify the cached\n * behavior is working\n * @internal\n */\nexport const reset = (): void => {\n  cached.height = undefined;\n  cached.width = undefined;\n};\n\n/**\n * This will return the scrollbar size for a specific OS by creating a\n * temporary element to compare the height/width between it's inner element and\n * it's own height/width when scrollbars are enabled. This is useful when your\n * height/width calculations need to exclude scrollbars since they are included\n * by default but content can't be shown underneath them for for static\n * elements.\n *\n * Note: This will return `0` on Mac OS with the default \"Only show scrollbars\n * when scrolling\" which is to be expected. These scrollbars overlay the content\n * and actually don't take up height/width real estate.\n *\n * @see https://stackoverflow.com/a/13382873\n * @param type - Either the string \"height\" or \"width\" to determine which size\n * to get\n * @param forced - Boolean if the scrollbar height/width should be force\n * updated. When this is false, the \"cached\" value will be returned immediately\n * instead\n * @returns the current scrollbar width or -1 if running this on the server\n */\nexport function scrollbarSize(\n  type: SizingType = \"width\",\n  forced = false\n): number {\n  /* istanbul ignore if */\n  if (typeof window === \"undefined\") {\n    return -1;\n  }\n\n  let value = cached[type];\n  if (!forced && typeof value === \"number\") {\n    return value;\n  }\n\n  const outer = document.createElement(\"div\");\n  outer.style.visibility = \"hidden\";\n  outer.style.overflow = \"scroll\";\n  document.body.appendChild(outer);\n\n  const inner = document.createElement(\"div\");\n  outer.appendChild(inner);\n\n  const offsetType = type === \"width\" ? \"offsetWidth\" : \"offsetHeight\";\n\n  // the scrollbar width can be determined by comparing the width of the parent\n  // element that has scrollbars to the child element that does not.\n  value = outer[offsetType] - inner[offsetType];\n  cached[type] = value;\n  document.body.removeChild(outer);\n\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}