{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Fragment as _Fragment, jsxs as _jsxs, jsx as _jsx } from \"react/jsx-runtime\";\nimport cn from \"classnames\";\nimport { bem } from \"@react-md/utils\";\nimport { LayoutNavigation } from \"./LayoutNavigation\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nvar styles = bem(\"rmd-layout-mini-wrapper\");\n/**\n * This is probably an internal only component.\n *\n * @remarks \\@since 2.8.3\n */\nexport function MiniLayoutWrapper(_a) {\n  var mini = _a.mini,\n    miniHidden = _a.miniHidden,\n    miniNav = _a.miniNav,\n    miniNavItems = _a.miniNavItems,\n    treeProps = _a.treeProps,\n    header = _a.header,\n    headerProps = _a.headerProps,\n    headerTitle = _a.headerTitle,\n    headerTitleProps = _a.headerTitleProps,\n    closeNav = _a.closeNav,\n    closeNavProps = _a.closeNavProps,\n    children = _a.children,\n    containerProps = _a.containerProps,\n    props = __rest(_a, [\"mini\", \"miniHidden\", \"miniNav\", \"miniNavItems\", \"treeProps\", \"header\", \"headerProps\", \"headerTitle\", \"headerTitleProps\", \"closeNav\", \"closeNavProps\", \"children\", \"containerProps\"]);\n  var _b = useLayoutConfig(),\n    fixedAppBar = _b.fixedAppBar,\n    isMiniable = _b.isMiniable;\n  if (!mini && !isMiniable || !treeProps || typeof miniNav !== \"undefined\") {\n    return _jsxs(_Fragment, {\n      children: [miniNav, children]\n    });\n  }\n  var miniTreeProps = treeProps;\n  if (miniNavItems) {\n    miniTreeProps = __assign(__assign({}, miniTreeProps), {\n      navItems: miniNavItems\n    });\n  }\n  var miniNavigation = _jsx(LayoutNavigation, __assign({\n    header: header,\n    headerProps: headerProps,\n    headerTitle: headerTitle,\n    headerTitleProps: headerTitleProps,\n    closeNav: closeNav,\n    closeNavProps: closeNavProps,\n    treeProps: miniTreeProps\n  }, props, {\n    mini: true,\n    sticky: !fixedAppBar,\n    hidden: miniHidden\n  }));\n  if (fixedAppBar) {\n    return _jsxs(_Fragment, {\n      children: [miniNavigation, children]\n    });\n  }\n  return _jsxs(\"div\", __assign({}, containerProps, {\n    className: cn(!miniHidden && mini && styles(), containerProps === null || containerProps === void 0 ? void 0 : containerProps.className)\n  }, {\n    children: [mini && miniNavigation, children]\n  }));\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;AACA,OAAOA,EAAE,MAAM,YAAY;AAG3B,SAASC,GAAG,QAAQ,iBAAiB;AAGrC,SAASC,gBAAgB,QAAQ,oBAAoB;AAErD,SAASC,eAAe,QAAQ,kBAAkB;AAElD,IAAMC,MAAM,GAAGH,GAAG,CAAC,yBAAyB,CAAC;AA8D7C;;;;;AAKA,OAAM,SAAUI,iBAAiB,CAACC,EAeT;EAdvB,QAAI;IACJC,UAAU;IACVC,OAAO;IACPC,YAAY;IACZC,SAAS;IACTC,MAAM;IACNC,WAAW;IACXC,WAAW;IACXC,gBAAgB;IAChBC,QAAQ;IACRC,aAAa;IACbC,QAAQ;IACRC,cAAc;IACXC,KAAK,cAdwB,qLAejC,CADS;EAEF,SAA8BhB,eAAe,EAAE;IAA7CiB,WAAW;IAAEC,UAAU,gBAAsB;EACrD,IAAK,CAACC,IAAI,IAAI,CAACD,UAAU,IAAK,CAACX,SAAS,IAAI,OAAOF,OAAO,KAAK,WAAW,EAAE;IAC1E,OACEe;MAAAN,WACGT,OAAO,EACPS,QAAQ;IAAA,EACR;;EAIP,IAAIO,aAAa,GAAGd,SAAS;EAC7B,IAAID,YAAY,EAAE;IAChBe,aAAa,yBACRA,aAAa;MAChBC,QAAQ,EAAEhB;IAAY,EACvB;;EAGH,IAAMiB,cAAc,GAClBC,KAACzB,gBAAgB;IACfS,MAAM,EAAEA,MAAM;IACdC,WAAW,EAAEA,WAAW;IACxBC,WAAW,EAAEA,WAAW;IACxBC,gBAAgB,EAAEA,gBAAgB;IAClCC,QAAQ,EAAEA,QAAQ;IAClBC,aAAa,EAAEA,aAAa;IAC5BN,SAAS,EAAEc;EAAa,GACpBL,KAAK;IACTG,IAAI;IACJM,MAAM,EAAE,CAACR,WAAW;IACpBS,MAAM,EAAEtB;EAAU,GAErB;EAED,IAAIa,WAAW,EAAE;IACf,OACEG;MAAAN,WACGS,cAAc,EACdT,QAAQ;IAAA,EACR;;EAIP,OACEM,0BACML,cAAc;IAClBY,SAAS,EAAE9B,EAAE,CAAC,CAACO,UAAU,IAAIe,IAAI,IAAIlB,MAAM,EAAE,EAAEc,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEY,SAAS;EAAC;IAAAb,WAExEK,IAAI,IAAII,cAAc,EACtBT,QAAQ;EAAA,GACL;AAEV","names":["cn","bem","LayoutNavigation","useLayoutConfig","styles","MiniLayoutWrapper","_a","miniHidden","miniNav","miniNavItems","treeProps","header","headerProps","headerTitle","headerTitleProps","closeNav","closeNavProps","children","containerProps","props","fixedAppBar","isMiniable","mini","_jsxs","miniTreeProps","navItems","miniNavigation","_jsx","sticky","hidden","className"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/layout/src/MiniLayoutWrapper.tsx"],"sourcesContent":["import type { HTMLAttributes, ReactElement, ReactNode } from \"react\";\nimport cn from \"classnames\";\nimport type { BaseTreeItem, TreeData } from \"@react-md/tree\";\nimport type { PropsWithRef } from \"@react-md/utils\";\nimport { bem } from \"@react-md/utils\";\n\nimport type { LayoutNavigationProps } from \"./LayoutNavigation\";\nimport { LayoutNavigation } from \"./LayoutNavigation\";\nimport type { LayoutNavigationItem } from \"./types\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\n\nconst styles = bem(\"rmd-layout-mini-wrapper\");\n\n/**\n * This is probably an internal only interface.\n *\n * @remarks \\@since 2.8.3\n */\nexport interface MiniLayoutWrapperProps<\n  T extends BaseTreeItem = LayoutNavigationItem\n> extends LayoutNavigationProps<T> {\n  /**\n   * Boolean if the current layout is one of the `mini` types.\n   */\n  mini: boolean;\n\n  /**\n   * A custom implementation for the main mini navigation component within the\n   * `Layout`. If this is not `undefined`, it will be used instead of the\n   * default implementation.\n   *\n   * Using this prop will make the following props do nothing for the mini nav:\n   *\n   * - `navProps`\n   * - `navHeader`\n   * - `navHeaderProps`\n   * - `navHeaderTitle`\n   * - `navHeaderTitleProps`\n   * - `closeNav`\n   * - `closeNavProps`\n   * - `treeProps`\n   *\n   * @remarks \\@since.2.7.0\n   */\n  miniNav?: ReactNode;\n\n  /**\n   * An optional tree to use for the mini navigation pane since the default\n   * behavior of rendering mini tree items might hide content in an\n   * undesirable way.\n   *\n   * @remarks \\@since 2.7.0\n   * @see {@link defaultMiniNavigationItemRenderer} for more information\n   */\n  miniNavItems?: TreeData<T>;\n\n  /**\n   * Boolean if the `mini` layout should be hidden. This should normally happen\n   * after the non-mini layout becomes visible.\n   */\n  miniHidden: boolean;\n\n  /**\n   * Any additional props to provide to the wrapping `<div>`.\n   */\n  containerProps?: PropsWithRef<HTMLAttributes<HTMLDivElement>, HTMLDivElement>;\n\n  /**\n   * The children to render. This should normally be the `LayoutMain` component.\n   */\n  children: ReactNode;\n}\n\n/**\n * This is probably an internal only component.\n *\n * @remarks \\@since 2.8.3\n */\nexport function MiniLayoutWrapper({\n  mini,\n  miniHidden,\n  miniNav,\n  miniNavItems,\n  treeProps,\n  header,\n  headerProps,\n  headerTitle,\n  headerTitleProps,\n  closeNav,\n  closeNavProps,\n  children,\n  containerProps,\n  ...props\n}: MiniLayoutWrapperProps): ReactElement {\n  const { fixedAppBar, isMiniable } = useLayoutConfig();\n  if ((!mini && !isMiniable) || !treeProps || typeof miniNav !== \"undefined\") {\n    return (\n      <>\n        {miniNav}\n        {children}\n      </>\n    );\n  }\n\n  let miniTreeProps = treeProps;\n  if (miniNavItems) {\n    miniTreeProps = {\n      ...miniTreeProps,\n      navItems: miniNavItems,\n    };\n  }\n\n  const miniNavigation = (\n    <LayoutNavigation\n      header={header}\n      headerProps={headerProps}\n      headerTitle={headerTitle}\n      headerTitleProps={headerTitleProps}\n      closeNav={closeNav}\n      closeNavProps={closeNavProps}\n      treeProps={miniTreeProps}\n      {...props}\n      mini\n      sticky={!fixedAppBar}\n      hidden={miniHidden}\n    />\n  );\n\n  if (fixedAppBar) {\n    return (\n      <>\n        {miniNavigation}\n        {children}\n      </>\n    );\n  }\n\n  return (\n    <div\n      {...containerProps}\n      className={cn(!miniHidden && mini && styles(), containerProps?.className)}\n    >\n      {mini && miniNavigation}\n      {children}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}