{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useCallback, useContext, useEffect, useMemo, useState } from \"react\";\nimport { useAppSize } from \"@react-md/utils\";\nimport { DEFAULT_DESKTOP_LAYOUT, DEFAULT_LANDSCAPE_TABLET_LAYOUT, DEFAULT_PHONE_LAYOUT, DEFAULT_TABLET_LAYOUT } from \"./constants\";\nimport { getLayoutType, isMiniLayout, isPersistentLayout, isToggleableLayout } from \"./utils\";\n/**\n * @internal\n */\nvar notInitialized = function (name) {\n  return function () {\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\") {\n      /* eslint-disable no-console */\n      console.warn(\"Uh oh, something went wrong. Somehow the `LayoutNavigationConfiguration` context has not been initialized. \" + \"This caused the \\\"\".concat(name, \"\\\" callback to do nothing.\"));\n    }\n  };\n};\nvar context = createContext({\n  baseId: \"layout\",\n  layout: \"temporary\",\n  visible: false,\n  showNav: notInitialized(\"showNav\"),\n  hideNav: notInitialized(\"hideNav\"),\n  fixedAppBar: true,\n  isMiniable: false\n});\n/**\n * Gets the current layout state and configuration.\n */\nexport function useLayoutConfig() {\n  return useContext(context);\n}\nvar Provider = context.Provider;\n/**\n * @remarks \\@since 2.6.0\n * @internal\n */\nfunction isToggleableVisible(behavior, layout) {\n  return typeof behavior === \"string\" ? behavior === layout : behavior && isToggleableLayout(layout);\n}\n/**\n * Determines the current layout based on the `LayoutConfiguration` and hooks\n * into the `AppSizeListener` to update on resize. This also initializes the\n * `LayLayoutContext` so that a custom layout implementation can be used along\n * with the `useLayoutConfig()` hook and the multiple `Layout` components.\n */\nexport function LayoutProvider(_a) {\n  var baseId = _a.baseId,\n    _b = _a.phoneLayout,\n    phoneLayout = _b === void 0 ? DEFAULT_PHONE_LAYOUT : _b,\n    _c = _a.tabletLayout,\n    tabletLayout = _c === void 0 ? DEFAULT_TABLET_LAYOUT : _c,\n    _d = _a.landscapeTabletLayout,\n    landscapeTabletLayout = _d === void 0 ? DEFAULT_LANDSCAPE_TABLET_LAYOUT : _d,\n    _e = _a.desktopLayout,\n    desktopLayout = _e === void 0 ? DEFAULT_DESKTOP_LAYOUT : _e,\n    largeDesktopLayout = _a.largeDesktopLayout,\n    _f = _a.defaultToggleableVisible,\n    defaultToggleableVisible = _f === void 0 ? false : _f,\n    _g = _a.fixedAppBar,\n    fixedAppBar = _g === void 0 ? true : _g,\n    children = _a.children;\n  var appSize = useAppSize();\n  var layout = getLayoutType({\n    appSize: appSize,\n    phoneLayout: phoneLayout,\n    tabletLayout: tabletLayout,\n    landscapeTabletLayout: landscapeTabletLayout,\n    desktopLayout: desktopLayout,\n    largeDesktopLayout: largeDesktopLayout\n  });\n  var isMiniable = [phoneLayout, tabletLayout, landscapeTabletLayout, desktopLayout, largeDesktopLayout].some(function (layout) {\n    return !!layout && isMiniLayout(layout);\n  });\n  var isDesktop = appSize.isDesktop;\n  var _h = __read(useState(isPersistentLayout(layout) && isDesktop || isToggleableVisible(defaultToggleableVisible, layout)), 2),\n    visible = _h[0],\n    setVisible = _h[1];\n  useEffect(function () {\n    setVisible(isPersistentLayout(layout) || isToggleableVisible(defaultToggleableVisible, layout));\n  }, [defaultToggleableVisible, layout]);\n  var showNav = useCallback(function () {\n    setVisible(true);\n  }, []);\n  var hideNav = useCallback(function () {\n    if (!isPersistentLayout(layout)) {\n      setVisible(false);\n    }\n  }, [layout]);\n  var value = useMemo(function () {\n    return {\n      baseId: baseId,\n      layout: layout,\n      visible: visible,\n      showNav: showNav,\n      hideNav: hideNav,\n      fixedAppBar: fixedAppBar,\n      isMiniable: isMiniable\n    };\n  }, [baseId, layout, visible, showNav, hideNav, fixedAppBar, isMiniable]);\n  return _jsx(Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"mappings":"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","names":["createContext","useCallback","useContext","useEffect","useMemo","useState","useAppSize","DEFAULT_DESKTOP_LAYOUT","DEFAULT_LANDSCAPE_TABLET_LAYOUT","DEFAULT_PHONE_LAYOUT","DEFAULT_TABLET_LAYOUT","getLayoutType","isMiniLayout","isPersistentLayout","isToggleableLayout","notInitialized","name","process","env","NODE_ENV","console","warn","context","baseId","layout","visible","showNav","hideNav","fixedAppBar","isMiniable","useLayoutConfig","isToggleableVisible","behavior","LayoutProvider","_a","_b","phoneLayout","_c","tabletLayout","_d","landscapeTabletLayout","_e","desktopLayout","largeDesktopLayout","_f","defaultToggleableVisible","_g","children","appSize","some","isDesktop","setVisible","value","_jsx","Provider"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/layout/src/LayoutProvider.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { useAppSize } from \"@react-md/utils\";\n\nimport {\n  DEFAULT_DESKTOP_LAYOUT,\n  DEFAULT_LANDSCAPE_TABLET_LAYOUT,\n  DEFAULT_PHONE_LAYOUT,\n  DEFAULT_TABLET_LAYOUT,\n} from \"./constants\";\nimport type { LayoutConfiguration, SupportedWideLayout } from \"./types\";\nimport {\n  getLayoutType,\n  isMiniLayout,\n  isPersistentLayout,\n  isToggleableLayout,\n} from \"./utils\";\n\n/**\n * @internal\n */\nconst notInitialized = (name: string) => (): void => {\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== \"production\") {\n    /* eslint-disable no-console */\n    console.warn(\n      \"Uh oh, something went wrong. Somehow the `LayoutNavigationConfiguration` context has not been initialized. \" +\n        `This caused the \"${name}\" callback to do nothing.`\n    );\n  }\n};\n\nexport interface LayoutContext {\n  /**\n   * The root `id` that was passed to the `Layout` component so that `id`s can\n   * be generated for child components.\n   */\n  baseId: string;\n\n  /**\n   * The current layout that is being used based on the app's size.\n   */\n  layout: SupportedWideLayout;\n\n  /**\n   * Boolean if the navigation panel is currently visible. This will always be\n   * `true` for persist layout types on desktop.\n   */\n  visible: boolean;\n\n  /**\n   * A function that will set the `visible` state to `true`.\n   */\n  showNav(): void;\n\n  /**\n   * A function that will set the `visible` state to `false`.\n   */\n  hideNav(): void;\n\n  /**\n   * Boolean if the layout is currently using a fixed app bar which can be\n   * useful for determining specific scroll or layout behavior.\n   *\n   * @remarks \\@since 2.8.3\n   */\n  fixedAppBar: boolean;\n\n  /**\n   * Boolean if one of the layout types are mini. This is mostly used internally\n   * to prevent the `<main>` element from unmounting (and losing state) for\n   * non-fixed app bar layouts.\n   *\n   * @remarks \\@since 2.9.1\n   */\n  isMiniable: boolean;\n}\n\nconst context = createContext<LayoutContext>({\n  baseId: \"layout\",\n  layout: \"temporary\",\n  visible: false,\n  showNav: notInitialized(\"showNav\"),\n  hideNav: notInitialized(\"hideNav\"),\n  fixedAppBar: true,\n  isMiniable: false,\n});\n\n/**\n * Gets the current layout state and configuration.\n */\nexport function useLayoutConfig(): LayoutContext {\n  return useContext(context);\n}\n\nconst { Provider } = context;\n\nexport interface LayoutProviderProps extends LayoutConfiguration {\n  /**\n   * The base id for the layout component. This is required since all the child\n   * components use this to generate their ids.\n   */\n  baseId: string;\n\n  /**\n   * The children to render that can inherit the current layout.\n   */\n  children: ReactNode;\n\n  /** {@inheritDoc LayoutContext.fixedAppBar} */\n  fixedAppBar?: boolean;\n}\n\n/**\n * @remarks \\@since 2.6.0\n * @internal\n */\nfunction isToggleableVisible(\n  behavior: boolean | \"toggleable\" | \"toggleable-mini\",\n  layout: SupportedWideLayout\n): boolean {\n  return typeof behavior === \"string\"\n    ? behavior === layout\n    : behavior && isToggleableLayout(layout);\n}\n\n/**\n * Determines the current layout based on the `LayoutConfiguration` and hooks\n * into the `AppSizeListener` to update on resize. This also initializes the\n * `LayLayoutContext` so that a custom layout implementation can be used along\n * with the `useLayoutConfig()` hook and the multiple `Layout` components.\n */\nexport function LayoutProvider({\n  baseId,\n  phoneLayout = DEFAULT_PHONE_LAYOUT,\n  tabletLayout = DEFAULT_TABLET_LAYOUT,\n  landscapeTabletLayout = DEFAULT_LANDSCAPE_TABLET_LAYOUT,\n  desktopLayout = DEFAULT_DESKTOP_LAYOUT,\n  largeDesktopLayout,\n  defaultToggleableVisible = false,\n  fixedAppBar = true,\n  children,\n}: LayoutProviderProps): ReactElement {\n  const appSize = useAppSize();\n  const layout = getLayoutType({\n    appSize,\n    phoneLayout,\n    tabletLayout,\n    landscapeTabletLayout,\n    desktopLayout,\n    largeDesktopLayout,\n  });\n  const isMiniable = [\n    phoneLayout,\n    tabletLayout,\n    landscapeTabletLayout,\n    desktopLayout,\n    largeDesktopLayout,\n  ].some((layout) => !!layout && isMiniLayout(layout));\n\n  const { isDesktop } = appSize;\n  const [visible, setVisible] = useState(\n    (isPersistentLayout(layout) && isDesktop) ||\n      isToggleableVisible(defaultToggleableVisible, layout)\n  );\n\n  useEffect(() => {\n    setVisible(\n      isPersistentLayout(layout) ||\n        isToggleableVisible(defaultToggleableVisible, layout)\n    );\n  }, [defaultToggleableVisible, layout]);\n\n  const showNav = useCallback(() => {\n    setVisible(true);\n  }, []);\n\n  const hideNav = useCallback(() => {\n    if (!isPersistentLayout(layout)) {\n      setVisible(false);\n    }\n  }, [layout]);\n\n  const value = useMemo<LayoutContext>(\n    () => ({\n      baseId,\n      layout,\n      visible,\n      showNav,\n      hideNav,\n      fixedAppBar,\n      isMiniable,\n    }),\n    [baseId, layout, visible, showNav, hideNav, fixedAppBar, isMiniable]\n  );\n\n  return <Provider value={value}>{children}</Provider>;\n}\n"]},"metadata":{},"sourceType":"module"}