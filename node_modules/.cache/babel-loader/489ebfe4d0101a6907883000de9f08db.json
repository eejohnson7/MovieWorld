{"ast":null,"code":"import { loop } from \"../loop\";\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var focusElement = function (element) {\n  element.focus();\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var isNotFocusable = function (element, includeDisabled) {\n  if (!element) {\n    return true;\n  }\n  if (includeDisabled) {\n    return false;\n  }\n  return element.getAttribute(\"disabled\") !== null || element.getAttribute(\"aria-disabled\") === \"true\";\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var getFirstFocusableIndex = function (watching, includeDisabled) {\n  if (!watching.length) {\n    return -1;\n  }\n  var firstIndex = 0;\n  while (firstIndex < watching.length - 1 && isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    firstIndex += 1;\n  }\n  if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    return -1;\n  }\n  return firstIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var getLastFocusableIndex = function (watching, includeDisabled) {\n  if (!watching.length) {\n    return -1;\n  }\n  var lastIndex = watching.length - 1;\n  while (lastIndex > 0 && isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    lastIndex -= 1;\n  }\n  if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    return -1;\n  }\n  return lastIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport var getNextFocusableIndex = function (_a) {\n  var loopable = _a.loopable,\n    watching = _a.watching,\n    increment = _a.increment,\n    includeDisabled = _a.includeDisabled,\n    currentFocusIndex = _a.currentFocusIndex;\n  var min = getFirstFocusableIndex(watching, includeDisabled);\n  var max = getLastFocusableIndex(watching, includeDisabled);\n  var nextIndex = loop({\n    min: min,\n    max: max,\n    value: currentFocusIndex,\n    minmax: !loopable,\n    increment: increment\n  });\n  while (isNotFocusable(watching[nextIndex].element, includeDisabled) && (loopable || nextIndex !== (increment ? max : min))) {\n    nextIndex = loop({\n      min: min,\n      max: max,\n      value: nextIndex,\n      minmax: !loopable,\n      increment: increment\n    });\n  }\n  // Since the `min` and `max` values are \"safely\" set, I don't need to verify\n  // the nextIndex is still focusable\n  return nextIndex;\n};\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport function getSearchText(element, searchable) {\n  if (!searchable) {\n    return \"\";\n  }\n  var cloned = element.cloneNode(true);\n  cloned.querySelectorAll(\".rmd-icon--font,[aria-hidden=true],[hidden]\").forEach(function (element) {\n    var _a;\n    (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n  });\n  // Note: It would be good to use `cloned.innerText` (maybe?) at some point,\n  // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe\n  // this is fine?\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext\n  return (cloned.textContent || \"\").substring(0, 1).toUpperCase();\n}","map":{"version":3,"mappings":"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","names":["loop","focusElement","element","focus","isNotFocusable","includeDisabled","getAttribute","getFirstFocusableIndex","watching","length","firstIndex","getLastFocusableIndex","lastIndex","getNextFocusableIndex","_a","loopable","increment","currentFocusIndex","min","max","nextIndex","value","minmax","getSearchText","searchable","cloned","cloneNode","querySelectorAll","forEach","parentNode","removeChild","textContent","substring","toUpperCase"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/keyboardMovement/utils.ts"],"sourcesContent":["import type { KeyboardFocusElementData } from \"./types\";\nimport { loop } from \"../loop\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const focusElement = (element: HTMLElement): void => {\n  element.focus();\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const isNotFocusable = (\n  element: HTMLElement | undefined,\n  includeDisabled: boolean\n): boolean => {\n  if (!element) {\n    return true;\n  }\n\n  if (includeDisabled) {\n    return false;\n  }\n\n  return (\n    element.getAttribute(\"disabled\") !== null ||\n    element.getAttribute(\"aria-disabled\") === \"true\"\n  );\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const getFirstFocusableIndex = (\n  watching: readonly KeyboardFocusElementData[],\n  includeDisabled: boolean\n): number => {\n  if (!watching.length) {\n    return -1;\n  }\n\n  let firstIndex = 0;\n  while (\n    firstIndex < watching.length - 1 &&\n    isNotFocusable(watching[firstIndex].element, includeDisabled)\n  ) {\n    firstIndex += 1;\n  }\n\n  if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return firstIndex;\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const getLastFocusableIndex = (\n  watching: readonly KeyboardFocusElementData[],\n  includeDisabled: boolean\n): number => {\n  if (!watching.length) {\n    return -1;\n  }\n\n  let lastIndex = watching.length - 1;\n  while (\n    lastIndex > 0 &&\n    isNotFocusable(watching[lastIndex].element, includeDisabled)\n  ) {\n    lastIndex -= 1;\n  }\n\n  if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {\n    return -1;\n  }\n\n  return lastIndex;\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\ninterface NextFocusableIndexOptions {\n  loopable: boolean;\n  watching: readonly KeyboardFocusElementData[];\n  increment: boolean;\n  includeDisabled: boolean;\n  currentFocusIndex: number;\n}\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const getNextFocusableIndex = ({\n  loopable,\n  watching,\n  increment,\n  includeDisabled,\n  currentFocusIndex,\n}: NextFocusableIndexOptions): number => {\n  const min = getFirstFocusableIndex(watching, includeDisabled);\n  const max = getLastFocusableIndex(watching, includeDisabled);\n  let nextIndex = loop({\n    min,\n    max,\n    value: currentFocusIndex,\n    minmax: !loopable,\n    increment,\n  });\n  while (\n    isNotFocusable(watching[nextIndex].element, includeDisabled) &&\n    (loopable || nextIndex !== (increment ? max : min))\n  ) {\n    nextIndex = loop({\n      min,\n      max,\n      value: nextIndex,\n      minmax: !loopable,\n      increment,\n    });\n  }\n\n  // Since the `min` and `max` values are \"safely\" set, I don't need to verify\n  // the nextIndex is still focusable\n  return nextIndex;\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport function getSearchText(\n  element: HTMLElement,\n  searchable: boolean\n): string {\n  if (!searchable) {\n    return \"\";\n  }\n\n  const cloned = element.cloneNode(true) as HTMLElement;\n  cloned\n    .querySelectorAll(\".rmd-icon--font,[aria-hidden=true],[hidden]\")\n    .forEach((element) => {\n      element.parentNode?.removeChild(element);\n    });\n\n  // Note: It would be good to use `cloned.innerText` (maybe?) at some point,\n  // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe\n  // this is fine?\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext\n  return (cloned.textContent || \"\").substring(0, 1).toUpperCase();\n}\n"]},"metadata":{},"sourceType":"module"}