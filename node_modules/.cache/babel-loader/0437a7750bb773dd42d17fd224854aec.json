{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { scrollIntoView } from \"../scrollIntoView\";\nimport { getFocusableElements } from \"./getFocusableElements\";\nimport { isFocusable } from \"./isFocusable\";\n/**\n * A function that is used to focus an element within the provided node.  This\n * can either focus the first, last, or a querySelector found element.\n *\n * @param container - Either an HTMLElement or the document to focus an element\n * within.\n * @param focus - Either the \"first\" or \"last\" string to focus the first or last\n * focusable element within the container or a query selector string to find a\n * focusable element within the container.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included as well.\n * @param preventScroll - Boolean if the focus event should not scroll the\n * element into view. This should normally remain `false`, but can be useful if\n * the element gets focused while offscreen during a transition.\n * @param elements - Optional child elements to search\n * @remarks \\@since 2.8.0 Supports focusing the container element if it is\n * focusable\n */\nexport function focusElementWithin(container, focus, programmatic, preventScroll, elements) {\n  var _a;\n  if (programmatic === void 0) {\n    programmatic = false;\n  }\n  if (preventScroll === void 0) {\n    preventScroll = false;\n  }\n  if (!elements || !elements.length) {\n    elements = getFocusableElements(container, programmatic);\n  }\n  var el;\n  switch (focus) {\n    case \"first\":\n      _a = __read(elements, 1), el = _a[0];\n      break;\n    case \"last\":\n      el = elements[elements.length - 1];\n      break;\n    default:\n      el = container.querySelector(focus);\n  }\n  // just allow any focusable-type element\n  if (!el && isFocusable(container, \"programmatic\")) {\n    el = container;\n  }\n  if (!el) {\n    throw new Error(\"Unable to find a focusable element\");\n  }\n  el.focus({\n    preventScroll: preventScroll\n  });\n  if (!preventScroll && container !== document) {\n    scrollIntoView(container, el);\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,cAAc,QAAQ,mBAAmB;AAClD,SAASC,oBAAoB,QAAQ,wBAAwB;AAC7D,SAASC,WAAW,QAAQ,eAAe;AAI3C;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,kBAAkB,CAChCC,SAAiC,EACjCC,KAAY,EACZC,YAAoB,EACpBC,aAAqB,EACrBC,QAAiC;;EAFjC;IAAAF,oBAAoB;EAAA;EACpB;IAAAC,qBAAqB;EAAA;EAGrB,IAAI,CAACC,QAAQ,IAAI,CAACA,QAAQ,CAACC,MAAM,EAAE;IACjCD,QAAQ,GAAGP,oBAAoB,CAACG,SAAS,EAAEE,YAAY,CAAC;;EAG1D,IAAII,EAAsB;EAC1B,QAAQL,KAAK;IACX,KAAK,OAAO;MACVM,YAAOH,QAAQ,MAAdE,EAAE;MACH;IACF,KAAK,MAAM;MACTA,EAAE,GAAGF,QAAQ,CAACA,QAAQ,CAACC,MAAM,GAAG,CAAC,CAAC;MAClC;IACF;MACEC,EAAE,GAAGN,SAAS,CAACQ,aAAa,CAAcP,KAAK,CAAC;EAAC;EAGrD;EACA,IAAI,CAACK,EAAE,IAAIR,WAAW,CAACE,SAAS,EAAE,cAAc,CAAC,EAAE;IACjDM,EAAE,GAAGN,SAAS;;EAGhB,IAAI,CAACM,EAAE,EAAE;IACP,MAAM,IAAIG,KAAK,CAAC,oCAAoC,CAAC;;EAGvDH,EAAE,CAACL,KAAK,CAAC;IAAEE,aAAa;EAAA,CAAE,CAAC;EAC3B,IAAI,CAACA,aAAa,IAAIH,SAAS,KAAKU,QAAQ,EAAE;IAC5Cd,cAAc,CAACI,SAAwB,EAAEM,EAAE,CAAC;;AAEhD","names":["scrollIntoView","getFocusableElements","isFocusable","focusElementWithin","container","focus","programmatic","preventScroll","elements","length","el","_a","querySelector","Error","document"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/wia-aria/focusElementWithin.ts"],"sourcesContent":["import { scrollIntoView } from \"../scrollIntoView\";\nimport { getFocusableElements } from \"./getFocusableElements\";\nimport { isFocusable } from \"./isFocusable\";\n\nexport type Focus = \"first\" | \"last\" | string;\n\n/**\n * A function that is used to focus an element within the provided node.  This\n * can either focus the first, last, or a querySelector found element.\n *\n * @param container - Either an HTMLElement or the document to focus an element\n * within.\n * @param focus - Either the \"first\" or \"last\" string to focus the first or last\n * focusable element within the container or a query selector string to find a\n * focusable element within the container.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included as well.\n * @param preventScroll - Boolean if the focus event should not scroll the\n * element into view. This should normally remain `false`, but can be useful if\n * the element gets focused while offscreen during a transition.\n * @param elements - Optional child elements to search\n * @remarks \\@since 2.8.0 Supports focusing the container element if it is\n * focusable\n */\nexport function focusElementWithin(\n  container: HTMLElement | Document,\n  focus: Focus,\n  programmatic = false,\n  preventScroll = false,\n  elements?: readonly HTMLElement[]\n): void {\n  if (!elements || !elements.length) {\n    elements = getFocusableElements(container, programmatic);\n  }\n\n  let el: HTMLElement | null;\n  switch (focus) {\n    case \"first\":\n      [el] = elements;\n      break;\n    case \"last\":\n      el = elements[elements.length - 1];\n      break;\n    default:\n      el = container.querySelector<HTMLElement>(focus);\n  }\n\n  // just allow any focusable-type element\n  if (!el && isFocusable(container, \"programmatic\")) {\n    el = container;\n  }\n\n  if (!el) {\n    throw new Error(\"Unable to find a focusable element\");\n  }\n\n  el.focus({ preventScroll });\n  if (!preventScroll && container !== document) {\n    scrollIntoView(container as HTMLElement, el);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}