{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useMemo } from \"react\";\nimport { getTreeItemId } from \"./getTreeItemId\";\nfunction flatten(_a) {\n  var list = _a.list,\n    item = _a.item,\n    index = _a.index,\n    baseId = _a.baseId,\n    parentIndexes = _a.parentIndexes,\n    valueKey = _a.valueKey,\n    getItemValue = _a.getItemValue;\n  if (item.isCustom) {\n    return list;\n  }\n  var id = getTreeItemId(baseId, index, parentIndexes);\n  var value = getItemValue(item, valueKey);\n  var itemId = item.itemId,\n    parentId = item.parentId,\n    childItems = item.childItems;\n  list.push({\n    id: id,\n    itemId: itemId,\n    parentId: parentId,\n    isParent: !!childItems,\n    value: value\n  });\n  if (!childItems) {\n    return list;\n  }\n  var nextIndexes = __spreadArray(__spreadArray([], __read(parentIndexes), false), [index + 1], false);\n  childItems.forEach(function (child, childIndex) {\n    flatten({\n      list: list,\n      item: child,\n      index: childIndex,\n      valueKey: valueKey,\n      getItemValue: getItemValue,\n      baseId: baseId,\n      parentIndexes: nextIndexes\n    });\n  });\n  return list;\n}\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @internal\n */\nexport function useFlattenedTreeList(_a) {\n  var id = _a.id,\n    items = _a.items,\n    rootId = _a.rootId,\n    expandedIds = _a.expandedIds,\n    valueKey = _a.valueKey,\n    getItemValue = _a.getItemValue;\n  var flattenedItems = useMemo(function () {\n    return items.reduce(function (list, item, index) {\n      return flatten({\n        list: list,\n        item: item,\n        index: index,\n        valueKey: valueKey,\n        getItemValue: getItemValue,\n        baseId: id,\n        parentIndexes: []\n      });\n    }, []);\n  }, [getItemValue, id, items, valueKey]);\n  var _b = useMemo(function () {\n      var index = 0;\n      return flattenedItems.reduce(function (collection, item) {\n        var _a, _b;\n        var parentId = item.parentId,\n          itemId = item.itemId;\n        var isVisible = parentId === rootId;\n        if (parentId !== null && expandedIds.includes(parentId)) {\n          // need to also make sure that the parent is visible\n          isVisible = ((_b = (_a = collection.itemRefs[parentId]) === null || _a === void 0 ? void 0 : _a.visibleIndex) !== null && _b !== void 0 ? _b : -1) !== -1;\n        }\n        collection.itemRefs[itemId] = {\n          id: item.id,\n          ref: {\n            current: null\n          },\n          visibleIndex: isVisible ? index : -1\n        };\n        if (isVisible) {\n          index += 1;\n          collection.visibleItems.push(item);\n        }\n        return collection;\n      }, {\n        visibleItems: [],\n        itemRefs: {}\n      });\n    }, [expandedIds, flattenedItems, rootId]),\n    visibleItems = _b.visibleItems,\n    itemRefs = _b.itemRefs;\n  return [visibleItems, itemRefs, flattenedItems];\n}","map":{"version":3,"mappings":"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","names":["useMemo","getTreeItemId","flatten","_a","list","item","index","baseId","parentIndexes","valueKey","getItemValue","isCustom","id","value","parentId","childItems","push","itemId","isParent","nextIndexes","forEach","child","childIndex","useFlattenedTreeList","items","rootId","expandedIds","flattenedItems","reduce","collection","isVisible","includes","itemRefs","visibleIndex","ref","current","visibleItems"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/tree/src/useFlattenedTreeList.ts"],"sourcesContent":["import type { MutableRefObject } from \"react\";\nimport { useMemo } from \"react\";\n\nimport { getTreeItemId } from \"./getTreeItemId\";\nimport type {\n  ExpandedIds,\n  TreeItemId,\n  TreeProps,\n  UnknownTreeItem,\n} from \"./types\";\nimport type { NestedTreeItem } from \"./useNestedTreeList\";\n\nexport interface SearchableTreeItem {\n  /**\n   * A DOM Node `id` to use.\n   */\n  id: string;\n\n  /**\n   * A searchable value for the tree item.\n   */\n  value: string;\n\n  isParent: boolean;\n  itemId: TreeItemId;\n  parentId: TreeItemId | null;\n}\n\ntype TreeConfig = Required<\n  Pick<TreeProps<UnknownTreeItem>, \"valueKey\" | \"getItemValue\">\n>;\n\ninterface FlattenOptions extends TreeConfig {\n  list: SearchableTreeItem[];\n  item: NestedTreeItem<UnknownTreeItem>;\n  index: number;\n  baseId: string;\n  parentIndexes: number[];\n}\n\nfunction flatten({\n  list,\n  item,\n  index,\n  baseId,\n  parentIndexes,\n  valueKey,\n  getItemValue,\n}: FlattenOptions): SearchableTreeItem[] {\n  if (item.isCustom) {\n    return list;\n  }\n\n  const id = getTreeItemId(baseId, index, parentIndexes);\n  const value = getItemValue(item, valueKey);\n  const { itemId, parentId, childItems } = item;\n  list.push({\n    id,\n    itemId,\n    parentId,\n    isParent: !!childItems,\n    value,\n  });\n\n  if (!childItems) {\n    return list;\n  }\n\n  const nextIndexes = [...parentIndexes, index + 1];\n  childItems.forEach((child, childIndex) => {\n    flatten({\n      list,\n      item: child,\n      index: childIndex,\n      valueKey,\n      getItemValue,\n      baseId,\n      parentIndexes: nextIndexes,\n    });\n  });\n\n  return list;\n}\n\ninterface Options extends TreeConfig {\n  id: string;\n  items: readonly NestedTreeItem<UnknownTreeItem>[];\n  expandedIds: ExpandedIds;\n  rootId: TreeItemId | null;\n}\n\nexport type TreeItemRef = MutableRefObject<HTMLLIElement | null>;\nexport interface ItemMetadata {\n  id: string;\n  ref: TreeItemRef;\n  visibleIndex: number;\n}\n\nexport type MetadataRecord = Record<TreeItemId, ItemMetadata>;\n\ninterface ItemCollection {\n  itemRefs: MetadataRecord;\n  visibleItems: SearchableTreeItem[];\n}\n\ntype ReturnValue = [SearchableTreeItem[], MetadataRecord, SearchableTreeItem[]];\n\n/**\n * Creates a flattened and ordered list of all the tree items that are current visible\n * in the DOM based on the expanded ids. This is only required for handling keyboard\n * navigation with `aria-activedescendant` movement so the items can be \"focused\" with\n * typeahead and keyboard movement since the keyboard movement API requires DOM refs\n * to be passed to each element.\n *\n * This flattened list will remove the `childItems` (if it existed) on each item for\n * simplicity and the child items aren't needed for this flattened list.\n *\n * @internal\n */\nexport function useFlattenedTreeList({\n  id,\n  items,\n  rootId,\n  expandedIds,\n  valueKey,\n  getItemValue,\n}: Options): ReturnValue {\n  const flattenedItems = useMemo(\n    () =>\n      items.reduce<SearchableTreeItem[]>(\n        (list, item, index) =>\n          flatten({\n            list,\n            item,\n            index,\n            valueKey,\n            getItemValue,\n            baseId: id,\n            parentIndexes: [],\n          }),\n        []\n      ),\n    [getItemValue, id, items, valueKey]\n  );\n\n  const { visibleItems, itemRefs } = useMemo(() => {\n    let index = 0;\n    return flattenedItems.reduce<ItemCollection>(\n      (collection, item) => {\n        const { parentId, itemId } = item;\n        let isVisible = parentId === rootId;\n        if (parentId !== null && expandedIds.includes(parentId)) {\n          // need to also make sure that the parent is visible\n          isVisible =\n            (collection.itemRefs[parentId]?.visibleIndex ?? -1) !== -1;\n        }\n\n        collection.itemRefs[itemId] = {\n          id: item.id,\n          ref: { current: null },\n          visibleIndex: isVisible ? index : -1,\n        };\n        if (isVisible) {\n          index += 1;\n          collection.visibleItems.push(item);\n        }\n        return collection;\n      },\n      { visibleItems: [], itemRefs: {} }\n    );\n  }, [expandedIds, flattenedItems, rootId]);\n\n  return [visibleItems, itemRefs, flattenedItems];\n}\n"]},"metadata":{},"sourceType":"module"}