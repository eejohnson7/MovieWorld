{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useEffect, useState } from \"react\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\n/**\n * This hook allows for custom keyboard focus movement using DOM focus behavior\n * by actually focusing each DOM node.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have a correct `role` applied as well as the `onKeyDown` event\n * handler provided by this hook. Then, you'll want to applied a\n * `ref={itemRefs[i]}` for each item within the items list so that the DOM nodes\n * can be focused as needed. Unfortunately, this means that all the child items\n * **must** either be an HTMLElement or the ref is forwarded down to the\n * HTMLElement.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useFocusMovement(_a) {\n  var _b = _a.defaultFocusedIndex,\n    defaultFocusedIndex = _b === void 0 ? -1 : _b,\n    onChange = _a.onChange,\n    options = __rest(_a, [\"defaultFocusedIndex\", \"onChange\"]);\n  var _c = __read(useState(defaultFocusedIndex), 2),\n    focusedIndex = _c[0],\n    setFocusedIndex = _c[1];\n  var _d = __read(useKeyboardMovement(__assign(__assign({}, options), {\n      focusedIndex: focusedIndex,\n      onChange: function (data, itemRefs) {\n        if (onChange) {\n          onChange(data, itemRefs);\n        }\n        var index = data.index;\n        if (index === -1) {\n          return;\n        }\n        var item = itemRefs[index] && itemRefs[index].current;\n        if (item) {\n          item.focus();\n        }\n        setFocusedIndex(index);\n      }\n    })), 2),\n    itemRefs = _d[0],\n    handleKeyDown = _d[1];\n  useEffect(function () {\n    if (defaultFocusedIndex === -1) {\n      return;\n    }\n    var item = itemRefs[defaultFocusedIndex] && itemRefs[defaultFocusedIndex].current;\n    if (item) {\n      item.focus();\n    }\n    // only want to trigger on mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return [itemRefs, handleKeyDown];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAM3C,SAASC,mBAAmB,QAAQ,uBAAuB;AAa3D;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,gBAAgB,CAI9BC,EAIgC;EAHhC,+BAAwB;IAAxBC,mBAAmB,mBAAG,CAAC,CAAC;IACxBC,QAAQ;IACLC,OAAO,cAHV,mCAID,CADW;EAEJ,gBAAkCN,QAAQ,CAACI,mBAAmB,CAAC;IAA9DG,YAAY;IAAEC,eAAe,QAAiC;EAC/D,gBAA4BP,mBAAmB,uBAChDK,OAAO;MACVC,YAAY;MACZF,QAAQ,YAACI,IAAI,EAAEC,QAAQ;QACrB,IAAIL,QAAQ,EAAE;UACZA,QAAQ,CAACI,IAAI,EAAEC,QAAQ,CAAC;;QAGlB,SAAK,GAAKD,IAAI,MAAT;QACb,IAAIE,KAAK,KAAK,CAAC,CAAC,EAAE;UAChB;;QAGF,IAAMC,IAAI,GAAGF,QAAQ,CAACC,KAAK,CAAC,IAAID,QAAQ,CAACC,KAAK,CAAC,CAACE,OAAO;QACvD,IAAID,IAAI,EAAE;UACRA,IAAI,CAACE,KAAK,EAAE;;QAGdN,eAAe,CAACG,KAAK,CAAC;MACxB;IAAC,GACD;IApBKD,QAAQ;IAAEK,aAAa,QAoB5B;EAEFhB,SAAS,CAAC;IACR,IAAIK,mBAAmB,KAAK,CAAC,CAAC,EAAE;MAC9B;;IAGF,IAAMQ,IAAI,GACRF,QAAQ,CAACN,mBAAmB,CAAC,IAAIM,QAAQ,CAACN,mBAAmB,CAAC,CAACS,OAAO;IACxE,IAAID,IAAI,EAAE;MACRA,IAAI,CAACE,KAAK,EAAE;;IAGd;IACA;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO,CAACJ,QAAQ,EAAEK,aAAa,CAAC;AAClC","names":["useEffect","useState","useKeyboardMovement","useFocusMovement","_a","defaultFocusedIndex","onChange","options","focusedIndex","setFocusedIndex","data","itemRefs","index","item","current","focus","handleKeyDown"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/wia-aria/movement/useFocusMovement.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\nimport type {\n  BaseKeyboardMovementOptions,\n  KeyboardMovementProviders,\n} from \"./useKeyboardMovement\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\n\ninterface KeyboardFocusOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends BaseKeyboardMovementOptions<D, CE, IE> {\n  /**\n   * The index that should be focused by default.\n   */\n  defaultFocusedIndex?: number;\n}\n\n/**\n * This hook allows for custom keyboard focus movement using DOM focus behavior\n * by actually focusing each DOM node.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have a correct `role` applied as well as the `onKeyDown` event\n * handler provided by this hook. Then, you'll want to applied a\n * `ref={itemRefs[i]}` for each item within the items list so that the DOM nodes\n * can be focused as needed. Unfortunately, this means that all the child items\n * **must** either be an HTMLElement or the ref is forwarded down to the\n * HTMLElement.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useFocusMovement<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n>({\n  defaultFocusedIndex = -1,\n  onChange,\n  ...options\n}: KeyboardFocusOptions<D, CE, IE>): KeyboardMovementProviders<CE, IE> {\n  const [focusedIndex, setFocusedIndex] = useState(defaultFocusedIndex);\n  const [itemRefs, handleKeyDown] = useKeyboardMovement<D, CE, IE>({\n    ...options,\n    focusedIndex,\n    onChange(data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      const { index } = data;\n      if (index === -1) {\n        return;\n      }\n\n      const item = itemRefs[index] && itemRefs[index].current;\n      if (item) {\n        item.focus();\n      }\n\n      setFocusedIndex(index);\n    },\n  });\n\n  useEffect(() => {\n    if (defaultFocusedIndex === -1) {\n      return;\n    }\n\n    const item =\n      itemRefs[defaultFocusedIndex] && itemRefs[defaultFocusedIndex].current;\n    if (item) {\n      item.focus();\n    }\n\n    // only want to trigger on mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return [itemRefs, handleKeyDown];\n}\n"]},"metadata":{},"sourceType":"module"}