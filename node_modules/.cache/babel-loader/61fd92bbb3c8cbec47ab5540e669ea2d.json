{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useEffect, useRef } from \"react\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport { containsElement, useIsUserInteractionMode, useScrollLock } from \"@react-md/utils\";\nimport { useMenuBarContext } from \"./MenuBarProvider\";\nimport { getDefaultAnchor, noop } from \"./utils\";\n/**\n * This hook provides all the functionality for a menu to:\n * - toggle the `Menu`'s visibility when the `MenuButton` or `MenuItemButton`\n *   has been clicked\n * - hide the `Menu` when an element outside of the `Menu` has been clicked\n * - hide the `Menu` when the `Escape` or `Tab` key has been pressed\n * - focus the `Menu` element when it gains visibility\n * - refocus the `MenuButton` or `MenuItemButton` when the menu loses visibility\n * - position the menu within the viewport with {@link useFixedPositioning}\n * - show the `Menu` when the `ArrowRight` key is pressed for a vertical\n *   `MenuItemButton`\n * - show the `Menu` when the `ArrowDown` key is pressed for a horizontal\n *   `MenuItemButton`\n * - hide the `Menu` when the `ArrowRight` key is pressed in a vertical submenu\n * - hide the `Menu` when the `ArrowDown` key is pressed in a horizontal\n *   submenu\n * - conditionally hide the `Menu` if the page is scrolled while the `Menu` is\n *   visible\n * - conditionally hide the `Menu` if the page is resized while the `Menu` is\n *   visible\n * - conditionally move focus to the next `DropdownMenu` with keyboard movement\n *   when inside of a `MenuBar`\n * - conditionally enable the visibility for a `DropdownMenu` when the mouse\n *   hovers over a `MenuItemButton` with a parent `MenuBar` that has been\n *   activated\n * - conditionally show/hide the `Menu` based on a parent `MenuBar`'s `activeId`\n *\n * This hook will probably never need to be used externally since it has been\n * integrated into the `DropdownMenu` component and `useContextMenu` hook.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useState } from \"react\";\n * import { useMenu, Menu, MenuButton, MenuItem } from \"@react-md/menu\";\n *\n * function Example(): ReactElement {\n *   const [visible, setVisible] = useState(false);\n *   const { menuRef, menuProps, toggleRef, toggleProps } = useMenu<\n *     HTMLButtonElement\n *   >({\n *     baseId: \"custom-menu-button\",\n *     visible,\n *     setVisible,\n *   });\n *\n *   return (\n *     <>\n *       <MenuButton ref={toggleRef} {...toggleProps}>\n *         Button\n *       </MenuButton>\n *       <Menu ref={menuRef} {...menuProps}>\n *         <MenuItem>Item 1</MenuItem>\n *         <MenuItem>Item 2</MenuItem>\n *         <MenuItem>Item 3</MenuItem>\n *       </Menu>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 5.0.0\n */\nexport function useMenu(options) {\n  var baseId = options.baseId,\n    _a = options.disabled,\n    disabled = _a === void 0 ? false : _a,\n    propStyle = options.style,\n    menuLabel = options.menuLabel,\n    visible = options.visible,\n    setVisible = options.setVisible,\n    _b = options.floating,\n    floating = _b === void 0 ? null : _b,\n    _c = options.onMenuClick,\n    onMenuClick = _c === void 0 ? noop : _c,\n    _d = options.onMenuKeyDown,\n    onMenuKeyDown = _d === void 0 ? noop : _d,\n    _e = options.onToggleClick,\n    onToggleClick = _e === void 0 ? noop : _e,\n    _f = options.onToggleKeyDown,\n    onToggleKeyDown = _f === void 0 ? noop : _f,\n    _g = options.onToggleMouseEnter,\n    onToggleMouseEnter = _g === void 0 ? noop : _g,\n    _h = options.onToggleMouseLeave,\n    onToggleMouseLeave = _h === void 0 ? noop : _h,\n    _j = options.menuitem,\n    menuitem = _j === void 0 ? false : _j,\n    _k = options.horizontal,\n    horizontal = _k === void 0 ? false : _k,\n    propAnchor = options.anchor,\n    fixedPositionOptions = options.fixedPositionOptions,\n    getFixedPositionOptions = options.getFixedPositionOptions,\n    _l = options.closeOnResize,\n    closeOnResize = _l === void 0 ? false : _l,\n    _m = options.closeOnScroll,\n    closeOnScroll = _m === void 0 ? false : _m,\n    onEnter = options.onEnter,\n    onEntering = options.onEntering,\n    _o = options.onEntered,\n    onEntered = _o === void 0 ? noop : _o,\n    _p = options.onExited,\n    onExited = _p === void 0 ? noop : _p,\n    _q = options.onFixedPositionScroll,\n    onFixedPositionScroll = _q === void 0 ? noop : _q,\n    _r = options.onFixedPositionResize,\n    onFixedPositionResize = _r === void 0 ? noop : _r,\n    _s = options.preventScroll,\n    preventScroll = _s === void 0 ? false : _s,\n    _t = options.disableFocusOnMount,\n    disableFocusOnMount = _t === void 0 ? false : _t,\n    _u = options.disableFocusOnUnmount,\n    disableFocusOnUnmount = _u === void 0 ? false : _u;\n  var _v = useMenuBarContext(),\n    root = _v.root,\n    menubar = _v.menubar,\n    activeId = _v.activeId,\n    setActiveId = _v.setActiveId,\n    hoverTimeout = _v.hoverTimeout,\n    setAnimatedOnce = _v.setAnimatedOnce;\n  var touch = useIsUserInteractionMode(\"touch\");\n  var timeout = useRef();\n  useEffect(function () {\n    return function () {\n      window.clearTimeout(timeout.current);\n    };\n  }, []);\n  // if the menu hides because the user scrolls the page or the page is resized,\n  // the focus toggle behavior should be disabled since the user is no longer\n  // interacting with the menu\n  var cancelExitFocus = useRef(false);\n  var anchor = propAnchor !== null && propAnchor !== void 0 ? propAnchor : getDefaultAnchor({\n    menubar: menubar,\n    menuitem: menuitem,\n    floating: floating,\n    horizontal: horizontal\n  });\n  var menuNodeRef = useRef(null);\n  var toggleRef = useRef(null);\n  var _w = useFixedPositioning(__assign(__assign({\n      nodeRef: menuNodeRef,\n      style: propStyle,\n      fixedTo: toggleRef,\n      onEnter: onEnter,\n      onEntering: onEntering,\n      onEntered: function (appearing) {\n        var _a;\n        cancelExitFocus.current = false;\n        onEntered(appearing);\n        setAnimatedOnce(true);\n        if (!disableFocusOnMount) {\n          (_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n      },\n      onExited: function () {\n        var _a;\n        onExited();\n        // this has to be done onExited or else the toggle component will be\n        // clicked if the user pressed the \"Enter\" key which makes it look like\n        // the menu never closes.\n        if (!disableFocusOnUnmount && !cancelExitFocus.current) {\n          (_a = toggleRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n      },\n      anchor: anchor,\n      transformOrigin: true\n    }, fixedPositionOptions), {\n      getFixedPositionOptions: getFixedPositionOptions,\n      onScroll: function (event, data) {\n        onFixedPositionScroll(event, data);\n        if (!data.visible || closeOnScroll) {\n          cancelExitFocus.current = true;\n          setVisible(false);\n        }\n      },\n      onResize: function (event) {\n        onFixedPositionResize(event);\n        if (closeOnResize) {\n          cancelExitFocus.current = true;\n          setVisible(false);\n        }\n      }\n    })),\n    style = _w.style,\n    _x = _w.transitionOptions,\n    nodeRef = _x.nodeRef,\n    transitionOptions = __rest(_x, [\"nodeRef\"]);\n  useScrollLock(preventScroll && visible);\n  useEffect(function () {\n    if (!visible) {\n      return;\n    }\n    var handler = function (_a) {\n      var _b, _c;\n      var target = _a.target;\n      if (!(target instanceof Element) || !((_b = menuNodeRef.current) === null || _b === void 0 ? void 0 : _b.contains(target)) && !((_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.contains(target))) {\n        setVisible(false);\n      }\n    };\n    window.addEventListener(\"click\", handler);\n    return function () {\n      window.removeEventListener(\"click\", handler);\n    };\n  }, [menuNodeRef, setVisible, toggleRef, visible]);\n  useEffect(function () {\n    var _a;\n    if (visible) {\n      return;\n    }\n    // this is to fix keyboard movement behavior when navigating between\n    // different root-level menuitems with the `ArrowLeft` and `ArrowRight` keys\n    // while menus are visible. If the exit focus behavior is not cancelled, the\n    // next menu's menu will be visible, but the current menu's menuitem would\n    // be the current focus which breaks everything\n    cancelExitFocus.current = cancelExitFocus.current || !((_a = menuNodeRef.current) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement));\n    setActiveId(function (prevActiveId) {\n      return baseId === prevActiveId ? \"\" : prevActiveId;\n    });\n  }, [baseId, root, setActiveId, visible]);\n  useEffect(function () {\n    setVisible(baseId === activeId);\n  }, [activeId, baseId, root, setVisible]);\n  return {\n    menuRef: nodeRef,\n    menuProps: __assign(__assign({\n      // typecast to string so that it passes the RequireAtLeastOne<LabelA11y>\n      // TS won't pass otherwise\n      \"aria-label\": menuLabel,\n      \"aria-labelledby\": menuLabel ? undefined : baseId,\n      id: \"\".concat(baseId, \"-menu\"),\n      style: style\n    }, transitionOptions), {\n      visible: visible,\n      onClick: function (event) {\n        onMenuClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        // this makes it so you can click on the menu/list without closing the\n        // menu\n        if (event.currentTarget === event.target) {\n          return;\n        }\n        // This might be a test only workaround since clicking links move focus\n        // somewhere else\n        if (event.target instanceof HTMLElement) {\n          cancelExitFocus.current = containsElement(event.currentTarget, event.target.closest(\"a\"));\n        }\n        setVisible(false);\n      },\n      onKeyDown: function (event) {\n        onMenuKeyDown(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        switch (event.key) {\n          case \"Escape\":\n            // prevent parent components that have an \"Escape\" keypress event\n            // from being triggered as well\n            event.stopPropagation();\n            setVisible(false);\n            break;\n          case \"Tab\":\n            // since menus are portalled, tab index is kinda broke so just close\n            // the menu instead of doing default tab behavior\n            event.preventDefault();\n            if (!menuitem) {\n              // pressing the tab key should still cascade close all menus\n              event.stopPropagation();\n            }\n            setVisible(false);\n            break;\n          case \"ArrowUp\":\n            if (menuitem && horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n          case \"ArrowLeft\":\n            if (menuitem && !horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n        }\n      }\n    }),\n    menuNodeRef: menuNodeRef,\n    toggleRef: toggleRef,\n    toggleProps: {\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": visible || undefined,\n      id: baseId,\n      onClick: function (event) {\n        onToggleClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n        if (menuitem || menubar) {\n          // do not allow the default menu close behavior from\n          // triggering for parent menus\n          event.stopPropagation();\n        }\n        setVisible(function (prevVisible) {\n          return !prevVisible;\n        });\n        setActiveId(function (prevActiveId) {\n          return baseId === prevActiveId ? \"\" : baseId;\n        });\n      },\n      onKeyDown: function (event) {\n        onToggleKeyDown(event);\n        if (event.isPropagationStopped() || disabled) {\n          return;\n        }\n        if (menubar && !menuitem && event.key === \"ArrowDown\") {\n          event.preventDefault();\n          event.stopPropagation();\n          setActiveId(baseId);\n          return;\n        }\n        if (!menuitem) {\n          return;\n        }\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n          case \"ArrowRight\":\n            if (!horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n        }\n      },\n      onMouseEnter: function (event) {\n        onToggleMouseEnter(event);\n        if (event.isPropagationStopped() || disabled || !menubar || !activeId || touch) {\n          if (typeof hoverTimeout === \"number\") {\n            timeout.current = window.setTimeout(function () {\n              setActiveId(baseId);\n            }, hoverTimeout);\n          }\n          return;\n        }\n        setActiveId(baseId);\n      },\n      onMouseLeave: function (event) {\n        onToggleMouseLeave(event);\n        window.clearTimeout(timeout.current);\n      }\n    }\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;AAKA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAEzC,SAASC,mBAAmB,QAAQ,sBAAsB;AAC1D,SACEC,eAAe,EACfC,wBAAwB,EACxBC,aAAa,QACR,iBAAiB;AAExB,SAASC,iBAAiB,QAAQ,mBAAmB;AAMrD,SAASC,gBAAgB,EAAEC,IAAI,QAAQ,SAAS;AAkFhD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+DA,OAAM,SAAUC,OAAO,CACrBC,OAAkC;EAGhC,UAAM,GA6BJA,OAAO,OA7BH;IACNC,KA4BED,OAAO,SA5BO;IAAhBE,QAAQ,mBAAG,KAAK;IACTC,SAAS,GA2BdH,OAAO,MA3BO;IAChBI,SAAS,GA0BPJ,OAAO,UA1BA;IACTK,OAAO,GAyBLL,OAAO,QAzBF;IACPM,UAAU,GAwBRN,OAAO,WAxBC;IACVO,KAuBEP,OAAO,SAvBM;IAAfQ,QAAQ,mBAAG,IAAI;IACfC,KAsBET,OAAO,YAtBS;IAAlBU,WAAW,mBAAGZ,IAAI;IAClBa,KAqBEX,OAAO,cArBW;IAApBY,aAAa,mBAAGd,IAAI;IACpBe,KAoBEb,OAAO,cApBW;IAApBc,aAAa,mBAAGhB,IAAI;IACpBiB,KAmBEf,OAAO,gBAnBa;IAAtBgB,eAAe,mBAAGlB,IAAI;IACtBmB,KAkBEjB,OAAO,mBAlBgB;IAAzBkB,kBAAkB,mBAAGpB,IAAI;IACzBqB,KAiBEnB,OAAO,mBAjBgB;IAAzBoB,kBAAkB,mBAAGtB,IAAI;IACzBuB,KAgBErB,OAAO,SAhBO;IAAhBsB,QAAQ,mBAAG,KAAK;IAChBC,KAeEvB,OAAO,WAfS;IAAlBwB,UAAU,mBAAG,KAAK;IACVC,UAAU,GAchBzB,OAAO,OAdS;IAClB0B,oBAAoB,GAalB1B,OAAO,qBAbW;IACpB2B,uBAAuB,GAYrB3B,OAAO,wBAZc;IACvB4B,KAWE5B,OAAO,cAXY;IAArB6B,aAAa,mBAAG,KAAK;IACrBC,KAUE9B,OAAO,cAVY;IAArB+B,aAAa,mBAAG,KAAK;IACrBC,OAAO,GASLhC,OAAO,QATF;IACPiC,UAAU,GAQRjC,OAAO,WARC;IACVkC,KAOElC,OAAO,UAPO;IAAhBmC,SAAS,mBAAGrC,IAAI;IAChBsC,KAMEpC,OAAO,SANM;IAAfqC,QAAQ,mBAAGvC,IAAI;IACfwC,KAKEtC,OAAO,sBALmB;IAA5BuC,qBAAqB,mBAAGzC,IAAI;IAC5B0C,KAIExC,OAAO,sBAJmB;IAA5ByC,qBAAqB,mBAAG3C,IAAI;IAC5B4C,KAGE1C,OAAO,cAHY;IAArB2C,aAAa,mBAAG,KAAK;IACrBC,KAEE5C,OAAO,oBAFkB;IAA3B6C,mBAAmB,mBAAG,KAAK;IAC3BC,KACE9C,OAAO,sBADoB;IAA7B+C,qBAAqB,mBAAG,KAAK;EAEzB,SAOFnD,iBAAiB,EAAE;IANrBoD,IAAI;IACJC,OAAO;IACPC,QAAQ;IACRC,WAAW;IACXC,YAAY;IACZC,eAAe,qBACM;EACvB,IAAMC,KAAK,GAAG5D,wBAAwB,CAAC,OAAO,CAAC;EAE/C,IAAM6D,OAAO,GAAGhE,MAAM,EAAsB;EAC5CD,SAAS,CAAC;IACR,OAAO;MACLkE,MAAM,CAACC,YAAY,CAACF,OAAO,CAACG,OAAO,CAAC;IACtC,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN;EACA;EACA;EACA,IAAMC,eAAe,GAAGpE,MAAM,CAAC,KAAK,CAAC;EACrC,IAAMqE,MAAM,GACVnC,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI5B,gBAAgB,CAAC;IAAEoD,OAAO;IAAE3B,QAAQ;IAAEd,QAAQ;IAAEgB,UAAU;EAAA,CAAE,CAAC;EAC7E,IAAMqC,WAAW,GAAGtE,MAAM,CAAiB,IAAI,CAAC;EAChD,IAAMuE,SAAS,GAAGvE,MAAM,CAAkB,IAAI,CAAC;EAC/C,IAAMwE,KAGFvE,mBAAmB;MACrBwE,OAAO,EAAEH,WAAW;MACpBI,KAAK,EAAE9D,SAAS;MAChB+D,OAAO,EAAEJ,SAAS;MAClB9B,OAAO;MACPC,UAAU;MACVE,SAAS,YAACgC,SAAS;;QACjBR,eAAe,CAACD,OAAO,GAAG,KAAK;QAC/BvB,SAAS,CAACgC,SAAS,CAAC;QACpBd,eAAe,CAAC,IAAI,CAAC;QACrB,IAAI,CAACR,mBAAmB,EAAE;UACxB,iBAAW,CAACa,OAAO,0CAAEU,KAAK,EAAE;;MAEhC,CAAC;MACD/B,QAAQ;;QACNA,QAAQ,EAAE;QAEV;QACA;QACA;QACA,IAAI,CAACU,qBAAqB,IAAI,CAACY,eAAe,CAACD,OAAO,EAAE;UACtD,eAAS,CAACA,OAAO,0CAAEU,KAAK,EAAE;;MAE9B,CAAC;MACDR,MAAM;MACNS,eAAe,EAAE;IAAI,GAClB3C,oBAAoB;MACvBC,uBAAuB;MACvB2C,QAAQ,YAACC,KAAK,EAAEC,IAAI;QAClBjC,qBAAqB,CAACgC,KAAK,EAAEC,IAAI,CAAC;QAClC,IAAI,CAACA,IAAI,CAACnE,OAAO,IAAI0B,aAAa,EAAE;UAClC4B,eAAe,CAACD,OAAO,GAAG,IAAI;UAC9BpD,UAAU,CAAC,KAAK,CAAC;;MAErB,CAAC;MACDmE,QAAQ,YAACF,KAAK;QACZ9B,qBAAqB,CAAC8B,KAAK,CAAC;QAC5B,IAAI1C,aAAa,EAAE;UACjB8B,eAAe,CAACD,OAAO,GAAG,IAAI;UAC9BpD,UAAU,CAAC,KAAK,CAAC;;MAErB;IAAC,GACD;IA5CA2D,KAAK;IACLS,yBAAoD;IAA/BV,OAAO;IAAKW,iBAAiB,cAA/B,WAAiC,CA2CpD;EACFhF,aAAa,CAACgD,aAAa,IAAItC,OAAO,CAAC;EAEvCf,SAAS,CAAC;IACR,IAAI,CAACe,OAAO,EAAE;MACZ;;IAGF,IAAMuE,OAAO,GAAG,UAAC3E,EAAsB;;UAApB4E,MAAM;MACvB,IACE,EAAEA,MAAM,YAAYC,OAAO,CAAC,IAC3B,EAAC,iBAAW,CAACpB,OAAO,0CAAEqB,QAAQ,CAACF,MAAM,CAAC,KACrC,EAAC,eAAS,CAACnB,OAAO,0CAAEqB,QAAQ,CAACF,MAAM,CAAC,CAAC,EACvC;QACAvE,UAAU,CAAC,KAAK,CAAC;;IAErB,CAAC;IAEDkD,MAAM,CAACwB,gBAAgB,CAAC,OAAO,EAAEJ,OAAO,CAAC;IACzC,OAAO;MACLpB,MAAM,CAACyB,mBAAmB,CAAC,OAAO,EAAEL,OAAO,CAAC;IAC9C,CAAC;EACH,CAAC,EAAE,CAACf,WAAW,EAAEvD,UAAU,EAAEwD,SAAS,EAAEzD,OAAO,CAAC,CAAC;EACjDf,SAAS,CAAC;;IACR,IAAIe,OAAO,EAAE;MACX;;IAGF;IACA;IACA;IACA;IACA;IACAsD,eAAe,CAACD,OAAO,GACrBC,eAAe,CAACD,OAAO,IACvB,EAAC,iBAAW,CAACA,OAAO,0CAAEqB,QAAQ,CAACG,QAAQ,CAACC,aAAa,CAAC;IAExDhC,WAAW,CAAC,UAACiC,YAAY;MACvB,aAAM,KAAKA,YAAY,GAAG,EAAE,GAAGA,YAAY;IAA3C,CAA2C,CAC5C;EACH,CAAC,EAAE,CAACC,MAAM,EAAErC,IAAI,EAAEG,WAAW,EAAE9C,OAAO,CAAC,CAAC;EACxCf,SAAS,CAAC;IACRgB,UAAU,CAAC+E,MAAM,KAAKnC,QAAQ,CAAC;EACjC,CAAC,EAAE,CAACA,QAAQ,EAAEmC,MAAM,EAAErC,IAAI,EAAE1C,UAAU,CAAC,CAAC;EAExC,OAAO;IACLgF,OAAO,EAAEtB,OAAO;IAChBuB,SAAS;MACP;MACA;MACA,YAAY,EAAEnF,SAAmB;MACjC,iBAAiB,EAAEA,SAAS,GAAGoF,SAAS,GAAGH,MAAM;MACjDI,EAAE,EAAE,UAAGJ,MAAM,UAAO;MACpBpB,KAAK;IAAA,GACFU,iBAAiB;MACpBtE,OAAO;MACPqF,OAAO,YAACnB,KAAK;QACX7D,WAAW,CAAC6D,KAAK,CAAC;QAClB,IAAIA,KAAK,CAACoB,oBAAoB,EAAE,EAAE;UAChC;;QAGF;QACA;QACA,IAAIpB,KAAK,CAACqB,aAAa,KAAKrB,KAAK,CAACM,MAAM,EAAE;UACxC;;QAGF;QACA;QACA,IAAIN,KAAK,CAACM,MAAM,YAAYgB,WAAW,EAAE;UACvClC,eAAe,CAACD,OAAO,GAAGjE,eAAe,CACvC8E,KAAK,CAACqB,aAAa,EACnBrB,KAAK,CAACM,MAAM,CAACiB,OAAO,CAAC,GAAG,CAAC,CAC1B;;QAEHxF,UAAU,CAAC,KAAK,CAAC;MACnB,CAAC;MACDyF,SAAS,YAACxB,KAAK;QACb3D,aAAa,CAAC2D,KAAK,CAAC;QACpB,IAAIA,KAAK,CAACoB,oBAAoB,EAAE,EAAE;UAChC;;QAGF,QAAQpB,KAAK,CAACyB,GAAG;UACf,KAAK,QAAQ;YACX;YACA;YACAzB,KAAK,CAAC0B,eAAe,EAAE;YACvB3F,UAAU,CAAC,KAAK,CAAC;YACjB;UACF,KAAK,KAAK;YACR;YACA;YACAiE,KAAK,CAAC2B,cAAc,EAAE;YACtB,IAAI,CAAC5E,QAAQ,EAAE;cACb;cACAiD,KAAK,CAAC0B,eAAe,EAAE;;YAEzB3F,UAAU,CAAC,KAAK,CAAC;YACjB;UACF,KAAK,SAAS;YACZ,IAAIgB,QAAQ,IAAIE,UAAU,EAAE;cAC1B+C,KAAK,CAAC0B,eAAe,EAAE;cACvB1B,KAAK,CAAC2B,cAAc,EAAE;cACtB5F,UAAU,CAAC,KAAK,CAAC;;YAEnB;UACF,KAAK,WAAW;YACd,IAAIgB,QAAQ,IAAI,CAACE,UAAU,EAAE;cAC3B+C,KAAK,CAAC0B,eAAe,EAAE;cACvB1B,KAAK,CAAC2B,cAAc,EAAE;cACtB5F,UAAU,CAAC,KAAK,CAAC;;YAEnB;QAAM;MAEZ;IAAC,EACF;IACDuD,WAAW;IACXC,SAAS;IACTqC,WAAW,EAAE;MACX,eAAe,EAAE,MAAM;MACvB,eAAe,EAAE9F,OAAO,IAAImF,SAAS;MACrCC,EAAE,EAAEJ,MAAM;MACVK,OAAO,YAACnB,KAAK;QACXzD,aAAa,CAACyD,KAAK,CAAC;QACpB,IAAIA,KAAK,CAACoB,oBAAoB,EAAE,EAAE;UAChC;;QAGF,IAAIrE,QAAQ,IAAI2B,OAAO,EAAE;UACvB;UACA;UACAsB,KAAK,CAAC0B,eAAe,EAAE;;QAGzB3F,UAAU,CAAC,UAAC8F,WAAW;UAAK,QAACA,WAAW;QAAZ,CAAY,CAAC;QACzCjD,WAAW,CAAC,UAACiC,YAAY;UAAK,OAACC,MAAM,KAAKD,YAAY,GAAG,EAAE,GAAGC,MAAM;QAAtC,CAAuC,CAAC;MACxE,CAAC;MACDU,SAAS,YAACxB,KAAK;QACbvD,eAAe,CAACuD,KAAK,CAAC;QACtB,IAAIA,KAAK,CAACoB,oBAAoB,EAAE,IAAIzF,QAAQ,EAAE;UAC5C;;QAGF,IAAI+C,OAAO,IAAI,CAAC3B,QAAQ,IAAIiD,KAAK,CAACyB,GAAG,KAAK,WAAW,EAAE;UACrDzB,KAAK,CAAC2B,cAAc,EAAE;UACtB3B,KAAK,CAAC0B,eAAe,EAAE;UACvB9C,WAAW,CAACkC,MAAM,CAAC;UACnB;;QAGF,IAAI,CAAC/D,QAAQ,EAAE;UACb;;QAGF,QAAQiD,KAAK,CAACyB,GAAG;UACf,KAAK,WAAW;YACd,IAAIxE,UAAU,EAAE;cACd+C,KAAK,CAAC0B,eAAe,EAAE;cACvB1B,KAAK,CAAC2B,cAAc,EAAE;cACtB5F,UAAU,CAAC,IAAI,CAAC;;YAElB;UACF,KAAK,YAAY;YACf,IAAI,CAACkB,UAAU,EAAE;cACf+C,KAAK,CAAC0B,eAAe,EAAE;cACvB1B,KAAK,CAAC2B,cAAc,EAAE;cACtB5F,UAAU,CAAC,IAAI,CAAC;;YAElB;QAAM;MAEZ,CAAC;MACD+F,YAAY,YAAC9B,KAAK;QAChBrD,kBAAkB,CAACqD,KAAK,CAAC;QACzB,IACEA,KAAK,CAACoB,oBAAoB,EAAE,IAC5BzF,QAAQ,IACR,CAAC+C,OAAO,IACR,CAACC,QAAQ,IACTI,KAAK,EACL;UACA,IAAI,OAAOF,YAAY,KAAK,QAAQ,EAAE;YACpCG,OAAO,CAACG,OAAO,GAAGF,MAAM,CAAC8C,UAAU,CAAC;cAClCnD,WAAW,CAACkC,MAAM,CAAC;YACrB,CAAC,EAAEjC,YAAY,CAAC;;UAElB;;QAGFD,WAAW,CAACkC,MAAM,CAAC;MACrB,CAAC;MACDkB,YAAY,YAAChC,KAAK;QAChBnD,kBAAkB,CAACmD,KAAK,CAAC;QACzBf,MAAM,CAACC,YAAY,CAACF,OAAO,CAACG,OAAO,CAAC;MACtC;;GAEH;AACH","names":["useEffect","useRef","useFixedPositioning","containsElement","useIsUserInteractionMode","useScrollLock","useMenuBarContext","getDefaultAnchor","noop","useMenu","options","_a","disabled","propStyle","menuLabel","visible","setVisible","_b","floating","_c","onMenuClick","_d","onMenuKeyDown","_e","onToggleClick","_f","onToggleKeyDown","_g","onToggleMouseEnter","_h","onToggleMouseLeave","_j","menuitem","_k","horizontal","propAnchor","fixedPositionOptions","getFixedPositionOptions","_l","closeOnResize","_m","closeOnScroll","onEnter","onEntering","_o","onEntered","_p","onExited","_q","onFixedPositionScroll","_r","onFixedPositionResize","_s","preventScroll","_t","disableFocusOnMount","_u","disableFocusOnUnmount","root","menubar","activeId","setActiveId","hoverTimeout","setAnimatedOnce","touch","timeout","window","clearTimeout","current","cancelExitFocus","anchor","menuNodeRef","toggleRef","_w","nodeRef","style","fixedTo","appearing","focus","transformOrigin","onScroll","event","data","onResize","_x","transitionOptions","handler","target","Element","contains","addEventListener","removeEventListener","document","activeElement","prevActiveId","baseId","menuRef","menuProps","undefined","id","onClick","isPropagationStopped","currentTarget","HTMLElement","closest","onKeyDown","key","stopPropagation","preventDefault","toggleProps","prevVisible","onMouseEnter","setTimeout","onMouseLeave"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/menu/src/useMenu.ts"],"sourcesContent":["import type {\n  KeyboardEventHandler,\n  MouseEventHandler,\n  MutableRefObject,\n} from \"react\";\nimport { useEffect, useRef } from \"react\";\nimport type { FABPosition } from \"@react-md/button\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport {\n  containsElement,\n  useIsUserInteractionMode,\n  useScrollLock,\n} from \"@react-md/utils\";\n\nimport { useMenuBarContext } from \"./MenuBarProvider\";\nimport type {\n  BaseMenuHookOptions,\n  BaseMenuHookReturnValue,\n  ProvidedMenuToggleProps,\n} from \"./types\";\nimport { getDefaultAnchor, noop } from \"./utils\";\n\n/** @remarks \\@since 5.0.0 */\nexport interface MenuHookOptions<ToggleEl extends HTMLElement>\n  extends BaseMenuHookOptions {\n  /**\n   * Boolean if the toggle component is currently disabled which will prevent\n   * the arrow keys from opening a menuitem's menu.\n   *\n   * @defaultValue `false`\n   */\n  disabled?: boolean;\n\n  /**\n   * This is just used to update the default anchor behavior.\n   *\n   * @see {@link FABPosition}\n   * @defaultValue `null`\n   */\n  floating?: FABPosition;\n\n  /**\n   * An optional click handler to merge with the\n   * {@link MenuHookReturnValue.onClick} behavior.\n   */\n  onMenuClick?: MouseEventHandler<HTMLDivElement>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link MenuHookReturnValue.menuProps} behavior. Calling\n   * `event.stopPropagation()` will prevent the default behavior of closing the\n   * menu when the `\"Escape\"` key is pressed.\n   */\n  onMenuKeyDown?: KeyboardEventHandler<HTMLDivElement>;\n\n  /**\n   * An optional click handler to merge with the toggle visibility behavior.\n   * Calling `event.stopPropagation()` will prevent the default behavior from\n   * occurring.\n   */\n  onToggleClick?: MouseEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onKeyDown} behavior.\n   */\n  onToggleKeyDown?: KeyboardEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onMouseEnter} behavior.\n   */\n  onToggleMouseEnter?: MouseEventHandler<ToggleEl>;\n\n  /**\n   * An optional keydown handler to merge with the\n   * {@link ProvidedMenuToggleProps.onMouseLeave} behavior.\n   */\n  onToggleMouseLeave?: MouseEventHandler<ToggleEl>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface MenuHookReturnValue<ToggleEl extends HTMLElement>\n  extends BaseMenuHookReturnValue {\n  /**\n   * A ref that **must** be passed to the toggle element if the toggle should be\n   * refocused when the menu is closed via a keyboard press. This can also be\n   * used if you need access to the toggle element's DOM node for some reason.\n   */\n  toggleRef: MutableRefObject<ToggleEl | null>;\n\n  /**\n   * An object of props that must be provided to the toggle element for the\n   * visibility functionality of menus to work.\n   *\n   * @see {@link ProvidedMenuToggleProps}\n   */\n  toggleProps: ProvidedMenuToggleProps<ToggleEl>;\n}\n\n/**\n * This hook provides all the functionality for a menu to:\n * - toggle the `Menu`'s visibility when the `MenuButton` or `MenuItemButton`\n *   has been clicked\n * - hide the `Menu` when an element outside of the `Menu` has been clicked\n * - hide the `Menu` when the `Escape` or `Tab` key has been pressed\n * - focus the `Menu` element when it gains visibility\n * - refocus the `MenuButton` or `MenuItemButton` when the menu loses visibility\n * - position the menu within the viewport with {@link useFixedPositioning}\n * - show the `Menu` when the `ArrowRight` key is pressed for a vertical\n *   `MenuItemButton`\n * - show the `Menu` when the `ArrowDown` key is pressed for a horizontal\n *   `MenuItemButton`\n * - hide the `Menu` when the `ArrowRight` key is pressed in a vertical submenu\n * - hide the `Menu` when the `ArrowDown` key is pressed in a horizontal\n *   submenu\n * - conditionally hide the `Menu` if the page is scrolled while the `Menu` is\n *   visible\n * - conditionally hide the `Menu` if the page is resized while the `Menu` is\n *   visible\n * - conditionally move focus to the next `DropdownMenu` with keyboard movement\n *   when inside of a `MenuBar`\n * - conditionally enable the visibility for a `DropdownMenu` when the mouse\n *   hovers over a `MenuItemButton` with a parent `MenuBar` that has been\n *   activated\n * - conditionally show/hide the `Menu` based on a parent `MenuBar`'s `activeId`\n *\n * This hook will probably never need to be used externally since it has been\n * integrated into the `DropdownMenu` component and `useContextMenu` hook.\n *\n * @example\n * Simple Example\n * ```tsx\n * import { ReactElement, useState } from \"react\";\n * import { useMenu, Menu, MenuButton, MenuItem } from \"@react-md/menu\";\n *\n * function Example(): ReactElement {\n *   const [visible, setVisible] = useState(false);\n *   const { menuRef, menuProps, toggleRef, toggleProps } = useMenu<\n *     HTMLButtonElement\n *   >({\n *     baseId: \"custom-menu-button\",\n *     visible,\n *     setVisible,\n *   });\n *\n *   return (\n *     <>\n *       <MenuButton ref={toggleRef} {...toggleProps}>\n *         Button\n *       </MenuButton>\n *       <Menu ref={menuRef} {...menuProps}>\n *         <MenuItem>Item 1</MenuItem>\n *         <MenuItem>Item 2</MenuItem>\n *         <MenuItem>Item 3</MenuItem>\n *       </Menu>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 5.0.0\n */\nexport function useMenu<ToggleEl extends HTMLElement>(\n  options: MenuHookOptions<ToggleEl>\n): MenuHookReturnValue<ToggleEl> {\n  const {\n    baseId,\n    disabled = false,\n    style: propStyle,\n    menuLabel,\n    visible,\n    setVisible,\n    floating = null,\n    onMenuClick = noop,\n    onMenuKeyDown = noop,\n    onToggleClick = noop,\n    onToggleKeyDown = noop,\n    onToggleMouseEnter = noop,\n    onToggleMouseLeave = noop,\n    menuitem = false,\n    horizontal = false,\n    anchor: propAnchor,\n    fixedPositionOptions,\n    getFixedPositionOptions,\n    closeOnResize = false,\n    closeOnScroll = false,\n    onEnter,\n    onEntering,\n    onEntered = noop,\n    onExited = noop,\n    onFixedPositionScroll = noop,\n    onFixedPositionResize = noop,\n    preventScroll = false,\n    disableFocusOnMount = false,\n    disableFocusOnUnmount = false,\n  } = options;\n  const {\n    root,\n    menubar,\n    activeId,\n    setActiveId,\n    hoverTimeout,\n    setAnimatedOnce,\n  } = useMenuBarContext();\n  const touch = useIsUserInteractionMode(\"touch\");\n\n  const timeout = useRef<number | undefined>();\n  useEffect(() => {\n    return () => {\n      window.clearTimeout(timeout.current);\n    };\n  }, []);\n\n  // if the menu hides because the user scrolls the page or the page is resized,\n  // the focus toggle behavior should be disabled since the user is no longer\n  // interacting with the menu\n  const cancelExitFocus = useRef(false);\n  const anchor =\n    propAnchor ?? getDefaultAnchor({ menubar, menuitem, floating, horizontal });\n  const menuNodeRef = useRef<HTMLDivElement>(null);\n  const toggleRef = useRef<ToggleEl | null>(null);\n  const {\n    style,\n    transitionOptions: { nodeRef, ...transitionOptions },\n  } = useFixedPositioning({\n    nodeRef: menuNodeRef,\n    style: propStyle,\n    fixedTo: toggleRef,\n    onEnter,\n    onEntering,\n    onEntered(appearing) {\n      cancelExitFocus.current = false;\n      onEntered(appearing);\n      setAnimatedOnce(true);\n      if (!disableFocusOnMount) {\n        menuNodeRef.current?.focus();\n      }\n    },\n    onExited() {\n      onExited();\n\n      // this has to be done onExited or else the toggle component will be\n      // clicked if the user pressed the \"Enter\" key which makes it look like\n      // the menu never closes.\n      if (!disableFocusOnUnmount && !cancelExitFocus.current) {\n        toggleRef.current?.focus();\n      }\n    },\n    anchor,\n    transformOrigin: true,\n    ...fixedPositionOptions,\n    getFixedPositionOptions,\n    onScroll(event, data) {\n      onFixedPositionScroll(event, data);\n      if (!data.visible || closeOnScroll) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    },\n    onResize(event) {\n      onFixedPositionResize(event);\n      if (closeOnResize) {\n        cancelExitFocus.current = true;\n        setVisible(false);\n      }\n    },\n  });\n  useScrollLock(preventScroll && visible);\n\n  useEffect(() => {\n    if (!visible) {\n      return;\n    }\n\n    const handler = ({ target }: MouseEvent): void => {\n      if (\n        !(target instanceof Element) ||\n        (!menuNodeRef.current?.contains(target) &&\n          !toggleRef.current?.contains(target))\n      ) {\n        setVisible(false);\n      }\n    };\n\n    window.addEventListener(\"click\", handler);\n    return () => {\n      window.removeEventListener(\"click\", handler);\n    };\n  }, [menuNodeRef, setVisible, toggleRef, visible]);\n  useEffect(() => {\n    if (visible) {\n      return;\n    }\n\n    // this is to fix keyboard movement behavior when navigating between\n    // different root-level menuitems with the `ArrowLeft` and `ArrowRight` keys\n    // while menus are visible. If the exit focus behavior is not cancelled, the\n    // next menu's menu will be visible, but the current menu's menuitem would\n    // be the current focus which breaks everything\n    cancelExitFocus.current =\n      cancelExitFocus.current ||\n      !menuNodeRef.current?.contains(document.activeElement);\n\n    setActiveId((prevActiveId) =>\n      baseId === prevActiveId ? \"\" : prevActiveId\n    );\n  }, [baseId, root, setActiveId, visible]);\n  useEffect(() => {\n    setVisible(baseId === activeId);\n  }, [activeId, baseId, root, setVisible]);\n\n  return {\n    menuRef: nodeRef,\n    menuProps: {\n      // typecast to string so that it passes the RequireAtLeastOne<LabelA11y>\n      // TS won't pass otherwise\n      \"aria-label\": menuLabel as string,\n      \"aria-labelledby\": menuLabel ? undefined : baseId,\n      id: `${baseId}-menu`,\n      style,\n      ...transitionOptions,\n      visible,\n      onClick(event) {\n        onMenuClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        // this makes it so you can click on the menu/list without closing the\n        // menu\n        if (event.currentTarget === event.target) {\n          return;\n        }\n\n        // This might be a test only workaround since clicking links move focus\n        // somewhere else\n        if (event.target instanceof HTMLElement) {\n          cancelExitFocus.current = containsElement(\n            event.currentTarget,\n            event.target.closest(\"a\")\n          );\n        }\n        setVisible(false);\n      },\n      onKeyDown(event) {\n        onMenuKeyDown(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"Escape\":\n            // prevent parent components that have an \"Escape\" keypress event\n            // from being triggered as well\n            event.stopPropagation();\n            setVisible(false);\n            break;\n          case \"Tab\":\n            // since menus are portalled, tab index is kinda broke so just close\n            // the menu instead of doing default tab behavior\n            event.preventDefault();\n            if (!menuitem) {\n              // pressing the tab key should still cascade close all menus\n              event.stopPropagation();\n            }\n            setVisible(false);\n            break;\n          case \"ArrowUp\":\n            if (menuitem && horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n          case \"ArrowLeft\":\n            if (menuitem && !horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(false);\n            }\n            break;\n        }\n      },\n    },\n    menuNodeRef,\n    toggleRef,\n    toggleProps: {\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": visible || undefined,\n      id: baseId,\n      onClick(event) {\n        onToggleClick(event);\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        if (menuitem || menubar) {\n          // do not allow the default menu close behavior from\n          // triggering for parent menus\n          event.stopPropagation();\n        }\n\n        setVisible((prevVisible) => !prevVisible);\n        setActiveId((prevActiveId) => (baseId === prevActiveId ? \"\" : baseId));\n      },\n      onKeyDown(event) {\n        onToggleKeyDown(event);\n        if (event.isPropagationStopped() || disabled) {\n          return;\n        }\n\n        if (menubar && !menuitem && event.key === \"ArrowDown\") {\n          event.preventDefault();\n          event.stopPropagation();\n          setActiveId(baseId);\n          return;\n        }\n\n        if (!menuitem) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n          case \"ArrowRight\":\n            if (!horizontal) {\n              event.stopPropagation();\n              event.preventDefault();\n              setVisible(true);\n            }\n            break;\n        }\n      },\n      onMouseEnter(event) {\n        onToggleMouseEnter(event);\n        if (\n          event.isPropagationStopped() ||\n          disabled ||\n          !menubar ||\n          !activeId ||\n          touch\n        ) {\n          if (typeof hoverTimeout === \"number\") {\n            timeout.current = window.setTimeout(() => {\n              setActiveId(baseId);\n            }, hoverTimeout);\n          }\n          return;\n        }\n\n        setActiveId(baseId);\n      },\n      onMouseLeave(event) {\n        onToggleMouseLeave(event);\n        window.clearTimeout(timeout.current);\n      },\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}