{"ast":null,"code":"var delegatedEvents = [];\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/**\n * Creates the delegated event handler that will run all the callbacks once an\n * event happens. The callbacks' invocation can also be throttled for event\n * types that trigger rapidly for additional performance.\n *\n * The `<K extends keyof WindowEventMap` is a nice thing I found while looking\n * through the `lib.d.ts` implementation of `addEventListener` that will allow\n * you to get the \"correct\" event type when using the `add` and `remove`\n * functions once you have created this event handler. Otherwise there'd be ts\n * errors trying to do `MouseEvent` or `KeyboardEvent` in your listeners.\n */\nfunction createEventHandler(throttle, callbacks) {\n  var running = false;\n  var runCallbacks = function (event) {\n    return function () {\n      for (var i = 0; i < callbacks.length; i += 1) {\n        callbacks[i](event);\n      }\n      running = false;\n    };\n  };\n  return function eventHandler(event) {\n    if (!throttle) {\n      runCallbacks(event)();\n      return;\n    }\n    if (running) {\n      return;\n    }\n    running = true;\n    window.requestAnimationFrame(runCallbacks(event));\n  };\n}\n/* eslint-enable @typescript-eslint/explicit-function-return-type */\n/**\n * Creates a throttled event handler for the provided event type and event\n * target.\n */\nfunction createDelegatedEventHandler(eventType, eventTarget, throttle, options) {\n  if (eventTarget === void 0) {\n    eventTarget = window;\n  }\n  if (throttle === void 0) {\n    throttle = false;\n  }\n  var callbacks = [];\n  var handler = createEventHandler(throttle, callbacks);\n  return {\n    /**\n     * Attempts to add the provided callback to the list of callbacks for the\n     * throttled event. If this is the first callback to be added, the throttled\n     * event will also be started.\n     */\n    add: function (callback) {\n      if (!callbacks.length) {\n        eventTarget.addEventListener(eventType, handler, options);\n      }\n      if (callbacks.indexOf(callback) === -1) {\n        callbacks.push(callback);\n      }\n    },\n    /**\n     * Attempts to remove the provided callback from the list of callbacks for\n     * the throttled event. If this is the last callback that was removed, the\n     * throttled event will also be stopped.\n     */\n    remove: function (callback) {\n      var i = callbacks.indexOf(callback);\n      if (i >= 0) {\n        callbacks.splice(i, 1);\n        if (!callbacks.length) {\n          eventTarget.removeEventListener(eventType, handler, options);\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a delegated event listener using custom events. Most of this code\n * comes from the MDN about resize listeners.\n *\n * This will return an object for adding or removing event handlers for the\n * provided `eventType` since only one base throttled event listener will be\n * created. Each callback that is added will be called with the event each time\n * the event is triggered. This does mean that you will manually need to remove\n * your callback like normal or else it can be called when no longer in use.\n * This also means that it doesn't \"hurt\" to call this function without\n * immediately calling the `add` function since the event won't start until\n * there is at least 1 callback.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Events/resize#Examples\n * @param eventType - One of the event types that should be used to create a\n * delegated event for. This should be things like resize, click, scroll, etc.\n * @param eventTarget - The target that should have the delegated event handler\n * attached to. This is normally the window, but can be any element as needed.\n * @param throttle - Boolean if the event should be throttled or not. Normally\n * only event types like resize or scroll should be throttled for performance\n * boosts, but anything can be.\n * @returns The delegated event handler that allows you to add or remove\n * `EventListener`s to that event.\n */\nexport function delegateEvent(eventType, eventTarget, throttle, options) {\n  if (eventTarget === void 0) {\n    eventTarget = window;\n  }\n  if (throttle === void 0) {\n    throttle = eventType === \"resize\" || eventType === \"scroll\";\n  }\n  var index = delegatedEvents.findIndex(function (event) {\n    return event.type === eventType && event.target === eventTarget && event.options === options && event.throttle === throttle;\n  });\n  if (index === -1) {\n    delegatedEvents.push({\n      type: eventType,\n      target: eventTarget,\n      options: options,\n      throttle: throttle,\n      handler: createDelegatedEventHandler(eventType, eventTarget, throttle, options)\n    });\n    index = delegatedEvents.length - 1;\n  }\n  return delegatedEvents[index].handler;\n}","map":{"version":3,"mappings":"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","names":["delegatedEvents","createEventHandler","throttle","callbacks","running","runCallbacks","event","i","length","eventHandler","window","requestAnimationFrame","createDelegatedEventHandler","eventType","eventTarget","options","handler","add","callback","addEventListener","indexOf","push","remove","splice","removeEventListener","delegateEvent","index","findIndex","type","target"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/events/utils.ts"],"sourcesContent":["export type DelegatedEventTarget = Window | Document | HTMLElement;\n\n/**\n * This is a \"shared\" event handler for the provided `eventType`. The event\n * listener will only be created once, but every single callback will be called\n * when the throttled event is triggered. This means that you will need to make\n * sure to remove the provided callback when it is no longer in use.\n */\nexport interface DelegatedEventHandler {\n  /**\n   * Adds the provided callback to the throttled event listener.\n   */\n  add: (callback: EventListener) => void;\n\n  /**\n   * Attempts to remove the provided callback from the throttled event listener.\n   */\n  remove: (callback: EventListener) => void;\n}\n\nexport interface DelegatableEvent {\n  type: string;\n  target: DelegatedEventTarget;\n  throttle: boolean;\n  handler: DelegatedEventHandler;\n  options?: boolean | AddEventListenerOptions;\n}\n\nconst delegatedEvents: DelegatableEvent[] = [];\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\n/**\n * Creates the delegated event handler that will run all the callbacks once an\n * event happens. The callbacks' invocation can also be throttled for event\n * types that trigger rapidly for additional performance.\n *\n * The `<K extends keyof WindowEventMap` is a nice thing I found while looking\n * through the `lib.d.ts` implementation of `addEventListener` that will allow\n * you to get the \"correct\" event type when using the `add` and `remove`\n * functions once you have created this event handler. Otherwise there'd be ts\n * errors trying to do `MouseEvent` or `KeyboardEvent` in your listeners.\n */\nfunction createEventHandler<K extends keyof WindowEventMap>(\n  throttle: boolean,\n  callbacks: readonly EventListener[]\n) {\n  let running = false;\n  const runCallbacks = (event: WindowEventMap[K]) => () => {\n    for (let i = 0; i < callbacks.length; i += 1) {\n      callbacks[i](event);\n    }\n\n    running = false;\n  };\n\n  return function eventHandler(event: WindowEventMap[K]) {\n    if (!throttle) {\n      runCallbacks(event)();\n      return;\n    }\n\n    if (running) {\n      return;\n    }\n\n    running = true;\n    window.requestAnimationFrame(runCallbacks(event));\n  };\n}\n/* eslint-enable @typescript-eslint/explicit-function-return-type */\n\n/**\n * Creates a throttled event handler for the provided event type and event\n * target.\n */\nfunction createDelegatedEventHandler(\n  eventType: string,\n  eventTarget: DelegatedEventTarget = window,\n  throttle = false,\n  options?: boolean | AddEventListenerOptions\n): DelegatedEventHandler {\n  const callbacks: EventListener[] = [];\n  const handler = createEventHandler(throttle, callbacks);\n\n  return {\n    /**\n     * Attempts to add the provided callback to the list of callbacks for the\n     * throttled event. If this is the first callback to be added, the throttled\n     * event will also be started.\n     */\n    add: (callback: EventListener) => {\n      if (!callbacks.length) {\n        eventTarget.addEventListener(eventType, handler, options);\n      }\n\n      if (callbacks.indexOf(callback) === -1) {\n        callbacks.push(callback);\n      }\n    },\n\n    /**\n     * Attempts to remove the provided callback from the list of callbacks for\n     * the throttled event. If this is the last callback that was removed, the\n     * throttled event will also be stopped.\n     */\n    remove: (callback: EventListener) => {\n      const i = callbacks.indexOf(callback);\n      if (i >= 0) {\n        callbacks.splice(i, 1);\n\n        if (!callbacks.length) {\n          eventTarget.removeEventListener(eventType, handler, options);\n        }\n      }\n    },\n  };\n}\n\n/**\n * Creates a delegated event listener using custom events. Most of this code\n * comes from the MDN about resize listeners.\n *\n * This will return an object for adding or removing event handlers for the\n * provided `eventType` since only one base throttled event listener will be\n * created. Each callback that is added will be called with the event each time\n * the event is triggered. This does mean that you will manually need to remove\n * your callback like normal or else it can be called when no longer in use.\n * This also means that it doesn't \"hurt\" to call this function without\n * immediately calling the `add` function since the event won't start until\n * there is at least 1 callback.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/Events/resize#Examples\n * @param eventType - One of the event types that should be used to create a\n * delegated event for. This should be things like resize, click, scroll, etc.\n * @param eventTarget - The target that should have the delegated event handler\n * attached to. This is normally the window, but can be any element as needed.\n * @param throttle - Boolean if the event should be throttled or not. Normally\n * only event types like resize or scroll should be throttled for performance\n * boosts, but anything can be.\n * @returns The delegated event handler that allows you to add or remove\n * `EventListener`s to that event.\n */\nexport function delegateEvent(\n  eventType: string,\n  eventTarget: DelegatedEventTarget = window,\n  throttle: boolean = eventType === \"resize\" || eventType === \"scroll\",\n  options?: boolean | AddEventListenerOptions\n): DelegatedEventHandler {\n  let index = delegatedEvents.findIndex(\n    (event) =>\n      event.type === eventType &&\n      event.target === eventTarget &&\n      event.options === options &&\n      event.throttle === throttle\n  );\n\n  if (index === -1) {\n    delegatedEvents.push({\n      type: eventType,\n      target: eventTarget,\n      options,\n      throttle,\n      handler: createDelegatedEventHandler(\n        eventType,\n        eventTarget,\n        throttle,\n        options\n      ),\n    });\n\n    index = delegatedEvents.length - 1;\n  }\n\n  return delegatedEvents[index].handler;\n}\n"]},"metadata":{},"sourceType":"module"}