{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Children, cloneElement, forwardRef, isValidElement, useCallback, useEffect, useRef, useState } from \"react\";\nimport cn from \"classnames\";\nimport { bem, useEnsuredRef } from \"@react-md/utils\";\nimport { useTabs } from \"./TabsManager\";\nvar block = bem(\"rmd-tab-panels\");\n/**\n * This component allows you to control the visibility of the `TabPanel`\n * components and animating the next and current panels as needed. This works by\n * looping over all the children and getting the current `TabPanel` by the\n * `activeIndex`. This is why the children for this component can only be\n * `TabPanel` and should not be conditional.\n */\nexport var TabPanels = forwardRef(function TabPanels(_a, forwardedRef) {\n  var className = _a.className,\n    children = _a.children,\n    _b = _a.disableScrollFix,\n    disableScrollFix = _b === void 0 ? false : _b,\n    _c = _a.disableTransition,\n    disableTransition = _c === void 0 ? false : _c,\n    _d = _a.persistent,\n    persistent = _d === void 0 ? false : _d,\n    props = __rest(_a, [\"className\", \"children\", \"disableScrollFix\", \"disableTransition\", \"persistent\"]);\n  var _e = useTabs(),\n    tabsId = _e.tabsId,\n    tabs = _e.tabs,\n    activeIndex = _e.activeIndex;\n  var prevIndex = useRef(activeIndex);\n  var _f = __read(useState({\n      previous: activeIndex,\n      incrementing: true\n    }), 2),\n    _g = _f[0],\n    previous = _g.previous,\n    incrementing = _g.incrementing,\n    setState = _f[1];\n  // have to set these in refs since changing these might cause mounting\n  // and unmounting in the Transition group component :/ they should only\n  // be re-evaluated when the activeIndex changes.\n  var transitionable = useRef(!persistent && !disableTransition);\n  var animatable = useRef(persistent && !disableTransition);\n  if (prevIndex.current !== activeIndex) {\n    prevIndex.current = activeIndex;\n    transitionable.current = !persistent && !disableTransition;\n    animatable.current = persistent && !disableTransition;\n  }\n  useEffect(function () {\n    setState(function (_a) {\n      var previous = _a.previous;\n      return {\n        incrementing: previous < activeIndex,\n        previous: disableTransition ? activeIndex : previous\n      };\n    });\n    // this is for only updating the incrementing state and should not be fired\n    // again if the disableTransition prop is changed\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeIndex]);\n  var onEntered = useCallback(function () {\n    setState(function (_a) {\n      var incrementing = _a.incrementing;\n      return {\n        incrementing: incrementing,\n        previous: activeIndex\n      };\n    });\n  }, [activeIndex]);\n  var _h = __read(useEnsuredRef(forwardedRef), 2),\n    ref = _h[0],\n    refHandler = _h[1];\n  useEffect(function () {\n    if (!ref.current || disableScrollFix) {\n      return;\n    }\n    ref.current.scrollTop = 0;\n    // don't want it to be triggered if only the disableScrollFix prop has changed\n    // since it might be independent from active indexes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [activeIndex]);\n  return _jsx(\"div\", __assign({}, props, {\n    ref: refHandler,\n    className: cn(block({\n      \"slide-left\": incrementing,\n      \"slide-right\": !incrementing\n    }), className)\n  }, {\n    children: Children.map(children, function (child, index) {\n      if (!isValidElement(child)) {\n        return child;\n      }\n      var panel = Children.only(child);\n      var labelledBy = panel.props[\"aria-labelledby\"];\n      if (!labelledBy && !panel.props[\"aria-label\"] && tabs[index]) {\n        // generally guaranteed to be defined by this point since the TabsManager\n        // will add ids if missing.\n        labelledBy = tabs[index].id;\n      }\n      return cloneElement(child, {\n        \"aria-labelledby\": labelledBy,\n        id: \"\".concat(tabsId, \"-panel-\").concat(index + 1),\n        hidden: persistent && index !== activeIndex && index !== previous,\n        temporary: !persistent,\n        transitionIn: index === activeIndex,\n        timeout: disableTransition ? 0 : panel.props.timeout,\n        onEntered: disableTransition ? undefined : onEntered\n      });\n    })\n  }));\n});","map":{"version":3,"mappings":"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","names":["Children","cloneElement","forwardRef","isValidElement","useCallback","useEffect","useRef","useState","cn","bem","useEnsuredRef","useTabs","block","TabPanels","_a","forwardedRef","children","_b","disableScrollFix","_c","disableTransition","_d","persistent","props","tabsId","tabs","activeIndex","prevIndex","previous","incrementing","_g","setState","transitionable","animatable","current","onEntered","ref","refHandler","scrollTop","_jsx","className","map","child","index","panel","only","labelledBy","id","hidden","temporary","transitionIn","timeout","undefined"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/tabs/src/TabPanels.tsx"],"sourcesContent":["import type { HTMLAttributes } from \"react\";\nimport {\n  Children,\n  cloneElement,\n  forwardRef,\n  isValidElement,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport cn from \"classnames\";\nimport { bem, useEnsuredRef } from \"@react-md/utils\";\n\nimport { useTabs } from \"./TabsManager\";\nimport type { TabPanelProps } from \"./TabPanel\";\n\nexport interface TabPanelsProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * Boolean if this component should no longer automatically reset the scrolling\n   * to the top when the panel changes.\n   *\n   * @defaultValue `false`\n   */\n  disableScrollFix?: boolean;\n\n  /**\n   * Boolean if the swiping transition should be disabled. If you want to add\n   * a custom transition, you'll need to wrap the `TabPanel`'s children in a\n   * custom component that does appear and exit animations.\n   *\n   * @defaultValue `false`\n   */\n  disableTransition?: boolean;\n\n  /**\n   * Boolean if the conditional rendering for the active tab panel only should\n   * be disabled. This means that all the children will be visible in the DOM\n   * instead of mounting and unmounting when their active state changes. The\n   * panels will also be updated to ensure that inactive panels can not be\n   * tab focusable.\n   *\n   * @defaultValue `false`\n   */\n  persistent?: boolean;\n}\n\nconst block = bem(\"rmd-tab-panels\");\n\n/**\n * This component allows you to control the visibility of the `TabPanel`\n * components and animating the next and current panels as needed. This works by\n * looping over all the children and getting the current `TabPanel` by the\n * `activeIndex`. This is why the children for this component can only be\n * `TabPanel` and should not be conditional.\n */\nexport const TabPanels = forwardRef<HTMLDivElement, TabPanelsProps>(\n  function TabPanels(\n    {\n      className,\n      children,\n      disableScrollFix = false,\n      disableTransition = false,\n      persistent = false,\n      ...props\n    },\n    forwardedRef\n  ) {\n    const { tabsId, tabs, activeIndex } = useTabs();\n    const prevIndex = useRef(activeIndex);\n    const [{ previous, incrementing }, setState] = useState({\n      previous: activeIndex,\n      incrementing: true,\n    });\n\n    // have to set these in refs since changing these might cause mounting\n    // and unmounting in the Transition group component :/ they should only\n    // be re-evaluated when the activeIndex changes.\n    const transitionable = useRef(!persistent && !disableTransition);\n    const animatable = useRef(persistent && !disableTransition);\n    if (prevIndex.current !== activeIndex) {\n      prevIndex.current = activeIndex;\n      transitionable.current = !persistent && !disableTransition;\n      animatable.current = persistent && !disableTransition;\n    }\n\n    useEffect(() => {\n      setState(({ previous }) => ({\n        incrementing: previous < activeIndex,\n        previous: disableTransition ? activeIndex : previous,\n      }));\n\n      // this is for only updating the incrementing state and should not be fired\n      // again if the disableTransition prop is changed\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [activeIndex]);\n\n    const onEntered = useCallback(() => {\n      setState(({ incrementing }) => ({ incrementing, previous: activeIndex }));\n    }, [activeIndex]);\n\n    const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n    useEffect(() => {\n      if (!ref.current || disableScrollFix) {\n        return;\n      }\n\n      ref.current.scrollTop = 0;\n      // don't want it to be triggered if only the disableScrollFix prop has changed\n      // since it might be independent from active indexes\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [activeIndex]);\n\n    return (\n      <div\n        {...props}\n        ref={refHandler}\n        className={cn(\n          block({\n            \"slide-left\": incrementing,\n            \"slide-right\": !incrementing,\n          }),\n          className\n        )}\n      >\n        {Children.map(children, (child, index) => {\n          if (!isValidElement<TabPanelProps>(child)) {\n            return child;\n          }\n\n          const panel = Children.only(child);\n          let labelledBy = panel.props[\"aria-labelledby\"];\n          if (!labelledBy && !panel.props[\"aria-label\"] && tabs[index]) {\n            // generally guaranteed to be defined by this point since the TabsManager\n            // will add ids if missing.\n            labelledBy = tabs[index].id;\n          }\n\n          return cloneElement(child, {\n            \"aria-labelledby\": labelledBy,\n            id: `${tabsId}-panel-${index + 1}`,\n            hidden: persistent && index !== activeIndex && index !== previous,\n            temporary: !persistent,\n            transitionIn: index === activeIndex,\n            timeout: disableTransition ? 0 : panel.props.timeout,\n            onEntered: disableTransition ? undefined : onEntered,\n          });\n        })}\n      </div>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}