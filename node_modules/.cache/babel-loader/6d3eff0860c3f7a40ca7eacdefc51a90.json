{"ast":null,"code":"import { createContext, useContext } from \"react\";\nexport var DEFAULT_MESSAGE_QUEUE_TIMEOUT = 5000;\n/**\n * @internal\n */\nexport var AddMessageContext = createContext(function () {\n  throw new Error(\"Attempted to create a message without initializing the MessageQueue component.\");\n});\n/**\n * @internal\n */\nexport var MessageVisibilityContext = createContext(false);\n/**\n * This hook is used to add a message to the queue from anywhere in your app.\n * This should normally be used from click event handlers, but can also be\n * triggered with custom logic within components.\n */\nexport function useAddMessage() {\n  return useContext(AddMessageContext);\n}\n/**\n * Gets the current message visibility to provide to the toast.\n *\n * @internal\n */\nexport function useMessageVisibility() {\n  return useContext(MessageVisibilityContext);\n}\n/**\n * @internal\n */\nexport var MessageQueueActionsContext = createContext({\n  popMessage: function () {\n    throw new Error(\"Attempted to pop a message without initializing the MessageQueue component.\");\n  },\n  hideMessage: function () {\n    throw new Error(\"Attempted to hide a message within initializing the MessageQueue component.\");\n  },\n  startTimer: function () {\n    throw new Error(\"Attempted to start a message queue timer without initializing the MessageQueue component.\");\n  },\n  stopTimer: function () {\n    throw new Error(\"Attempted to stop a message queue timer without initializing the MessageQueue component.\");\n  },\n  restartTimer: function () {\n    throw new Error(\"Attempted to restart a message queue timer without initializing the MessageQueue component.\");\n  },\n  resetQueue: function () {\n    throw new Error(\"Attempted to reset the message queue timer without initializing the MessageQueue component.\");\n  }\n});\n/**\n * This hook exposes some of the lower level actions for handling a message\n * queue if advanced behavior is desired.\n */\nexport function useMessageQueueActions() {\n  // I don't know how to type the createContext for a generic\n  return useContext(MessageQueueActionsContext);\n}\n/**\n * @internal\n */\nexport var MessageQueueContext = createContext([]);\n/**\n * This hook will allow you to get the current queue. This probably shouldn't be\n * used that much.\n */\nexport function useQueue() {\n  return useContext(MessageQueueContext);\n}","map":{"version":3,"mappings":"AACA,SAASA,aAAa,EAAEC,UAAU,QAAQ,OAAO;AAKjD,OAAO,IAAMC,6BAA6B,GAAG,IAAI;AAgEjD;;;AAGA,OAAO,IAAMC,iBAAiB,GAAGH,aAAa,CAAsB;EAClE,MAAM,IAAII,KAAK,CACb,gFAAgF,CACjF;AACH,CAAC,CAAC;AAEF;;;AAGA,OAAO,IAAMC,wBAAwB,GAAGL,aAAa,CAAC,KAAK,CAAC;AAE5D;;;;;AAKA,OAAM,SAAUM,aAAa;EAG3B,OAAOL,UAAU,CAACE,iBAAiB,CAAC;AACtC;AAEA;;;;;AAKA,OAAM,SAAUI,oBAAoB;EAClC,OAAON,UAAU,CAACI,wBAAwB,CAAC;AAC7C;AAwDA;;;AAGA,OAAO,IAAMG,0BAA0B,GAAGR,aAAa,CAErD;EACAS,UAAU;IACR,MAAM,IAAIL,KAAK,CACb,6EAA6E,CAC9E;EACH,CAAC;EACDM,WAAW;IACT,MAAM,IAAIN,KAAK,CACb,6EAA6E,CAC9E;EACH,CAAC;EACDO,UAAU;IACR,MAAM,IAAIP,KAAK,CACb,2FAA2F,CAC5F;EACH,CAAC;EACDQ,SAAS;IACP,MAAM,IAAIR,KAAK,CACb,0FAA0F,CAC3F;EACH,CAAC;EACDS,YAAY;IACV,MAAM,IAAIT,KAAK,CACb,6FAA6F,CAC9F;EACH,CAAC;EACDU,UAAU;IACR,MAAM,IAAIV,KAAK,CACb,6FAA6F,CAC9F;EACH;CACD,CAAC;AAEF;;;;AAIA,OAAM,SAAUW,sBAAsB;EAGpC;EACA,OAAOd,UAAU,CAACO,0BAA0B,CAA2B;AACzE;AAEA;;;AAGA,OAAO,IAAMQ,mBAAmB,GAAGhB,aAAa,CAAqB,EAAE,CAAC;AAExE;;;;AAIA,OAAM,SAAUiB,QAAQ;EACtB,OAAOhB,UAAU,CAACe,mBAAmB,CAAiB;AACxD","names":["createContext","useContext","DEFAULT_MESSAGE_QUEUE_TIMEOUT","AddMessageContext","Error","MessageVisibilityContext","useAddMessage","useMessageVisibility","MessageQueueActionsContext","popMessage","hideMessage","startTimer","stopTimer","restartTimer","resetQueue","useMessageQueueActions","MessageQueueContext","useQueue"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/alert/src/MessageQueueContext.tsx"],"sourcesContent":["import type { ReactNode } from \"react\";\nimport { createContext, useContext } from \"react\";\nimport type { ButtonProps } from \"@react-md/button\";\n\nimport type { ToastProps } from \"./Toast\";\n\nexport const DEFAULT_MESSAGE_QUEUE_TIMEOUT = 5000;\n\nexport type DuplicateBehavior = \"restart\" | \"prevent\" | \"allow\";\n\nexport type MessagePriority = \"normal\" | \"next\" | \"immediate\" | \"replace\";\n\nexport interface Message {\n  /**\n   * If you have not enabled the prevent duplicated messages or the restart\n   * message display timer functionality, this property can be omitted since it\n   * is only used for those flows.\n   *\n   * When the `addMessage` action is called, the existing queue will be checked\n   * for a message containing the new message's id. If it exists, it will not be\n   * re-added to the queue. If the current message is being displayed, the\n   * display timer will be restarted.\n   */\n  messageId?: string | number;\n\n  /**\n   * An optional priority to set to the message if this message needs to be\n   * shown to the user more quickly. The default behavior will be to add it to\n   * the end of the message queue, but when the priority is set to `\"next\"` it\n   * will be shown immediately if there are no messages being displayed or\n   * immediately after the current displayed message is hidden. All other\n   * existing messages will maintain their order but pushed behind this new\n   * message.\n   *\n   * @defaultValue `\"normal\"`\n   */\n  messagePriority?: MessagePriority;\n\n  /**\n   * Boolean if the message should not automatically hide itself after the\n   * timeout duration.  This should normally be enabled if you want to enforce\n   * the user presses the action inside or it is a toast that will be hidden by\n   * some other logic (like online/offline).\n   *\n   * @defaultValue `false`\n   */\n  disableAutohide?: boolean;\n}\n\nexport interface ToastMessage\n  extends Message,\n    Omit<ToastProps, \"visible\" | \"action\"> {\n  /**\n   * This can either be an object of button props to apply to a Button or a\n   * ReactNode that will be rendered within a button.\n   */\n  action?: ButtonProps | ReactNode;\n\n  /**\n   * Boolean if the action button should not automatically hide the toast once\n   * clicked.\n   */\n  disableActionHide?: boolean;\n}\n\n/**\n * This function is used to add a message to the queue.\n */\nexport type AddMessage<M extends Message> = (message: M) => void;\n\n/**\n * @internal\n */\nexport const AddMessageContext = createContext<AddMessage<Message>>(() => {\n  throw new Error(\n    \"Attempted to create a message without initializing the MessageQueue component.\"\n  );\n});\n\n/**\n * @internal\n */\nexport const MessageVisibilityContext = createContext(false);\n\n/**\n * This hook is used to add a message to the queue from anywhere in your app.\n * This should normally be used from click event handlers, but can also be\n * triggered with custom logic within components.\n */\nexport function useAddMessage<\n  M extends Message = ToastMessage\n>(): AddMessage<M> {\n  return useContext(AddMessageContext);\n}\n\n/**\n * Gets the current message visibility to provide to the toast.\n *\n * @internal\n */\nexport function useMessageVisibility(): boolean {\n  return useContext(MessageVisibilityContext);\n}\n\n/**\n * This function is used to immediately remove the current message from the\n * queue without an exit animation.\n */\nexport type PopMessage = () => void;\n\n/**\n * This function is used to trigger the exit animation for the current message.\n * Once the animation finishes, the `PopMessage` function will be called to\n * remove it from the queue.\n */\nexport type HideMessage = () => void;\n\n/**\n * This function will start the visibility timer for the current message. The\n * default behavior is to start the timer once the message finishes its' enter\n * animation. Once the timeout finished, the `HideMessage` function will be\n * called to start the exit animation.\n */\nexport type StartVisibilityTimer = () => void;\n\n/**\n * This function will stop the visibility timer for the current message. This is\n * nice to use when the browser is blurred while a toast is visible and then\n * trigger the `RestartVisibilityTimer` once the focus is returned so that\n * toasts are not shown and hidden without the user being aware.\n */\nexport type StopVisibilityTimer = () => void;\n\n/**\n * This function will restart the visibility timer. This is useful for handling\n * duplicate messages or browser focus loss/gain behavior.\n */\nexport type RestartVisibilityTimer = () => void;\n\n/**\n * This will allow you to reset the entire queue and immediately hide all\n * notifications. This will return the current queue at the time of reset if you\n * would like to do some manual logic for adding items to the queue.\n */\nexport type ResetQueue<M extends Message> = () => readonly M[];\n\n/**\n * @internal\n */\nexport interface MessageQueueActions<M extends Message> {\n  popMessage: PopMessage;\n  hideMessage: HideMessage;\n  startTimer: StartVisibilityTimer;\n  stopTimer: StopVisibilityTimer;\n  restartTimer: RestartVisibilityTimer;\n  resetQueue: ResetQueue<M>;\n}\n\n/**\n * @internal\n */\nexport const MessageQueueActionsContext = createContext<\n  MessageQueueActions<Message>\n>({\n  popMessage() {\n    throw new Error(\n      \"Attempted to pop a message without initializing the MessageQueue component.\"\n    );\n  },\n  hideMessage() {\n    throw new Error(\n      \"Attempted to hide a message within initializing the MessageQueue component.\"\n    );\n  },\n  startTimer() {\n    throw new Error(\n      \"Attempted to start a message queue timer without initializing the MessageQueue component.\"\n    );\n  },\n  stopTimer() {\n    throw new Error(\n      \"Attempted to stop a message queue timer without initializing the MessageQueue component.\"\n    );\n  },\n  restartTimer() {\n    throw new Error(\n      \"Attempted to restart a message queue timer without initializing the MessageQueue component.\"\n    );\n  },\n  resetQueue() {\n    throw new Error(\n      \"Attempted to reset the message queue timer without initializing the MessageQueue component.\"\n    );\n  },\n});\n\n/**\n * This hook exposes some of the lower level actions for handling a message\n * queue if advanced behavior is desired.\n */\nexport function useMessageQueueActions<\n  M extends Message\n>(): MessageQueueActions<M> {\n  // I don't know how to type the createContext for a generic\n  return useContext(MessageQueueActionsContext) as MessageQueueActions<M>;\n}\n\n/**\n * @internal\n */\nexport const MessageQueueContext = createContext<readonly Message[]>([]);\n\n/**\n * This hook will allow you to get the current queue. This probably shouldn't be\n * used that much.\n */\nexport function useQueue<M extends Message>(): readonly M[] {\n  return useContext(MessageQueueContext) as readonly M[];\n}\n"]},"metadata":{},"sourceType":"module"}