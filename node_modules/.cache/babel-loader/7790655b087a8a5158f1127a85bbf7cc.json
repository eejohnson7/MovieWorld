{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useContext, useEffect, useMemo, useState } from \"react\";\nimport { noop } from \"./utils\";\nvar context = createContext({\n  root: false,\n  menubar: false,\n  menuitem: false,\n  activeId: \"\",\n  setActiveId: noop,\n  animatedOnce: false,\n  setAnimatedOnce: noop\n});\ncontext.displayName = \"MenuBar\";\nvar Provider = context.Provider;\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport function useMenuBarContext() {\n  return useContext(context);\n}\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport function MenuBarProvider(_a) {\n  var children = _a.children,\n    _b = _a.root,\n    root = _b === void 0 ? true : _b,\n    _c = _a.defaultActiveId,\n    defaultActiveId = _c === void 0 ? \"\" : _c,\n    hoverTimeout = _a.hoverTimeout;\n  var menubar = useMenuBarContext().menubar;\n  var _d = __read(useState(defaultActiveId), 2),\n    activeId = _d[0],\n    setActiveId = _d[1];\n  var _e = __read(useState(!!defaultActiveId), 2),\n    animatedOnce = _e[0],\n    setAnimatedOnce = _e[1];\n  var value = useMemo(function () {\n    return {\n      root: root,\n      menubar: root || menubar,\n      menuitem: true,\n      activeId: activeId,\n      setActiveId: setActiveId,\n      hoverTimeout: hoverTimeout,\n      animatedOnce: animatedOnce,\n      setAnimatedOnce: setAnimatedOnce\n    };\n  }, [activeId, animatedOnce, hoverTimeout, menubar, root]);\n  useEffect(function () {\n    if (!activeId) {\n      setAnimatedOnce(false);\n    }\n  }, [activeId]);\n  return _jsx(Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,aAAa,EAAEC,UAAU,EAAEC,SAAS,EAAEC,OAAO,EAAEC,QAAQ,QAAQ,OAAO;AAC/E,SAASC,IAAI,QAAQ,SAAS;AAsE9B,IAAMC,OAAO,GAAGN,aAAa,CAAiB;EAC5CO,IAAI,EAAE,KAAK;EACXC,OAAO,EAAE,KAAK;EACdC,QAAQ,EAAE,KAAK;EACfC,QAAQ,EAAE,EAAE;EACZC,WAAW,EAAEN,IAAI;EACjBO,YAAY,EAAE,KAAK;EACnBC,eAAe,EAAER;CAClB,CAAC;AACFC,OAAO,CAACQ,WAAW,GAAG,SAAS;AACvB,YAAQ,GAAKR,OAAO,SAAZ;AAEhB;;;;AAIA,OAAM,SAAUS,iBAAiB;EAC/B,OAAOd,UAAU,CAACK,OAAO,CAAC;AAC5B;AAiCA;;;;AAIA,OAAM,SAAUU,eAAe,CAACC,EAKT;MAJrBC,QAAQ;IACRC,YAAW;IAAXZ,IAAI,mBAAG,IAAI;IACXa,uBAAoB;IAApBC,eAAe,mBAAG,EAAE;IACpBC,YAAY;EAEJ,WAAO,GAAKP,iBAAiB,EAAE,QAAxB;EACT,gBAA0BX,QAAQ,CAACiB,eAAe,CAAC;IAAlDX,QAAQ;IAAEC,WAAW,QAA6B;EACnD,gBAAkCP,QAAQ,CAAC,CAAC,CAACiB,eAAe,CAAC;IAA5DT,YAAY;IAAEC,eAAe,QAA+B;EACnE,IAAMU,KAAK,GAAGpB,OAAO,CACnB;IAAM,OAAC;MACLI,IAAI;MACJC,OAAO,EAAED,IAAI,IAAIC,OAAO;MACxBC,QAAQ,EAAE,IAAI;MACdC,QAAQ;MACRC,WAAW;MACXW,YAAY;MACZV,YAAY;MACZC,eAAe;KAChB;EATK,CASJ,EACF,CAACH,QAAQ,EAAEE,YAAY,EAAEU,YAAY,EAAEd,OAAO,EAAED,IAAI,CAAC,CACtD;EACDL,SAAS,CAAC;IACR,IAAI,CAACQ,QAAQ,EAAE;MACbG,eAAe,CAAC,KAAK,CAAC;;EAE1B,CAAC,EAAE,CAACH,QAAQ,CAAC,CAAC;EAEd,OAAOc,KAACC,QAAQ;IAACF,KAAK,EAAEA;EAAK;IAAAL,UAAGA;EAAQ,GAAY;AACtD","names":["createContext","useContext","useEffect","useMemo","useState","noop","context","root","menubar","menuitem","activeId","setActiveId","animatedOnce","setAnimatedOnce","displayName","useMenuBarContext","MenuBarProvider","_a","children","_b","_c","defaultActiveId","hoverTimeout","value","_jsx","Provider"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/menu/src/MenuBarProvider.tsx"],"sourcesContent":["import type { Dispatch, ReactElement, ReactNode, SetStateAction } from \"react\";\nimport { createContext, useContext, useEffect, useMemo, useState } from \"react\";\nimport { noop } from \"./utils\";\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport interface HoverableMenuBar {\n  /**\n   * When this is provided and a number greater than 0, this will allow the\n   * menus to become visible on hover without clicking a `MenuItemButton`\n   * beforehand. Instead, hovering over a `MenuItemButton` for this time in\n   * milliseconds will display the `Menu`.\n   */\n  hoverTimeout?: number;\n}\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport interface MenuBarContext extends HoverableMenuBar {\n  /**\n   * Boolean if the `MenuBar` is the top-most `MenuBar`. This is just used so\n   * that the top-most `DropdownMenu` can render as a `MenuItemButton` instead\n   * of a `MenuButton` while maintaining the dropdown icon and keyboard behavior\n   * of a `MenuButton`.\n   */\n  root: boolean;\n\n  /**\n   * Boolean if the `MenuBar` functionality is enabled.\n   */\n  menubar: boolean;\n\n  /**\n   * This isn't tied directly to a `MenuBar`, but this is used to determine if\n   * there is a parent `Menu` so the `DropdownMenu` can be rendered as a\n   * `MenuItemButton` instead of a `MenuButton`.\n   */\n  menuitem: boolean;\n\n  /**\n   * This is the current DOM id for the `MenuButton` or `MenuItemButton` this is\n   * currently visible within the `MenuBar`. If the `MenuBar` behavior has not\n   * been enabled or no `Menu` are visible, this will be an empty string;\n   */\n  activeId: string;\n\n  /**\n   * This is used to manually set the {@link activeId} based on menu visibility.\n   */\n  setActiveId: Dispatch<SetStateAction<string>>;\n\n  /**\n   * Boolean if at least one menu has finished the enter animation. This is used\n   * to disable repeating the enter animation once the user is in hover mode\n   * since it is distracting to have to wait `0.2ms` each time a new menu gains\n   * visibility.\n   */\n  animatedOnce: boolean;\n\n  /**\n   * This should be called with the menu's `onEntered` option so that the\n   * {@link animatedOnce} flag can be set to `true`. Once the {@link activeId}\n   * becomes an empty string (no visible menus), this should be called again\n   * with `false` so that the menu animations are visible.\n   */\n  setAnimatedOnce: Dispatch<SetStateAction<boolean>>;\n}\n\nconst context = createContext<MenuBarContext>({\n  root: false,\n  menubar: false,\n  menuitem: false,\n  activeId: \"\",\n  setActiveId: noop,\n  animatedOnce: false,\n  setAnimatedOnce: noop,\n});\ncontext.displayName = \"MenuBar\";\nconst { Provider } = context;\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport function useMenuBarContext(): Readonly<MenuBarContext> {\n  return useContext(context);\n}\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport interface MenuBarProviderProps extends HoverableMenuBar {\n  /**\n   * This should be set to `false` if this is a child of another `Menu`.\n   *\n   * @defaultValue `true`\n   * @see {@link MenuBarContext.root}\n   */\n  root?: boolean;\n\n  /**\n   * This is used so that when the user is moving through the `MenuBar` while a\n   * menu is opened, pressing the `ArrowLeft` or `ArrowRight` key will:\n   * - close the current menu\n   * - focus the next menu's toggle element\n   * - open the next menu's toggle element\n   * - move focus to the first menu item\n   *\n   * This should be set to the `Menu`'s id in that the example above. Otherwise\n   * it should be omitted.\n   *\n   * @defaultValue `\"\"`\n   */\n  defaultActiveId?: string;\n\n  children: ReactNode;\n}\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport function MenuBarProvider({\n  children,\n  root = true,\n  defaultActiveId = \"\",\n  hoverTimeout,\n}: MenuBarProviderProps): ReactElement {\n  const { menubar } = useMenuBarContext();\n  const [activeId, setActiveId] = useState(defaultActiveId);\n  const [animatedOnce, setAnimatedOnce] = useState(!!defaultActiveId);\n  const value = useMemo<MenuBarContext>(\n    () => ({\n      root,\n      menubar: root || menubar,\n      menuitem: true,\n      activeId,\n      setActiveId,\n      hoverTimeout,\n      animatedOnce,\n      setAnimatedOnce,\n    }),\n    [activeId, animatedOnce, hoverTimeout, menubar, root]\n  );\n  useEffect(() => {\n    if (!activeId) {\n      setAnimatedOnce(false);\n    }\n  }, [activeId]);\n\n  return <Provider value={value}>{children}</Provider>;\n}\n"]},"metadata":{},"sourceType":"module"}