{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useEffect, useState } from \"react\";\nimport { SkipToMainContent } from \"@react-md/link\";\nimport { LayoutAppBar } from \"./LayoutAppBar\";\nimport { LayoutMain } from \"./LayoutMain\";\nimport { LayoutNavigation } from \"./LayoutNavigation\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { MiniLayoutWrapper } from \"./MiniLayoutWrapper\";\nimport { isMiniLayout } from \"./utils\";\n/**\n * The only purpose of this component is to render the children and different\n * parts of the `Layout` depending on the current layout that is active. Since\n * the `Layout` component defines the provider itself, this has to be a child\n * component to get the resolved `layout` type.\n *\n * @remarks \\@since 2.7.0\n * @internal\n */\nexport function LayoutChildren(_a) {\n  var _b = _a.id,\n    id = _b === void 0 ? \"layout\" : _b,\n    propAppBar = _a.appBar,\n    appBarProps = _a.appBarProps,\n    customTitle = _a.customTitle,\n    title = _a.title,\n    titleProps = _a.titleProps,\n    navToggle = _a.navToggle,\n    navToggleProps = _a.navToggleProps,\n    _c = _a.navAfterAppBar,\n    navAfterAppBar = _c === void 0 ? false : _c,\n    propNav = _a.nav,\n    miniNav = _a.miniNav,\n    miniNavItems = _a.miniNavItems,\n    miniWrapperProps = _a.miniWrapperProps,\n    navHeader = _a.navHeader,\n    navHeaderProps = _a.navHeaderProps,\n    navHeaderTitle = _a.navHeaderTitle,\n    navHeaderTitleProps = _a.navHeaderTitleProps,\n    closeNav = _a.closeNav,\n    closeNavProps = _a.closeNavProps,\n    treeProps = _a.treeProps,\n    navProps = _a.navProps,\n    skipProps = _a.skipProps,\n    mainProps = _a.mainProps,\n    children = _a.children;\n  var mainId = (mainProps === null || mainProps === void 0 ? void 0 : mainProps.id) || \"\".concat(id, \"-main\");\n  var _d = useLayoutConfig(),\n    layout = _d.layout,\n    visible = _d.visible,\n    fixedAppBar = _d.fixedAppBar;\n  var mini = isMiniLayout(layout);\n  var _e = __read(useState(visible), 2),\n    miniHidden = _e[0],\n    setMiniHidden = _e[1];\n  // when the layout changes, the hidden state for the mini drawer must also be\n  // updated\n  useEffect(function () {\n    setMiniHidden(visible);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [layout]);\n  var appBar = propAppBar;\n  if (typeof appBar === \"undefined\") {\n    appBar = _jsx(LayoutAppBar, __assign({}, appBarProps, {\n      customTitle: customTitle,\n      title: title,\n      titleProps: titleProps,\n      navToggle: navToggle,\n      navToggleProps: navToggleProps\n    }));\n  }\n  var nav = propNav;\n  if (typeof nav === \"undefined\") {\n    nav = _jsx(LayoutNavigation, __assign({\n      header: navHeader,\n      headerProps: navHeaderProps,\n      headerTitle: navHeaderTitle,\n      headerTitleProps: navHeaderTitleProps,\n      closeNav: closeNav,\n      closeNavProps: closeNavProps,\n      treeProps: treeProps\n    }, navProps, {\n      onEntered: function (appearing) {\n        var _a;\n        (_a = navProps === null || navProps === void 0 ? void 0 : navProps.onEntered) === null || _a === void 0 ? void 0 : _a.call(navProps, appearing);\n        setMiniHidden(true);\n      },\n      onExit: function () {\n        var _a;\n        (_a = navProps === null || navProps === void 0 ? void 0 : navProps.onExit) === null || _a === void 0 ? void 0 : _a.call(navProps);\n        setMiniHidden(false);\n      }\n    }));\n  }\n  return _jsxs(_Fragment, {\n    children: [_jsx(SkipToMainContent, __assign({}, skipProps, {\n      mainId: mainId\n    })), navAfterAppBar && appBar, nav, !navAfterAppBar && appBar, _jsx(MiniLayoutWrapper, __assign({\n      mini: mini,\n      miniNav: miniNav,\n      miniHidden: miniHidden,\n      containerProps: miniWrapperProps,\n      miniNavItems: miniNavItems,\n      treeProps: treeProps,\n      header: navHeader,\n      headerProps: navHeaderProps,\n      headerTitle: navHeaderTitle,\n      headerTitleProps: navHeaderTitleProps,\n      closeNav: closeNav,\n      closeNavProps: closeNavProps\n    }, {\n      children: _jsx(LayoutMain, __assign({\n        headerOffset: fixedAppBar,\n        mini: mini,\n        miniHidden: miniHidden\n      }, mainProps, {\n        id: mainId\n      }, {\n        children: children\n      }))\n    }))]\n  });\n}","map":{"version":3,"mappings":"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","names":["useEffect","useState","SkipToMainContent","LayoutAppBar","LayoutMain","LayoutNavigation","useLayoutConfig","MiniLayoutWrapper","isMiniLayout","LayoutChildren","_a","_b","id","propAppBar","appBarProps","customTitle","title","titleProps","navToggle","navToggleProps","_c","navAfterAppBar","propNav","miniNav","miniNavItems","miniWrapperProps","navHeader","navHeaderProps","navHeaderTitle","navHeaderTitleProps","closeNav","closeNavProps","treeProps","navProps","skipProps","mainProps","children","mainId","layout","visible","fixedAppBar","mini","miniHidden","setMiniHidden","appBar","_jsx","nav","header","headerProps","headerTitle","headerTitleProps","onEntered","appearing","onExit","_jsxs","containerProps","headerOffset"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/layout/src/LayoutChildren.tsx"],"sourcesContent":["import type { HTMLAttributes, ReactElement, ReactNode } from \"react\";\nimport { useEffect, useState } from \"react\";\nimport type { SkipToMainContentProps } from \"@react-md/link\";\nimport { SkipToMainContent } from \"@react-md/link\";\nimport type { BaseTreeItem, TreeData } from \"@react-md/tree\";\nimport type { PropsWithRef } from \"@react-md/utils\";\n\nimport type { FlattenedLayoutComponentConfiguration } from \"./Layout\";\nimport { LayoutAppBar } from \"./LayoutAppBar\";\nimport type { LayoutMainProps } from \"./LayoutMain\";\nimport { LayoutMain } from \"./LayoutMain\";\nimport { LayoutNavigation } from \"./LayoutNavigation\";\nimport { useLayoutConfig } from \"./LayoutProvider\";\nimport { MiniLayoutWrapper } from \"./MiniLayoutWrapper\";\nimport type { LayoutNavigationItem } from \"./types\";\nimport { isMiniLayout } from \"./utils\";\n\n/**\n * This used to just be the `LayoutProps` but was split up to help with mini\n * layouts.\n *\n * @remarks \\@since 2.7.0\n */\nexport interface LayoutChildrenProps<\n  T extends BaseTreeItem = LayoutNavigationItem\n> extends FlattenedLayoutComponentConfiguration<T> {\n  /**\n   * The base id to use for everything within the layout component. The `id`\n   * will be applied to:\n   *\n   * - the `LayoutAppBar` as `${id}-header`\n   * - the `AppBarTitle` as `${id}-title`\n   * - the `LayoutNavToggle` as `${id}-nav-toggle`\n   * - the `LayoutMain` element as `${id}-main`\n   */\n  id?: string;\n\n  /**\n   * Boolean if the main app bar should appear after the navigation component.\n   * It is generally recommended to enable this prop if the navigation component\n   * as a focusable element in the header since it will have a better tab focus\n   * order.\n   */\n  navAfterAppBar?: boolean;\n\n  /**\n   * Any optional props to provide to the `<main>` element of the page.\n   */\n  mainProps?: PropsWithRef<LayoutMainProps, HTMLDivElement>;\n\n  /**\n   * Any additional props to provide to the `<SkipToMainContent />` link that is\n   * automatically rendered in the layout.\n   */\n  skipProps?: Omit<SkipToMainContentProps, \"mainId\">;\n\n  /**\n   * An optional tree to use for the mini navigation pane since the default\n   * behavior of rendering mini tree items might hide content in an undesirable\n   * way.\n   *\n   * @remarks \\@since 2.7.0\n   * @see {@link defaultMiniNavigationItemRenderer} for more information\n   */\n  miniNavItems?: TreeData<T>;\n\n  /**\n   * This prop allows you to provide additional props to the `<div>` surrounding\n   * the `LayoutMain` and mini `LayoutNavigation` components.\n   *\n   * Note: This additional `<div>` will only be rendered if:\n   * - at least one of the provided layout types are `mini`\n   * - the layout is not using a fixed app bar\n   * - the `miniNav` prop has not been defined\n   * - `treeProps` have been provided\n   *\n   * @remarks \\@since 2.8.3\n   * @remarks \\@since 2.9.1 This will render if any provided layout type is `mini`.\n   */\n  miniWrapperProps?: PropsWithRef<\n    HTMLAttributes<HTMLDivElement>,\n    HTMLDivElement\n  >;\n\n  /**\n   * The children to display within the layout. This is pretty much required\n   * since you'll have an empty app otherwise, but it's left as optional just\n   * for prototyping purposes.\n   */\n  children?: ReactNode;\n}\n\n/**\n * The only purpose of this component is to render the children and different\n * parts of the `Layout` depending on the current layout that is active. Since\n * the `Layout` component defines the provider itself, this has to be a child\n * component to get the resolved `layout` type.\n *\n * @remarks \\@since 2.7.0\n * @internal\n */\nexport function LayoutChildren({\n  id = \"layout\",\n  appBar: propAppBar,\n  appBarProps,\n  customTitle,\n  title,\n  titleProps,\n  navToggle,\n  navToggleProps,\n  navAfterAppBar = false,\n  nav: propNav,\n  miniNav,\n  miniNavItems,\n  miniWrapperProps,\n  navHeader,\n  navHeaderProps,\n  navHeaderTitle,\n  navHeaderTitleProps,\n  closeNav,\n  closeNavProps,\n  treeProps,\n  navProps,\n  skipProps,\n  mainProps,\n  children,\n}: LayoutChildrenProps): ReactElement {\n  const mainId = mainProps?.id || `${id}-main`;\n  const { layout, visible, fixedAppBar } = useLayoutConfig();\n  const mini = isMiniLayout(layout);\n  const [miniHidden, setMiniHidden] = useState(visible);\n  // when the layout changes, the hidden state for the mini drawer must also be\n  // updated\n  useEffect(() => {\n    setMiniHidden(visible);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [layout]);\n\n  let appBar = propAppBar;\n  if (typeof appBar === \"undefined\") {\n    appBar = (\n      <LayoutAppBar\n        {...appBarProps}\n        customTitle={customTitle}\n        title={title}\n        titleProps={titleProps}\n        navToggle={navToggle}\n        navToggleProps={navToggleProps}\n      />\n    );\n  }\n\n  let nav = propNav;\n  if (typeof nav === \"undefined\") {\n    nav = (\n      <LayoutNavigation\n        header={navHeader}\n        headerProps={navHeaderProps}\n        headerTitle={navHeaderTitle}\n        headerTitleProps={navHeaderTitleProps}\n        closeNav={closeNav}\n        closeNavProps={closeNavProps}\n        treeProps={treeProps}\n        {...navProps}\n        onEntered={(appearing) => {\n          navProps?.onEntered?.(appearing);\n          setMiniHidden(true);\n        }}\n        onExit={() => {\n          navProps?.onExit?.();\n          setMiniHidden(false);\n        }}\n      />\n    );\n  }\n\n  return (\n    <>\n      <SkipToMainContent {...skipProps} mainId={mainId} />\n      {navAfterAppBar && appBar}\n      {nav}\n      {!navAfterAppBar && appBar}\n      <MiniLayoutWrapper\n        mini={mini}\n        miniNav={miniNav}\n        miniHidden={miniHidden}\n        containerProps={miniWrapperProps}\n        miniNavItems={miniNavItems}\n        treeProps={treeProps}\n        header={navHeader}\n        headerProps={navHeaderProps}\n        headerTitle={navHeaderTitle}\n        headerTitleProps={navHeaderTitleProps}\n        closeNav={closeNav}\n        closeNavProps={closeNavProps}\n      >\n        <LayoutMain\n          headerOffset={fixedAppBar}\n          mini={mini}\n          miniHidden={miniHidden}\n          {...mainProps}\n          id={mainId}\n        >\n          {children}\n        </LayoutMain>\n      </MiniLayoutWrapper>\n    </>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}