{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useEffect } from \"react\";\nimport { Link } from \"@react-md/link\";\nimport { getItemsFrom, useTreeItemExpansion } from \"@react-md/tree\";\n/**\n * @internal\n */\nvar getParentIds = function (itemId, navItems) {\n  return getItemsFrom(navItems, itemId).map(function (_a) {\n    var itemId = _a.itemId;\n    return itemId;\n  });\n};\n/**\n * This is used to disable the item select and multi item select functionality\n * since only one id can be selected at a time, and it'll always be the current\n * pathname's itemId\n *\n * @internal\n */\nvar noop = function () {\n  // do nothing\n};\n/**\n * This used to just be `pathname.replace(/\\?.*$/, \"\")` but that can apparently\n * cause performance issues or a DoS attack if the pathname contains multiple\n * ?`?` (shouldn't really be possible though)\n *\n * @remarks \\@since 2.9.0\n */\nvar removeQueryParams = function (pathname) {\n  var i = pathname.indexOf(\"?\");\n  if (i === -1) {\n    return pathname;\n  }\n  return pathname.substring(0, i);\n};\n/**\n * This is a pretty reasonable default implementation for having a navigation\n * tree within the Layout component. The way it'll work is that the current\n * route will be the only selected item within the tree. When the pathname\n * changes, the selectedIds will be updated to only be the current pathname once\n * again.\n *\n * This means that you can use whatever routing library or history provider that\n * ensures that your layout re-renders on a path change.\n *\n * @see LayoutNavigationTree for description of the navItems\n * @param navItems - All the navigation items within your layout. This is used\n * for determining which parent tree items should be expanded when the route\n * changes so the current route won't be hidden from view. This sort of flow\n * happens if you have a link outside of the navigation tree.\n * @param pathname - The current pathname\n * @param linkComponent - The link component to use within the navigation tree\n * for any item that has a `to` or `href` attribute. This defaults to the `Link`\n * from `@react-md/link` but should be changed to whatever link component you\n * need if using a routing library like `react-router`.\n * @returns the required `Tree` selection and expansion state and handlers that\n * should be passed to the `Layout` component.\n */\nexport function useLayoutNavigation(navItems, pathname, linkComponent) {\n  if (linkComponent === void 0) {\n    linkComponent = Link;\n  }\n  var itemId = removeQueryParams(pathname);\n  var _a = useTreeItemExpansion(function () {\n      return getParentIds(itemId, navItems);\n    }),\n    expandedIds = _a.expandedIds,\n    onItemExpansion = _a.onItemExpansion,\n    onMultiItemExpansion = _a.onMultiItemExpansion;\n  useEffect(function () {\n    onMultiItemExpansion(function (prevExpandedIds) {\n      var nextExpandedIds = __spreadArray([], __read(new Set(__spreadArray(__spreadArray([], __read(prevExpandedIds), false), __read(getParentIds(itemId, navItems)), false))), false);\n      if (nextExpandedIds.length !== prevExpandedIds.length) {\n        return nextExpandedIds;\n      }\n      var prevSorted = prevExpandedIds.slice().sort();\n      var nextSorted = nextExpandedIds.slice().sort();\n      return nextSorted.some(function (itemId, index) {\n        return itemId !== prevSorted[index];\n      }) ? nextSorted : prevSorted;\n    });\n  }, [itemId, navItems, onMultiItemExpansion]);\n  return {\n    navItems: navItems,\n    multiSelect: false,\n    selectedIds: [itemId],\n    onItemSelect: noop,\n    onMultiItemSelect: noop,\n    expandedIds: expandedIds,\n    onItemExpansion: onItemExpansion,\n    onMultiItemExpansion: onMultiItemExpansion,\n    linkComponent: linkComponent\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,SAAS,QAAQ,OAAO;AACjC,SAASC,IAAI,QAAQ,gBAAgB;AAQrC,SAASC,YAAY,EAAEC,oBAAoB,QAAQ,gBAAgB;AAsBnE;;;AAGA,IAAMC,YAAY,GAAG,UACnBC,MAAkB,EAClBC,QAAgC;EAEhC,mBAAY,CAACA,QAAQ,EAAED,MAAM,CAAC,CAACE,GAAG,CAAC,UAACC,EAAU;QAARH,MAAM;IAAO,aAAM;EAAN,CAAM,CAAC;AAA1D,CAA0D;AAE5D;;;;;;;AAOA,IAAMI,IAAI,GAAG;EACX;AACF,CAAC;AAED;;;;;;;AAOA,IAAMC,iBAAiB,GAAG,UAACC,QAAgB;EACzC,IAAMC,CAAC,GAAGD,QAAQ,CAACE,OAAO,CAAC,GAAG,CAAC;EAC/B,IAAID,CAAC,KAAK,CAAC,CAAC,EAAE;IACZ,OAAOD,QAAQ;;EAGjB,OAAOA,QAAQ,CAACG,SAAS,CAAC,CAAC,EAAEF,CAAC,CAAC;AACjC,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUG,mBAAmB,CAGjCT,QAAiC,EACjCK,QAAgB,EAChBK,aAAiC;EAAjC;IAAAA,oBAAiC;EAAA;EAEjC,IAAMX,MAAM,GAAGK,iBAAiB,CAACC,QAAQ,CAAC;EACpC,SACJR,oBAAoB,CAAC;MAAM,mBAAY,CAACE,MAAM,EAAEC,QAAQ,CAAC;IAA9B,CAA8B,CAAC;IADpDW,WAAW;IAAEC,eAAe;IAAEC,oBAAoB,0BACE;EAE5DnB,SAAS,CAAC;IACRmB,oBAAoB,CAAC,UAACC,eAAe;MACnC,IAAMC,eAAe,4BAChB,IAAIC,GAAG,wCAAKF,eAAe,kBAAKhB,YAAY,CAACC,MAAM,EAAEC,QAAQ,CAAC,UAAE,SACpE;MACD,IAAIe,eAAe,CAACE,MAAM,KAAKH,eAAe,CAACG,MAAM,EAAE;QACrD,OAAOF,eAAe;;MAGxB,IAAMG,UAAU,GAAGJ,eAAe,CAACK,KAAK,EAAE,CAACC,IAAI,EAAE;MACjD,IAAMC,UAAU,GAAGN,eAAe,CAACI,KAAK,EAAE,CAACC,IAAI,EAAE;MAEjD,OAAOC,UAAU,CAACC,IAAI,CAAC,UAACvB,MAAM,EAAEwB,KAAK;QAAK,aAAM,KAAKL,UAAU,CAACK,KAAK,CAAC;MAA5B,CAA4B,CAAC,GACnEF,UAAU,GACVH,UAAU;IAChB,CAAC,CAAC;EACJ,CAAC,EAAE,CAACnB,MAAM,EAAEC,QAAQ,EAAEa,oBAAoB,CAAC,CAAC;EAE5C,OAAO;IACLb,QAAQ;IACRwB,WAAW,EAAE,KAAK;IAClBC,WAAW,EAAE,CAAC1B,MAAM,CAAC;IACrB2B,YAAY,EAAEvB,IAAI;IAClBwB,iBAAiB,EAAExB,IAAI;IACvBQ,WAAW;IACXC,eAAe;IACfC,oBAAoB;IACpBH,aAAa;GACd;AACH","names":["useEffect","Link","getItemsFrom","useTreeItemExpansion","getParentIds","itemId","navItems","map","_a","noop","removeQueryParams","pathname","i","indexOf","substring","useLayoutNavigation","linkComponent","expandedIds","onItemExpansion","onMultiItemExpansion","prevExpandedIds","nextExpandedIds","Set","length","prevSorted","slice","sort","nextSorted","some","index","multiSelect","selectedIds","onItemSelect","onMultiItemSelect"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/layout/src/useLayoutNavigation.ts"],"sourcesContent":["import type { ElementType } from \"react\";\nimport { useEffect } from \"react\";\nimport { Link } from \"@react-md/link\";\nimport type {\n  BaseTreeItem,\n  TreeData,\n  TreeItemExpansion,\n  TreeItemId,\n  TreeItemSelection,\n} from \"@react-md/tree\";\nimport { getItemsFrom, useTreeItemExpansion } from \"@react-md/tree\";\n\nimport type { LayoutNavigationItem, LayoutNavigationTree } from \"./types\";\n\nexport interface LayoutNavigationState<\n  T extends BaseTreeItem = LayoutNavigationItem\n> extends TreeItemSelection,\n    TreeItemExpansion {\n  /**\n   * The navigation items to use that will be passed to the `Tree` component\n   * from `@react-md/tree`\n   */\n  navItems: LayoutNavigationTree<T>;\n\n  /**\n   * The link component to use when a nav item is clicked. This defaults to the\n   * `Link` component from `@react-md/link`, but can also be a `Link` from\n   * `react-router` or another routing library.\n   */\n  linkComponent: ElementType;\n}\n\n/**\n * @internal\n */\nconst getParentIds = (\n  itemId: TreeItemId,\n  navItems: TreeData<BaseTreeItem>\n): readonly TreeItemId[] =>\n  getItemsFrom(navItems, itemId).map(({ itemId }) => itemId);\n\n/**\n * This is used to disable the item select and multi item select functionality\n * since only one id can be selected at a time, and it'll always be the current\n * pathname's itemId\n *\n * @internal\n */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * This used to just be `pathname.replace(/\\?.*$/, \"\")` but that can apparently\n * cause performance issues or a DoS attack if the pathname contains multiple\n * ?`?` (shouldn't really be possible though)\n *\n * @remarks \\@since 2.9.0\n */\nconst removeQueryParams = (pathname: string): string => {\n  const i = pathname.indexOf(\"?\");\n  if (i === -1) {\n    return pathname;\n  }\n\n  return pathname.substring(0, i);\n};\n\n/**\n * This is a pretty reasonable default implementation for having a navigation\n * tree within the Layout component. The way it'll work is that the current\n * route will be the only selected item within the tree. When the pathname\n * changes, the selectedIds will be updated to only be the current pathname once\n * again.\n *\n * This means that you can use whatever routing library or history provider that\n * ensures that your layout re-renders on a path change.\n *\n * @see LayoutNavigationTree for description of the navItems\n * @param navItems - All the navigation items within your layout. This is used\n * for determining which parent tree items should be expanded when the route\n * changes so the current route won't be hidden from view. This sort of flow\n * happens if you have a link outside of the navigation tree.\n * @param pathname - The current pathname\n * @param linkComponent - The link component to use within the navigation tree\n * for any item that has a `to` or `href` attribute. This defaults to the `Link`\n * from `@react-md/link` but should be changed to whatever link component you\n * need if using a routing library like `react-router`.\n * @returns the required `Tree` selection and expansion state and handlers that\n * should be passed to the `Layout` component.\n */\nexport function useLayoutNavigation<\n  T extends BaseTreeItem = LayoutNavigationItem\n>(\n  navItems: LayoutNavigationTree<T>,\n  pathname: string,\n  linkComponent: ElementType = Link\n): LayoutNavigationState<T> {\n  const itemId = removeQueryParams(pathname);\n  const { expandedIds, onItemExpansion, onMultiItemExpansion } =\n    useTreeItemExpansion(() => getParentIds(itemId, navItems));\n\n  useEffect(() => {\n    onMultiItemExpansion((prevExpandedIds) => {\n      const nextExpandedIds = [\n        ...new Set([...prevExpandedIds, ...getParentIds(itemId, navItems)]),\n      ];\n      if (nextExpandedIds.length !== prevExpandedIds.length) {\n        return nextExpandedIds;\n      }\n\n      const prevSorted = prevExpandedIds.slice().sort();\n      const nextSorted = nextExpandedIds.slice().sort();\n\n      return nextSorted.some((itemId, index) => itemId !== prevSorted[index])\n        ? nextSorted\n        : prevSorted;\n    });\n  }, [itemId, navItems, onMultiItemExpansion]);\n\n  return {\n    navItems,\n    multiSelect: false,\n    selectedIds: [itemId],\n    onItemSelect: noop,\n    onMultiItemSelect: noop,\n    expandedIds,\n    onItemExpansion,\n    onMultiItemExpansion,\n    linkComponent,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}