{"ast":null,"code":"import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\nvar FALLBACK_DOM_RECT = {\n  x: 0,\n  y: 0,\n  height: 0,\n  width: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  toJSON: function () {\n    // do nothing\n  }\n};\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\nexport function getFixedPosition(_a) {\n  var _b;\n  var container = _a.container,\n    element = _a.element,\n    _c = _a.anchor,\n    anchor = _c === void 0 ? BELOW_CENTER_ANCHOR : _c,\n    initialX = _a.initialX,\n    initialY = _a.initialY,\n    _d = _a.vwMargin,\n    vwMargin = _d === void 0 ? 16 : _d,\n    _e = _a.vhMargin,\n    vhMargin = _e === void 0 ? 16 : _e,\n    _f = _a.xMargin,\n    xMargin = _f === void 0 ? 0 : _f,\n    _g = _a.yMargin,\n    yMargin = _g === void 0 ? 0 : _g,\n    _h = _a.width,\n    widthType = _h === void 0 ? \"auto\" : _h,\n    _j = _a.preventOverlap,\n    preventOverlap = _j === void 0 ? false : _j,\n    _k = _a.transformOrigin,\n    transformOrigin = _k === void 0 ? false : _k,\n    _l = _a.disableSwapping,\n    propDisableSwapping = _l === void 0 ? false : _l,\n    _m = _a.disableVHBounds,\n    disableVHBounds = _m === void 0 ? false : _m;\n  container = findSizingContainer(container);\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error('Unable to use a calculated width when the horizontal anchor is not `\"center\"`.');\n    }\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error('Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`');\n    }\n  }\n  if (!element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y\n    };\n  }\n  var containerRect = (_b = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _b !== void 0 ? _b : FALLBACK_DOM_RECT;\n  var vh = getViewportSize(\"height\");\n  var vw = getViewportSize(\"width\");\n  var _o = getElementRect(element),\n    height = _o.height,\n    elWidth = _o.width;\n  if (disableVHBounds) {\n    var dialog = element.closest(\"[role='dialog']\");\n    if (!dialog) {\n      initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;\n    }\n  }\n  var disableSwapping = propDisableSwapping || !container;\n  var _p = createHorizontalPosition({\n      x: anchor.x,\n      vw: vw,\n      vwMargin: vwMargin,\n      xMargin: xMargin,\n      width: widthType,\n      elWidth: elWidth,\n      initialX: initialX,\n      containerRect: containerRect,\n      disableSwapping: disableSwapping\n    }),\n    left = _p.left,\n    right = _p.right,\n    width = _p.width,\n    minWidth = _p.minWidth,\n    actualX = _p.actualX;\n  var _q = createVerticalPosition({\n      y: anchor.y,\n      vh: vh,\n      vhMargin: vhMargin,\n      yMargin: yMargin,\n      initialY: initialY,\n      elHeight: height,\n      containerRect: containerRect,\n      disableSwapping: disableSwapping,\n      preventOverlap: preventOverlap,\n      disableVHBounds: disableVHBounds\n    }),\n    top = _q.top,\n    bottom = _q.bottom,\n    actualY = _q.actualY;\n  return {\n    actualX: actualX,\n    actualY: actualY,\n    style: {\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: width,\n      minWidth: minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin ? getTransformOrigin({\n        x: actualX,\n        y: actualY\n      }) : undefined\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["BELOW_CENTER_ANCHOR","createHorizontalPosition","createVerticalPosition","findSizingContainer","getElementRect","getTransformOrigin","getViewportSize","FALLBACK_DOM_RECT","x","y","height","width","left","right","top","bottom","toJSON","getFixedPosition","_a","container","element","_c","anchor","initialX","initialY","_d","vwMargin","_e","vhMargin","_f","xMargin","_g","yMargin","_h","widthType","_j","preventOverlap","_k","transformOrigin","_l","propDisableSwapping","_m","disableVHBounds","process","env","NODE_ENV","Error","actualX","actualY","containerRect","getBoundingClientRect","vh","vw","elWidth","dialog","closest","window","scrollY","disableSwapping","minWidth","elHeight","style","position","undefined"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/positioning/getFixedPosition.ts"],"sourcesContent":["import { BELOW_CENTER_ANCHOR } from \"./constants\";\nimport { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\nimport type { FixedPosition, FixedPositionOptions } from \"./types\";\n\n/**\n * This is used when there is no `container` element so that some styles can\n * still be created. The main use-case for this is context menus and when the\n * `initialX` and `initialY` options have been provided.\n *\n * @internal\n * @remarks \\@since 5.0.0\n */\nconst FALLBACK_DOM_RECT: DOMRect = {\n  x: 0,\n  y: 0,\n  height: 0,\n  width: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n  toJSON() {\n    // do nothing\n  },\n};\n\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\nexport function getFixedPosition({\n  container,\n  element,\n  anchor = BELOW_CENTER_ANCHOR,\n  initialX,\n  initialY,\n  vwMargin = 16,\n  vhMargin = 16,\n  xMargin = 0,\n  yMargin = 0,\n  width: widthType = \"auto\",\n  preventOverlap = false,\n  transformOrigin = false,\n  disableSwapping: propDisableSwapping = false,\n  disableVHBounds = false,\n}: FixedPositionOptions): FixedPosition {\n  container = findSizingContainer(container);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error(\n        'Unable to use a calculated width when the horizontal anchor is not `\"center\"`.'\n      );\n    }\n\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error(\n        'Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`'\n      );\n    }\n  }\n\n  if (!element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y,\n    };\n  }\n\n  const containerRect = container?.getBoundingClientRect() ?? FALLBACK_DOM_RECT;\n  const vh = getViewportSize(\"height\");\n  const vw = getViewportSize(\"width\");\n\n  const { height, width: elWidth } = getElementRect(element);\n  if (disableVHBounds) {\n    const dialog = element.closest(\"[role='dialog']\");\n    if (!dialog) {\n      initialY = (initialY ?? 0) + window.scrollY;\n    }\n  }\n\n  const disableSwapping = propDisableSwapping || !container;\n\n  const { left, right, width, minWidth, actualX } = createHorizontalPosition({\n    x: anchor.x,\n    vw,\n    vwMargin,\n    xMargin,\n    width: widthType,\n    elWidth,\n    initialX,\n    containerRect,\n    disableSwapping,\n  });\n  const { top, bottom, actualY } = createVerticalPosition({\n    y: anchor.y,\n    vh,\n    vhMargin,\n    yMargin,\n    initialY,\n    elHeight: height,\n    containerRect,\n    disableSwapping,\n    preventOverlap,\n    disableVHBounds,\n  });\n\n  return {\n    actualX,\n    actualY,\n    style: {\n      left,\n      top,\n      right,\n      bottom,\n      width,\n      minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin\n        ? getTransformOrigin({ x: actualX, y: actualY })\n        : undefined,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}