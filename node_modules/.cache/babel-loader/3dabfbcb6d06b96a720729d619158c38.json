{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useState } from \"react\";\nexport function useIndeterminateChecked(values, _a) {\n  var _b;\n  var _c = _a === void 0 ? {} : _a,\n    _d = _c.menu,\n    menu = _d === void 0 ? false : _d,\n    propOnChange = _c.onChange,\n    _e = _c.defaultCheckedValues,\n    defaultCheckedValues = _e === void 0 ? [] : _e;\n  var _f = __read(useState(defaultCheckedValues), 2),\n    checkedValues = _f[0],\n    setCheckedValues = _f[1];\n  var checked = checkedValues.length > 0;\n  var indeterminate = checked && checkedValues.length < values.length;\n  var updateCheckedValues = function (values) {\n    propOnChange === null || propOnChange === void 0 ? void 0 : propOnChange(values);\n    setCheckedValues(values);\n  };\n  var rootProps = (_b = {\n    \"aria-checked\": indeterminate ? \"mixed\" : undefined,\n    checked: checked,\n    indeterminate: indeterminate\n  }, _b[menu ? \"onCheckedChange\" : \"onChange\"] = function () {\n    updateCheckedValues(checkedValues.length === 0 || indeterminate ? values : []);\n  }, _b);\n  var getProps = function (value) {\n    var _a;\n    return _a = {\n      value: value,\n      checked: checkedValues.includes(value)\n    }, _a[menu ? \"onCheckedChange\" : \"onChange\"] = function () {\n      var i = checkedValues.indexOf(value);\n      var nextChecked = checkedValues.slice();\n      if (i === -1) {\n        nextChecked.push(value);\n      } else {\n        nextChecked.splice(i, 1);\n      }\n      updateCheckedValues(nextChecked);\n    }, _a;\n  };\n  return {\n    rootProps: rootProps,\n    getProps: getProps,\n    checkedValues: checkedValues,\n    setCheckedValues: setCheckedValues\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,QAAQ,QAAQ,OAAO;AAqUhC,OAAM,SAAUC,uBAAuB,CACrCC,MAAoB,EACpBC,EAI0C;;MAJ1CC,qBAIwC,EAAE;IAHxCC,YAAY;IAAZC,IAAI,mBAAG,KAAK;IACFC,YAAY;IACtBC,4BAAyB;IAAzBC,oBAAoB,mBAAG,EAAE;EAGrB,gBACJT,QAAQ,CAAeS,oBAAoB,CAAC;IADvCC,aAAa;IAAEC,gBAAgB,QACQ;EAC9C,IAAMC,OAAO,GAAGF,aAAa,CAACG,MAAM,GAAG,CAAC;EACxC,IAAMC,aAAa,GAAGF,OAAO,IAAIF,aAAa,CAACG,MAAM,GAAGX,MAAM,CAACW,MAAM;EACrE,IAAME,mBAAmB,GAAG,UAACb,MAAoB;IAC/CK,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAGL,MAAM,CAAC;IACtBS,gBAAgB,CAACT,MAAM,CAAC;EAC1B,CAAC;EAED,IAAMc,SAAS;IACb,cAAc,EAAEF,aAAa,GAAG,OAAO,GAAGG,SAAS;IACnDL,OAAO;IACPE,aAAa;KACbI,GAACZ,IAAI,GAAG,iBAAiB,GAAG,UAAU,IAAG;IACvCS,mBAAmB,CACjBL,aAAa,CAACG,MAAM,KAAK,CAAC,IAAIC,aAAa,GAAGZ,MAAM,GAAG,EAAE,CAC1D;EACH,CAAC,KACF;EAED,IAAMiB,QAAQ,GAAG,UACfC,KAAQ;;IAER;MACEA,KAAK;MACLR,OAAO,EAAEF,aAAa,CAACW,QAAQ,CAACD,KAAK;OACrCjB,GAACG,IAAI,GAAG,iBAAiB,GAAG,UAAU,IAAG;MACvC,IAAMgB,CAAC,GAAGZ,aAAa,CAACa,OAAO,CAACH,KAAK,CAAC;MACtC,IAAMI,WAAW,GAAGd,aAAa,CAACe,KAAK,EAAE;MACzC,IAAIH,CAAC,KAAK,CAAC,CAAC,EAAE;QACZE,WAAW,CAACE,IAAI,CAACN,KAAK,CAAC;OACxB,MAAM;QACLI,WAAW,CAACG,MAAM,CAACL,CAAC,EAAE,CAAC,CAAC;;MAG1BP,mBAAmB,CAACS,WAAW,CAAC;IAClC,CAAC;EAEL,CAAC;EAED,OAAO;IACLR,SAAS;IACTG,QAAQ;IACRT,aAAa;IACbC,gBAAgB;GACjB;AACH","names":["useState","useIndeterminateChecked","values","_a","_c","_d","menu","propOnChange","_e","defaultCheckedValues","checkedValues","setCheckedValues","checked","length","indeterminate","updateCheckedValues","rootProps","undefined","_b","getProps","value","includes","i","indexOf","nextChecked","slice","push","splice"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/useIndeterminateChecked.ts"],"sourcesContent":["import type { Dispatch, SetStateAction } from \"react\";\nimport { useState } from \"react\";\n\n/**\n * @internal\n * @remarks \\@since 2.8.5\n */\ntype Initializer<V extends string> = readonly V[] | (() => readonly V[]);\n\n/**\n * The change handler for indeterminate checkboxes.\n *\n * @param values - The current list of checked values.\n * @typeParam V - The values allowed for the list of checkboxes.\n * @internal\n * @remarks \\@since 2.8.5\n */\ntype OnChange<V extends string> = (values: readonly V[]) => void;\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n */\nexport interface IndeterminateCheckedHookOptions<V extends string> {\n  /**\n   * Enabling this option will update the returned props to rename `onChange` to\n   * `onCheckedChange` to work with the {@link MenuItemCheckbox} component.\n   *\n   * @defaultValue `false`\n   */\n  menu?: boolean;\n\n  /**\n   * This is the `useState` initializer that can be used if some checkboxes should\n   * be checked by default.\n   */\n  onChange?: OnChange<V>;\n\n  /**\n   * The change handler for indeterminate checkboxes.\n   *\n   * @param values - The current list of checked values.\n   */\n  defaultCheckedValues?: Initializer<V>;\n}\n\n/** @remarks \\@since 2.8.5 */\nexport interface BaseProvidedIndeterminateCheckboxProps {\n  /**\n   * Note: This will only be provided when the {@link indeterminate} prop is\n   * `true`.\n   */\n  \"aria-checked\"?: \"mixed\";\n\n  /**\n   * Boolean if the root checkbox is currently checked.\n   */\n  checked: boolean;\n\n  /**\n   * This will be set to `true` when at least one checkbox has been checked but\n   * not every checkbox to enable the {@link CheckboxProps.indeterminate} state.\n   */\n  indeterminate: boolean;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @internal\n */\nexport interface ProvidedIndeterminateCheckboxProps\n  extends BaseProvidedIndeterminateCheckboxProps {\n  onChange(): void;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @internal\n */\nexport interface ProvidedIndeterminateMenuItemCheckboxProps\n  extends BaseProvidedIndeterminateCheckboxProps {\n  onCheckedChange(): void;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @internal\n */\ninterface ProvidedCombinedIndeterminateProps\n  extends BaseProvidedIndeterminateCheckboxProps {\n  onChange?(): void;\n  onCheckedChange?(): void;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n */\nexport interface BaseProvidedIndeterminateControlledCheckboxProps<\n  V extends string\n> {\n  /**\n   * One of the values provided to the {@link useIndeterminateChecked} hook.\n   */\n  value: V;\n\n  /**\n   * Boolean if the current checkbox is checked.\n   */\n  checked: boolean;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n * @internal\n */\nexport interface ProvidedIndeterminateControlledCheckboxProps<V extends string>\n  extends BaseProvidedIndeterminateControlledCheckboxProps<V> {\n  onChange(): void;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n * @internal\n */\nexport interface ProvidedIndeterminateControlledMenuItemCheckboxProps<\n  V extends string\n> extends BaseProvidedIndeterminateControlledCheckboxProps<V> {\n  onCheckedChange(): void;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n * @internal\n */\ninterface ProvidedCombinedIndeterminateControlledProps<V extends string>\n  extends BaseProvidedIndeterminateControlledCheckboxProps<V> {\n  onChange?(): void;\n  onCheckedChange?(): void;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n */\nexport interface BaseIndeterminateCheckedHookReturnValue<V extends string> {\n  /**\n   * A list of all the values that are currently checked.\n   */\n  checkedValues: readonly V[];\n\n  /**\n   * A function to manually override the {@link checkedValues} if the default\n   * hook's implementation does not work for your use-case.\n   */\n  setCheckedValues: Dispatch<SetStateAction<readonly V[]>>;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n * @internal\n */\ninterface OnChangeReturnValue<V extends string>\n  extends BaseIndeterminateCheckedHookReturnValue<V> {\n  rootProps: ProvidedIndeterminateCheckboxProps;\n  getProps(value: V): ProvidedIndeterminateControlledCheckboxProps<V>;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n * @internal\n */\ninterface OnCheckedChangeReturnValue<V extends string>\n  extends BaseIndeterminateCheckedHookReturnValue<V> {\n  rootProps: ProvidedIndeterminateMenuItemCheckboxProps;\n  getProps(value: V): ProvidedIndeterminateControlledMenuItemCheckboxProps<V>;\n}\n\n/**\n * @remarks \\@since 2.8.5\n * @typeParam V - The values allowed for the list of checkboxes.\n * @internal\n */\nexport interface CombinedIndeterminateCheckedHookReturnValue<V extends string>\n  extends BaseIndeterminateCheckedHookReturnValue<V> {\n  rootProps: ProvidedCombinedIndeterminateProps;\n  getProps(value: V): ProvidedCombinedIndeterminateControlledProps<V>;\n}\n\n/**\n * This hook allows you to toggle the state of multiple checkboxes in a single\n * place along with an indeterminate checkbox that can check/uncheck all\n * checkboxes at once.\n *\n * @example\n * Simple value list with labels lookup:\n * ```tsx\n * const values = [\"a\", \"b\", \"c\", \"d\"] as const;\n * const LABELS = {\n *   a: \"Label 1\",\n *   b: \"Label 2\",\n *   c: \"Label 3\",\n *   d: \"Label 4\",\n * } as const;\n * const { getProps, rootProps } = useIndeterminateChecked(values);\n *\n * return (\n *   <>\n *     <Checkbox id=\"root-checkbox\" {...rootProps} label=\"Root Checkbox\" />\n *     {values.map((value, i) => (\n *       <Checkbox\n *         id={`child-checkbox-${i + 1}`}\n *         label={LABELS[value]}\n *         {...getProps(value)}\n *       />\n *     ))}\n *   </>\n * );\n * ```\n *\n * @example\n * Fetch Data From Server and check first result\n * ```tsx\n * interface ServerFetchedData {\n *   id: Guid;\n *   name: string;\n * }\n *\n *\n * const [data, setData] = useState<readonly ServerFetchedData[]>([]);\n * const { getProps, rootProps, setCheckedValues } = useIndeterminateChecked(\n *   data.map(({ id }) => id),\n * );\n *\n * useEffect(() => {\n *   let cancelled = false;\n *   (async function load() {\n *     const response = await fetch(\"/my-api\");\n *     const json = await response.json();\n *     if (!cancelled) {\n *       // pretend validation and sanity checks\n *       setData(json);\n *       setCheckedValues(json[0].id);\n *     }\n *   })();\n\n *   return () => {\n *     cancelled = true;\n *   };\n * }, []);\n *\n * return (\n *   <>\n *     <Checkbox id=\"root-checkbox\" {...rootProps} label=\"Root Checkbox\" />\n *     {data.map(({ id, name }, i) => (\n *       <Checkbox\n *         id={`child-checkbox-${i + 1}`}\n *         label={name}\n *         {...getProps(id)}\n *       />\n *     ))}\n *   </>\n * );\n * ```\n *\n * @example\n * With MenuItemCheckbox\n * ```tsx\n * const values = [\"a\", \"b\", \"c\", \"d\"] as const;\n * const LABELS = {\n *   a: \"Label 1\",\n *   b: \"Label 2\",\n *   c: \"Label 3\",\n *   d: \"Label 4\",\n * } as const;\n * const { getProps, rootProps } = useIndeterminateChecked(values, {\n *   menu: true,\n * });\n *\n * return (\n *   <DropdownMenu id=\"dropdown-menu-id\" buttonChildren=\"Button\">\n *     <MenuItemCheckbox\n *       id=\"dropdown-menu-id-toggle-all\"\n *       {...rootProps}\n *     >\n *       Toggle All\n *     </MenuItemCheckbox>\n *     {values.map((value, i) => (\n *       <MenuItemCheckbox\n *         id={`dropdown-menu-id-${i + 1}`}\n *         key={value}\n *         {...getProps(value)}\n *       >\n *         {LABELS[value]}\n *       </MenuItemCheckbox>\n *     ))}\n *   </DropdownMenu>\n * );\n * ```\n *\n * @typeParam V - The allowed values for the checkboxes\n * @param values - The allowed values for the checkboxes which is used to\n * control the checked states.\n * @param defaultOrOptions - The {@link IndeterminateCheckedHookOptions} or a\n * `useState` initializer callback/default value for backwards compatibility\n * @param optionalOnChange - This is really just for backwards compatibility and\n * should not be used. Use {@link IndeterminateCheckedHookOptions.onChange}\n * instead.\n * @returns an object containing the `rootProps` to pass to the indeterminate\n * checkbox, a `getProps` function to provide the controlled behavior for the\n * additional `values` in the checkbox list, a list of `checkedValues`, and a\n * `setCheckedValues` function to manually override the state if needed.\n */\nexport function useIndeterminateChecked<V extends string>(\n  values: readonly V[],\n  options?: IndeterminateCheckedHookOptions<V> & { menu?: false }\n): OnChangeReturnValue<V>;\nexport function useIndeterminateChecked<V extends string>(\n  values: readonly V[],\n  options: IndeterminateCheckedHookOptions<V> & { menu: true }\n): OnCheckedChangeReturnValue<V>;\nexport function useIndeterminateChecked<V extends string>(\n  values: readonly V[],\n  {\n    menu = false,\n    onChange: propOnChange,\n    defaultCheckedValues = [],\n  }: IndeterminateCheckedHookOptions<V> = {}\n): CombinedIndeterminateCheckedHookReturnValue<V> {\n  const [checkedValues, setCheckedValues] =\n    useState<readonly V[]>(defaultCheckedValues);\n  const checked = checkedValues.length > 0;\n  const indeterminate = checked && checkedValues.length < values.length;\n  const updateCheckedValues = (values: readonly V[]): void => {\n    propOnChange?.(values);\n    setCheckedValues(values);\n  };\n\n  const rootProps: ProvidedCombinedIndeterminateProps = {\n    \"aria-checked\": indeterminate ? \"mixed\" : undefined,\n    checked,\n    indeterminate,\n    [menu ? \"onCheckedChange\" : \"onChange\"]: () => {\n      updateCheckedValues(\n        checkedValues.length === 0 || indeterminate ? values : []\n      );\n    },\n  };\n\n  const getProps = (\n    value: V\n  ): ProvidedCombinedIndeterminateControlledProps<V> => {\n    return {\n      value,\n      checked: checkedValues.includes(value),\n      [menu ? \"onCheckedChange\" : \"onChange\"]: () => {\n        const i = checkedValues.indexOf(value);\n        const nextChecked = checkedValues.slice();\n        if (i === -1) {\n          nextChecked.push(value);\n        } else {\n          nextChecked.splice(i, 1);\n        }\n\n        updateCheckedValues(nextChecked);\n      },\n    };\n  };\n\n  return {\n    rootProps,\n    getProps,\n    checkedValues,\n    setCheckedValues,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}