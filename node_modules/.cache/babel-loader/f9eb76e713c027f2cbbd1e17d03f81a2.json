{"ast":null,"code":"import { getCenterXCoord, getInnerLeftCoord, getInnerRightCoord, getLeftCoord, getRightCoord } from \"./getCoord\";\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredLeft(config) {\n  var vwMargin = config.vwMargin,\n    screenRight = config.screenRight,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getLeftCoord(config);\n  var actualX = \"left\";\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  var swappedLeft = getRightCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"right\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerLeft(config) {\n  var vwMargin = config.vwMargin,\n    screenRight = config.screenRight,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getInnerLeftCoord(config);\n  var actualX = \"inner-left\";\n  if (left + elWidth <= screenRight && left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  if (disableSwapping) {\n    if (left + elWidth > screenRight) {\n      left = screenRight - elWidth;\n    } else {\n      left = vwMargin;\n    }\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  var swappedLeft = getInnerRightCoord(config);\n  if (swappedLeft < vwMargin) {\n    left = vwMargin;\n  } else if (swappedLeft + elWidth > screenRight) {\n    left = screenRight - elWidth;\n    actualX = \"inner-right\";\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-right\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\nexport function createAnchoredCenter(config) {\n  var vwMargin = config.vwMargin,\n    screenRight = config.screenRight,\n    elWidth = config.elWidth;\n  var left = getCenterXCoord(config);\n  if (left < vwMargin) {\n    left = vwMargin;\n  } else if (left + elWidth > screenRight || left < vwMargin) {\n    left = screenRight - elWidth;\n  }\n  return {\n    actualX: \"center\",\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerRight(config) {\n  var screenRight = config.screenRight,\n    vwMargin = config.vwMargin,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getInnerRightCoord(config);\n  var actualX = \"inner-right\";\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: Math.min(left, screenRight - elWidth)\n    };\n  }\n  var swappedLeft = getInnerLeftCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = Math.max(swappedLeft, vwMargin);\n    actualX = \"inner-left\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredRight(config) {\n  var screenRight = config.screenRight,\n    vwMargin = config.vwMargin,\n    elWidth = config.elWidth,\n    disableSwapping = config.disableSwapping;\n  var left = getRightCoord(config);\n  var actualX = \"right\";\n  if (left + elWidth <= screenRight) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n  var swappedLeft = getLeftCoord(config);\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"left\";\n  }\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * @internal\n */\nexport function createEqualWidth(_a) {\n  var x = _a.x,\n    vw = _a.vw,\n    elWidth = _a.elWidth,\n    xMargin = _a.xMargin,\n    vwMargin = _a.vwMargin,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect,\n    isMinWidth = _a.isMinWidth;\n  var left = initialX !== null && initialX !== void 0 ? initialX : containerRect.left + xMargin;\n  var width = containerRect.width - xMargin * 2;\n  var minWidth;\n  var right;\n  if (isMinWidth) {\n    minWidth = width;\n    width = undefined;\n    if (left + elWidth > vw - vwMargin) {\n      right = vwMargin;\n    }\n  }\n  // going to assume that the container element is visible in the DOM and just\n  // make the fixed element have the same left and right corners\n  return {\n    left: left,\n    right: right,\n    width: width,\n    minWidth: minWidth,\n    actualX: x\n  };\n}\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\nexport function createHorizontalPosition(_a) {\n  var x = _a.x,\n    vw = _a.vw,\n    vwMargin = _a.vwMargin,\n    xMargin = _a.xMargin,\n    width = _a.width,\n    elWidth = _a.elWidth,\n    initialX = _a.initialX,\n    containerRect = _a.containerRect,\n    disableSwapping = _a.disableSwapping;\n  if (width === \"min\" || width === \"equal\") {\n    return createEqualWidth({\n      x: x,\n      vw: vw,\n      vwMargin: vwMargin,\n      xMargin: xMargin,\n      elWidth: elWidth,\n      initialX: initialX,\n      containerRect: containerRect,\n      isMinWidth: width === \"min\"\n    });\n  }\n  if (elWidth > vw - vwMargin * 2) {\n    // if the element's width is greater than the viewport's width minus the\n    // margin on both sides, just make the element span the entire viewport with\n    // the margin\n    return {\n      left: vwMargin,\n      right: vwMargin,\n      actualX: x\n    };\n  }\n  var config = {\n    vwMargin: vwMargin,\n    xMargin: xMargin,\n    elWidth: elWidth,\n    initialX: initialX,\n    screenRight: vw - vwMargin,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping\n  };\n  switch (x) {\n    case \"left\":\n      return createAnchoredLeft(config);\n    case \"inner-left\":\n      return createAnchoredInnerLeft(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"inner-right\":\n      return createAnchoredInnerRight(config);\n    case \"right\":\n      return createAnchoredRight(config);\n  }\n}","map":{"version":3,"mappings":"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","names":["getCenterXCoord","getInnerLeftCoord","getInnerRightCoord","getLeftCoord","getRightCoord","createAnchoredLeft","config","screenRight","elWidth","disableSwapping","left","actualX","vwMargin","swappedLeft","createAnchoredInnerLeft","createAnchoredCenter","createAnchoredInnerRight","Math","min","max","createAnchoredRight","createEqualWidth","_a","x","vw","xMargin","initialX","containerRect","isMinWidth","width","minWidth","right","undefined","createHorizontalPosition"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/positioning/createHorizontalPosition.ts"],"sourcesContent":["import type { XCoordConfig } from \"./getCoord\";\nimport {\n  getCenterXCoord,\n  getInnerLeftCoord,\n  getInnerRightCoord,\n  getLeftCoord,\n  getRightCoord,\n} from \"./getCoord\";\nimport type { FixedPositionOptions, HorizontalPosition } from \"./types\";\n\n/**\n * @internal\n */\ninterface XPosition {\n  left: number;\n  right?: number;\n  width?: number;\n  minWidth?: number;\n  actualX: HorizontalPosition;\n}\n\n/**\n * @internal\n */\nexport interface FixConfig extends XCoordConfig {\n  vwMargin: number;\n  screenRight: number;\n  disableSwapping: boolean;\n}\n\n/**\n * @internal\n */\ninterface Options\n  extends Required<\n    Pick<\n      FixedPositionOptions,\n      \"vwMargin\" | \"xMargin\" | \"width\" | \"disableSwapping\"\n    >\n  > {\n  x: HorizontalPosition;\n  vw: number;\n  elWidth: number;\n  initialX?: number;\n  containerRect: DOMRect;\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredLeft(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth, disableSwapping } = config;\n\n  let left = getLeftCoord(config);\n  let actualX: HorizontalPosition = \"left\";\n  if (left >= vwMargin) {\n    return { actualX, left };\n  }\n\n  const swappedLeft = getRightCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"right\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerLeft(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth, disableSwapping } = config;\n\n  let left = getInnerLeftCoord(config);\n  let actualX: HorizontalPosition = \"inner-left\";\n  if (left + elWidth <= screenRight && left >= vwMargin) {\n    return { actualX, left };\n  }\n\n  if (disableSwapping) {\n    if (left + elWidth > screenRight) {\n      left = screenRight - elWidth;\n    } else {\n      left = vwMargin;\n    }\n\n    return { actualX, left };\n  }\n\n  const swappedLeft = getInnerRightCoord(config);\n  if (swappedLeft < vwMargin) {\n    left = vwMargin;\n  } else if (swappedLeft + elWidth > screenRight) {\n    left = screenRight - elWidth;\n    actualX = \"inner-right\";\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-right\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\nexport function createAnchoredCenter(config: FixConfig): XPosition {\n  const { vwMargin, screenRight, elWidth } = config;\n  let left = getCenterXCoord(config);\n  if (left < vwMargin) {\n    left = vwMargin;\n  } else if (left + elWidth > screenRight || left < vwMargin) {\n    left = screenRight - elWidth;\n  }\n\n  return { actualX: \"center\", left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerRight(config: FixConfig): XPosition {\n  const { screenRight, vwMargin, elWidth, disableSwapping } = config;\n\n  let left = getInnerRightCoord(config);\n  let actualX: HorizontalPosition = \"inner-right\";\n  if (left >= vwMargin) {\n    return { actualX, left: Math.min(left, screenRight - elWidth) };\n  }\n\n  const swappedLeft = getInnerLeftCoord(config);\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = Math.max(swappedLeft, vwMargin);\n    actualX = \"inner-left\";\n  }\n\n  return { actualX, left };\n}\n\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredRight(config: FixConfig): XPosition {\n  const { screenRight, vwMargin, elWidth, disableSwapping } = config;\n\n  let left = getRightCoord(config);\n  let actualX: HorizontalPosition = \"right\";\n  if (left + elWidth <= screenRight) {\n    return { actualX, left };\n  }\n\n  const swappedLeft = getLeftCoord(config);\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"left\";\n  }\n\n  return { actualX, left };\n}\n\ninterface EqualWidthOptions\n  extends Pick<\n    Options,\n    | \"x\"\n    | \"vw\"\n    | \"elWidth\"\n    | \"xMargin\"\n    | \"vwMargin\"\n    | \"containerRect\"\n    | \"initialX\"\n  > {\n  isMinWidth: boolean;\n}\n\n/**\n * @internal\n */\nexport function createEqualWidth({\n  x,\n  vw,\n  elWidth,\n  xMargin,\n  vwMargin,\n  initialX,\n  containerRect,\n  isMinWidth,\n}: EqualWidthOptions): XPosition {\n  const left = initialX ?? containerRect.left + xMargin;\n\n  let width: number | undefined = containerRect.width - xMargin * 2;\n  let minWidth: number | undefined;\n  let right: number | undefined;\n  if (isMinWidth) {\n    minWidth = width;\n    width = undefined;\n    if (left + elWidth > vw - vwMargin) {\n      right = vwMargin;\n    }\n  }\n\n  // going to assume that the container element is visible in the DOM and just\n  // make the fixed element have the same left and right corners\n  return {\n    left,\n    right,\n    width,\n    minWidth,\n    actualX: x,\n  };\n}\n\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\nexport function createHorizontalPosition({\n  x,\n  vw,\n  vwMargin,\n  xMargin,\n  width,\n  elWidth,\n  initialX,\n  containerRect,\n  disableSwapping,\n}: Options): XPosition {\n  if (width === \"min\" || width === \"equal\") {\n    return createEqualWidth({\n      x,\n      vw,\n      vwMargin,\n      xMargin,\n      elWidth,\n      initialX,\n      containerRect,\n      isMinWidth: width === \"min\",\n    });\n  }\n\n  if (elWidth > vw - vwMargin * 2) {\n    // if the element's width is greater than the viewport's width minus the\n    // margin on both sides, just make the element span the entire viewport with\n    // the margin\n    return {\n      left: vwMargin,\n      right: vwMargin,\n      actualX: x,\n    };\n  }\n\n  const config: FixConfig = {\n    vwMargin,\n    xMargin,\n    elWidth,\n    initialX,\n    screenRight: vw - vwMargin,\n    containerRect,\n    disableSwapping,\n  };\n\n  switch (x) {\n    case \"left\":\n      return createAnchoredLeft(config);\n    case \"inner-left\":\n      return createAnchoredInnerLeft(config);\n    case \"center\":\n      return createAnchoredCenter(config);\n    case \"inner-right\":\n      return createAnchoredInnerRight(config);\n    case \"right\":\n      return createAnchoredRight(config);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}