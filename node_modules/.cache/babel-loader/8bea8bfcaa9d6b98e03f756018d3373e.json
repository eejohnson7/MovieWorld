{"ast":null,"code":"import { findSizingContainer } from \"@react-md/utils\";\n/**\n * Checks if the ripple event should be ignored since it was bubbled\n * up from a child treeitem. I should find a better way to handle\n * this at some point.\n */\nexport function isBubbled(event) {\n  return Array.from(event.currentTarget.querySelectorAll('[role=\"treeitem\"]')).some(function (item) {\n    return item.contains(event.target);\n  });\n}\n/**\n * Gets the ripple event type based on the provided event.\n */\nexport function getType(event) {\n  switch (event.type) {\n    case \"mousedown\":\n    case \"mouseup\":\n    case \"mouseleave\":\n      return \"mouse\";\n    case \"touchstart\":\n    case \"touchmove\":\n    case \"touchend\":\n      return \"touch\";\n    case \"keydown\":\n    case \"keyup\":\n      return \"keyboard\";\n    default:\n      return \"programmatic\";\n  }\n}\n/**\n * Checks if the provided event type is actually rippleable by ensuring:\n * - it is a mousedown event while not in touch mode and the left mouse was\n *   clicked.\n * - it was a keydown event for either tab or space when spacebar clicks have not\n *   been disabled\n * - it was a touchstart event\n */\nexport function isRippleable(event, disableSpacebarClick) {\n  switch (event.type) {\n    case \"mousedown\":\n      return document.querySelector(\".rmd-states--touch\") === null && event.button === 0;\n    case \"keydown\":\n      return !disableSpacebarClick && event.key === \" \" || event.key === \"Enter\" && !/checkbox|radio/i.test(event.currentTarget.getAttribute(\"type\") || \"\");\n    case \"touchstart\":\n    case \"click\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction calcHypotenuse(a, b) {\n  return Math.sqrt(a * a + b * b);\n}\n/**\n * Gets the current radius for a ripple based on the x and y page dimensions\n * as well as the size of the element.\n *\n * This is really just in a separate file so I can easily mock this and write\n * tests.\n */\nfunction getRadius(x, y, offsetWidth, offsetHeight) {\n  return Math.max(calcHypotenuse(x, y), calcHypotenuse(offsetWidth - x, y), calcHypotenuse(offsetWidth - x, offsetHeight - y), calcHypotenuse(x, offsetHeight - y));\n}\n/**\n * Gets the ripple creation origin base on the provided event. When the event\n * type is for keyboards or triggered programmatically, the origin will\n * be the center of the target element. When the event is for touch or mouse,\n * the origin will be the location within the viewport where the user touched\n * or clicked the target element.\n */\nexport function getOrigin(event, element) {\n  var _a;\n  var type = getType(event);\n  var offsetWidth = element.offsetWidth,\n    offsetHeight = element.offsetHeight;\n  var x;\n  var y;\n  if (type === \"programmatic\" || type === \"keyboard\") {\n    x = offsetWidth / 2;\n    y = offsetHeight / 2;\n  } else {\n    // if the event type is not programmatic, want to figure out exactly where in\n    // the element to trigger the animation from. this can be determined by:\n    // - getting the pageX and pageY of the mouse or touch event\n    // - getting element's current position in the page\n    var pageX = void 0;\n    var pageY = void 0;\n    if (type === \"mouse\") {\n      _a = event, pageX = _a.pageX, pageY = _a.pageY;\n    } else {\n      var touch = event.touches.item(0);\n      pageX = touch.pageX, pageY = touch.pageY;\n    }\n    var rect = element.getBoundingClientRect();\n    // have to include the current page's scroll offset to the element's\n    // bounding rect since the pageX and pageY from Events include the scroll\n    // offset while the bounding rect is only based on viewport.\n    x = pageX - (rect.left + window.pageXOffset);\n    y = pageY - (rect.top + window.pageYOffset);\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Creates a new ripple state based off the provided event type.\n */\nexport function createRippleState(event) {\n  var element = findSizingContainer(event.currentTarget) || event.currentTarget;\n  var offsetWidth = element.offsetWidth,\n    offsetHeight = element.offsetHeight;\n  var type = getType(event);\n  var _a = getOrigin(event, element),\n    x = _a.x,\n    y = _a.y;\n  var radius = getRadius(x, y, offsetWidth, offsetHeight);\n  var size = radius * 2;\n  return {\n    startTime: Date.now(),\n    style: {\n      left: x - radius,\n      top: y - radius,\n      height: size,\n      width: size\n    },\n    type: type,\n    holding: type !== \"programmatic\",\n    exiting: false,\n    entered: false\n  };\n}","map":{"version":3,"mappings":"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","names":["findSizingContainer","isBubbled","event","Array","from","currentTarget","querySelectorAll","some","item","contains","target","getType","type","isRippleable","disableSpacebarClick","document","querySelector","button","key","test","getAttribute","calcHypotenuse","a","b","Math","sqrt","getRadius","x","y","offsetWidth","offsetHeight","max","getOrigin","element","pageX","pageY","_a","touch","touches","rect","getBoundingClientRect","left","window","pageXOffset","top","pageYOffset","createRippleState","radius","size","startTime","Date","now","style","height","width","holding","exiting","entered"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/states/src/ripples/utils.ts"],"sourcesContent":["import { findSizingContainer } from \"@react-md/utils\";\n\nimport type { RippleEvent, RippleState, RippleType } from \"./types\";\n\n/**\n * Checks if the ripple event should be ignored since it was bubbled\n * up from a child treeitem. I should find a better way to handle\n * this at some point.\n */\nexport function isBubbled<E extends HTMLElement>(\n  event: Pick<RippleEvent<E>, \"currentTarget\" | \"target\">\n): boolean {\n  return Array.from(\n    event.currentTarget.querySelectorAll('[role=\"treeitem\"]')\n  ).some((item) => item.contains(event.target as HTMLElement));\n}\n\n/**\n * Gets the ripple event type based on the provided event.\n */\nexport function getType(\n  event: Pick<RippleEvent<HTMLElement>, \"type\">\n): RippleType {\n  switch (event.type) {\n    case \"mousedown\":\n    case \"mouseup\":\n    case \"mouseleave\":\n      return \"mouse\";\n    case \"touchstart\":\n    case \"touchmove\":\n    case \"touchend\":\n      return \"touch\";\n    case \"keydown\":\n    case \"keyup\":\n      return \"keyboard\";\n    default:\n      return \"programmatic\";\n  }\n}\n\n/**\n * Checks if the provided event type is actually rippleable by ensuring:\n * - it is a mousedown event while not in touch mode and the left mouse was\n *   clicked.\n * - it was a keydown event for either tab or space when spacebar clicks have not\n *   been disabled\n * - it was a touchstart event\n */\nexport function isRippleable(\n  event: RippleEvent<HTMLElement>,\n  disableSpacebarClick: boolean\n): boolean {\n  switch (event.type) {\n    case \"mousedown\":\n      return (\n        document.querySelector(\".rmd-states--touch\") === null &&\n        event.button === 0\n      );\n    case \"keydown\":\n      return (\n        (!disableSpacebarClick && event.key === \" \") ||\n        (event.key === \"Enter\" &&\n          !/checkbox|radio/i.test(\n            event.currentTarget.getAttribute(\"type\") || \"\"\n          ))\n      );\n    case \"touchstart\":\n    case \"click\":\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction calcHypotenuse(a: number, b: number): number {\n  return Math.sqrt(a * a + b * b);\n}\n\n/**\n * Gets the current radius for a ripple based on the x and y page dimensions\n * as well as the size of the element.\n *\n * This is really just in a separate file so I can easily mock this and write\n * tests.\n */\nfunction getRadius(\n  x: number,\n  y: number,\n  offsetWidth: number,\n  offsetHeight: number\n): number {\n  return Math.max(\n    calcHypotenuse(x, y),\n    calcHypotenuse(offsetWidth - x, y),\n    calcHypotenuse(offsetWidth - x, offsetHeight - y),\n    calcHypotenuse(x, offsetHeight - y)\n  );\n}\n\ninterface Origin {\n  x: number;\n  y: number;\n}\n\n/**\n * Gets the ripple creation origin base on the provided event. When the event\n * type is for keyboards or triggered programmatically, the origin will\n * be the center of the target element. When the event is for touch or mouse,\n * the origin will be the location within the viewport where the user touched\n * or clicked the target element.\n */\nexport function getOrigin(\n  event: Pick<RippleEvent<HTMLElement>, \"pageX\" | \"pageY\" | \"touches\" | \"type\">,\n  element: HTMLElement\n): Origin {\n  const type = getType(event);\n  const { offsetWidth, offsetHeight } = element;\n\n  let x: number;\n  let y: number;\n  if (type === \"programmatic\" || type === \"keyboard\") {\n    x = offsetWidth / 2;\n    y = offsetHeight / 2;\n  } else {\n    // if the event type is not programmatic, want to figure out exactly where in\n    // the element to trigger the animation from. this can be determined by:\n    // - getting the pageX and pageY of the mouse or touch event\n    // - getting element's current position in the page\n\n    let pageX;\n    let pageY;\n    if (type === \"mouse\") {\n      ({ pageX, pageY } = event as React.MouseEvent<HTMLElement>);\n    } else {\n      const touch = (event as React.TouchEvent<HTMLElement>).touches.item(0);\n      ({ pageX, pageY } = touch);\n    }\n\n    const rect = element.getBoundingClientRect();\n    // have to include the current page's scroll offset to the element's\n    // bounding rect since the pageX and pageY from Events include the scroll\n    // offset while the bounding rect is only based on viewport.\n    x = pageX - (rect.left + window.pageXOffset);\n    y = pageY - (rect.top + window.pageYOffset);\n  }\n\n  return { x, y };\n}\n\n/**\n * Creates a new ripple state based off the provided event type.\n */\nexport function createRippleState(\n  event: RippleEvent<HTMLElement>\n): RippleState {\n  const element =\n    findSizingContainer(event.currentTarget) || event.currentTarget;\n  const { offsetWidth, offsetHeight } = element;\n  const type = getType(event);\n  const { x, y } = getOrigin(event, element);\n\n  const radius = getRadius(x, y, offsetWidth, offsetHeight);\n  const size = radius * 2;\n  return {\n    startTime: Date.now(),\n    style: {\n      left: x - radius,\n      top: y - radius,\n      height: size,\n      width: size,\n    },\n    type,\n    holding: type !== \"programmatic\",\n    exiting: false,\n    entered: false,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}