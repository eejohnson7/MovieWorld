{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useUserInteractionMode } from \"../mode\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_EXIT_TIME } from \"./constants\";\nimport { useHoverModeContext } from \"./useHoverModeContext\";\n/**\n * This hook is used to add the hover mode functionality to any component.\n *\n * @example\n * Displaying a Color Preview when hovering a Hex Code\n * ```tsx\n * import type { ReactElement } from \"react\";\n * import { CSSTransition } from \"@react-md/transition\";\n * import { useHoverMode } from \"@react-md/utils\";\n *\n * interface Props {\n *   value: string;\n * }\n *\n * export default function Color({ value }: Props): ReactElement {\n *   const { visible, onMouseEnter, onMouseLeave } =\n *     useHoverMode({ exitVisibilityDelay: 0 });\n *\n *   return (\n *     <>\n *       <span\n *         onMouseEnter={onMouseEnter}\n *         onMouseLeave={onMouseLeave}\n *         style={{\n *           // pretend styles\n *         }}\n *       >\n *         {value}\n *       </span>\n *       <CSSTransition\n *         transitionIn={visible}\n *         classNames=\"opacity-change\"\n *         timeout={150}\n *         temporary\n *       >\n *         <span\n *           style={{\n *             backgroundColor: value,\n *             // other styles\n *           }}\n *         />\n *      </CSSTransition>\n *     </>\n *   );\n * }\n * ```\n *\n * @example\n * Sticky Usage with a Fixed Dialog\n * ```tsx\n * const {\n *   stuck,\n *   active,\n *   visible,\n *   setVisible,\n *   handlers,\n *   hoverHandlers,\n * } = useHoverMode();\n * const buttonRef = useRef<HTMLButtonElement>(null);\n *\n * return (\n *   <>\n *     <Button {...handlers} ref={buttonRef}>\n *       Click Me\n *     </Button>\n *     <FixedDialog\n *       {...hoverHandlers}\n *       aria-labelledby=\"dialog-title-id\"\n *       id=\"dialog-id\"\n *       visible={visible}\n *       onRequestClose={() => setVisible(false)}\n *       fixedTo={buttonRef}\n *       anchor={BELOW_CENTER_ANCHOR}\n *       options={{ preventOverlap: true }}\n *       // this allows the close on outside click\"\" behavior\" to work\n *       overlay={!stuck && active ? false : undefined}\n *       disableScrollLock={active}\n *     >\n *       <YourDialogContent />\n *    </FixedDialog>\n *   </>\n * );\n * ```\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 This hook no longer returns `handlers` or\n * `stickyHandlers` and does not hide when an element on the page is clicked.\n * @param options - An optional object of options to use. See\n * {@link HoverModeOptions} for more details.\n * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}\n */\nexport function useHoverMode(_a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.disabled,\n    disabled = _c === void 0 ? false : _c,\n    _d = _b.defaultVisible,\n    defaultVisible = _d === void 0 ? false : _d,\n    _e = _b.exitVisibilityDelay,\n    exitVisibilityDelay = _e === void 0 ? DEFAULT_HOVER_MODE_EXIT_TIME : _e;\n  var mode = useUserInteractionMode();\n  var isTouch = mode === \"touch\";\n  var _f = __read(useState(defaultVisible), 2),\n    visible = _f[0],\n    setVisible = _f[1];\n  var _g = __read(useState(false), 2),\n    stuck = _g[0],\n    setStuck = _g[1];\n  var timeoutRef = useRef();\n  var _h = useHoverModeContext(),\n    visibleInTime = _h.visibleInTime,\n    enableHoverMode = _h.enableHoverMode,\n    disableHoverMode = _h.disableHoverMode,\n    startDisableTimer = _h.startDisableTimer;\n  var active = visibleInTime === 0;\n  useEffect(function () {\n    if (!visible) {\n      setStuck(false);\n    }\n  }, [visible]);\n  useOnUnmount(function () {\n    window.clearTimeout(timeoutRef.current);\n  });\n  var clearHoverTimeout = useCallback(function () {\n    window.clearTimeout(timeoutRef.current);\n  }, []);\n  var onMouseEnter = useCallback(function (event) {\n    if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n      return;\n    }\n    clearHoverTimeout();\n    if (visibleInTime === 0) {\n      enableHoverMode();\n      setVisible(true);\n      return;\n    }\n    timeoutRef.current = window.setTimeout(function () {\n      enableHoverMode();\n      setVisible(true);\n    }, visibleInTime);\n  }, [clearHoverTimeout, disabled, enableHoverMode, isTouch, stuck, visibleInTime]);\n  var onMouseLeave = useCallback(function (event) {\n    if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n      return;\n    }\n    startDisableTimer();\n    clearHoverTimeout();\n    if (exitVisibilityDelay === 0) {\n      setVisible(false);\n      return;\n    }\n    timeoutRef.current = window.setTimeout(function () {\n      setVisible(false);\n    }, exitVisibilityDelay);\n  }, [clearHoverTimeout, disabled, exitVisibilityDelay, isTouch, startDisableTimer, stuck]);\n  var onClick = useCallback(function (event) {\n    if (event.isPropagationStopped()) {\n      return;\n    }\n    // If the hover mode functionality is disabled, just allow this to behave\n    // like a toggle visibility handler.\n    if (!stuck && !disabled) {\n      setStuck(true);\n      setVisible(true);\n    } else {\n      setStuck(false);\n      setVisible(function (prevVisible) {\n        return !prevVisible;\n      });\n    }\n  }, [disabled, stuck]);\n  return {\n    active: active,\n    stuck: stuck,\n    visible: visible,\n    setVisible: setVisible,\n    onClick: onClick,\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    enableHoverMode: enableHoverMode,\n    disableHoverMode: disableHoverMode,\n    startDisableTimer: startDisableTimer,\n    clearHoverTimeout: clearHoverTimeout,\n    handlers: {\n      onClick: onClick,\n      onMouseEnter: onMouseEnter,\n      onMouseLeave: onMouseLeave\n    },\n    hoverHandlers: {\n      onMouseEnter: onMouseEnter,\n      onMouseLeave: onMouseLeave\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","useUserInteractionMode","useOnUnmount","DEFAULT_HOVER_MODE_EXIT_TIME","useHoverModeContext","useHoverMode","_a","_b","_c","disabled","_d","defaultVisible","_e","exitVisibilityDelay","mode","isTouch","visible","setVisible","stuck","setStuck","timeoutRef","visibleInTime","enableHoverMode","disableHoverMode","startDisableTimer","active","window","clearTimeout","current","clearHoverTimeout","onMouseEnter","event","isPropagationStopped","setTimeout","onMouseLeave","onClick","prevVisible","handlers","hoverHandlers"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/hover/useHoverMode.ts"],"sourcesContent":["import type { Dispatch, MouseEvent, SetStateAction } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { useUserInteractionMode } from \"../mode\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_EXIT_TIME } from \"./constants\";\nimport type { HoverModeActions } from \"./useHoverModeContext\";\nimport { useHoverModeContext } from \"./useHoverModeContext\";\n\n/** @remarks \\@since 5.0.0 */\nexport interface HoverModeHoverEventHandlers {\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onMouseEnter<E extends HTMLElement>(event: MouseEvent<E>): void;\n\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onMouseLeave<E extends HTMLElement>(event: MouseEvent<E>): void;\n}\n\n/**\n * An object of event handlers that should be provided to a component to enable\n * and disable the visibility of a temporary element while hovering over that\n * component.\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 The `HTMLElement` type will be correctly inferred when\n * using them on multiple components.\n */\nexport interface HoverModeEventHandlers extends HoverModeHoverEventHandlers {\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onClick<E extends HTMLElement>(event: MouseEvent<E>): void;\n}\n\n/**\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 No longer has event handlers or a separate \"sticky\" API.\n */\nexport interface HoverModeOptions {\n  /**\n   * Boolean if the hover mode functionality should be disabled.\n   *\n   * @defaultValue `false`\n   */\n  disabled?: boolean;\n\n  /**\n   * Boolean if the element should start visible.\n   *\n   * @defaultValue `false`\n   */\n  defaultVisible?: boolean;\n\n  /**\n   * The amount of time to wait once the mouse has left the element before\n   * setting the visibility to `false`.\n   *\n   * @defaultValue {@link DEFAULT_HOVER_MODE_EXIT_TIME}\n   */\n  exitVisibilityDelay?: number;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface HoverModeHookReturnValue\n  extends HoverModeActions,\n    HoverModeEventHandlers {\n  /**\n   * Boolean if the hover mode is currently working.\n   */\n  active: boolean;\n\n  /**\n   * Boolean if the the `visible` state is `true` because the user clicked an\n   * element.\n   */\n  stuck: boolean;\n\n  /**\n   * Boolean if the temporary element should be visible.\n   */\n  visible: boolean;\n\n  /**\n   * A function to manually set the visibility state if you need even more\n   * custom behavior.\n   */\n  setVisible: Dispatch<SetStateAction<boolean>>;\n\n  /**\n   * A convenience prop that allows you to spread all the hover mode event\n   * handlers onto a single component if no custom functionality is required.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  handlers: Readonly<HoverModeEventHandlers>;\n\n  /**\n   * A convenience prop that allows you to spread only the `onMouseEnter` and\n   * `onMouseLeave` the hover mode event handlers onto a single component if no\n   * custom functionality is required.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  hoverHandlers: Readonly<HoverModeHoverEventHandlers>;\n\n  /**\n   * Clears the current `onMouseEnter` visibility timer.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  clearHoverTimeout(): void;\n}\n\n/**\n * This hook is used to add the hover mode functionality to any component.\n *\n * @example\n * Displaying a Color Preview when hovering a Hex Code\n * ```tsx\n * import type { ReactElement } from \"react\";\n * import { CSSTransition } from \"@react-md/transition\";\n * import { useHoverMode } from \"@react-md/utils\";\n *\n * interface Props {\n *   value: string;\n * }\n *\n * export default function Color({ value }: Props): ReactElement {\n *   const { visible, onMouseEnter, onMouseLeave } =\n *     useHoverMode({ exitVisibilityDelay: 0 });\n *\n *   return (\n *     <>\n *       <span\n *         onMouseEnter={onMouseEnter}\n *         onMouseLeave={onMouseLeave}\n *         style={{\n *           // pretend styles\n *         }}\n *       >\n *         {value}\n *       </span>\n *       <CSSTransition\n *         transitionIn={visible}\n *         classNames=\"opacity-change\"\n *         timeout={150}\n *         temporary\n *       >\n *         <span\n *           style={{\n *             backgroundColor: value,\n *             // other styles\n *           }}\n *         />\n *      </CSSTransition>\n *     </>\n *   );\n * }\n * ```\n *\n * @example\n * Sticky Usage with a Fixed Dialog\n * ```tsx\n * const {\n *   stuck,\n *   active,\n *   visible,\n *   setVisible,\n *   handlers,\n *   hoverHandlers,\n * } = useHoverMode();\n * const buttonRef = useRef<HTMLButtonElement>(null);\n *\n * return (\n *   <>\n *     <Button {...handlers} ref={buttonRef}>\n *       Click Me\n *     </Button>\n *     <FixedDialog\n *       {...hoverHandlers}\n *       aria-labelledby=\"dialog-title-id\"\n *       id=\"dialog-id\"\n *       visible={visible}\n *       onRequestClose={() => setVisible(false)}\n *       fixedTo={buttonRef}\n *       anchor={BELOW_CENTER_ANCHOR}\n *       options={{ preventOverlap: true }}\n *       // this allows the close on outside click\"\" behavior\" to work\n *       overlay={!stuck && active ? false : undefined}\n *       disableScrollLock={active}\n *     >\n *       <YourDialogContent />\n *    </FixedDialog>\n *   </>\n * );\n * ```\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 This hook no longer returns `handlers` or\n * `stickyHandlers` and does not hide when an element on the page is clicked.\n * @param options - An optional object of options to use. See\n * {@link HoverModeOptions} for more details.\n * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}\n */\nexport function useHoverMode({\n  disabled = false,\n  defaultVisible = false,\n  exitVisibilityDelay = DEFAULT_HOVER_MODE_EXIT_TIME,\n}: HoverModeOptions = {}): HoverModeHookReturnValue {\n  const mode = useUserInteractionMode();\n  const isTouch = mode === \"touch\";\n  const [visible, setVisible] = useState(defaultVisible);\n  const [stuck, setStuck] = useState(false);\n  const timeoutRef = useRef<number>();\n  const {\n    visibleInTime,\n    enableHoverMode,\n    disableHoverMode,\n    startDisableTimer,\n  } = useHoverModeContext();\n  const active = visibleInTime === 0;\n\n  useEffect(() => {\n    if (!visible) {\n      setStuck(false);\n    }\n  }, [visible]);\n\n  useOnUnmount(() => {\n    window.clearTimeout(timeoutRef.current);\n  });\n\n  const clearHoverTimeout = useCallback(() => {\n    window.clearTimeout(timeoutRef.current);\n  }, []);\n\n  const onMouseEnter = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n        return;\n      }\n\n      clearHoverTimeout();\n      if (visibleInTime === 0) {\n        enableHoverMode();\n        setVisible(true);\n        return;\n      }\n\n      timeoutRef.current = window.setTimeout(() => {\n        enableHoverMode();\n        setVisible(true);\n      }, visibleInTime);\n    },\n    [\n      clearHoverTimeout,\n      disabled,\n      enableHoverMode,\n      isTouch,\n      stuck,\n      visibleInTime,\n    ]\n  );\n\n  const onMouseLeave = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n        return;\n      }\n\n      startDisableTimer();\n      clearHoverTimeout();\n      if (exitVisibilityDelay === 0) {\n        setVisible(false);\n        return;\n      }\n\n      timeoutRef.current = window.setTimeout(() => {\n        setVisible(false);\n      }, exitVisibilityDelay);\n    },\n    [\n      clearHoverTimeout,\n      disabled,\n      exitVisibilityDelay,\n      isTouch,\n      startDisableTimer,\n      stuck,\n    ]\n  );\n\n  const onClick = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (event.isPropagationStopped()) {\n        return;\n      }\n\n      // If the hover mode functionality is disabled, just allow this to behave\n      // like a toggle visibility handler.\n      if (!stuck && !disabled) {\n        setStuck(true);\n        setVisible(true);\n      } else {\n        setStuck(false);\n        setVisible((prevVisible) => !prevVisible);\n      }\n    },\n    [disabled, stuck]\n  );\n\n  return {\n    active,\n    stuck,\n    visible,\n    setVisible,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    enableHoverMode,\n    disableHoverMode,\n    startDisableTimer,\n    clearHoverTimeout,\n    handlers: {\n      onClick,\n      onMouseEnter,\n      onMouseLeave,\n    },\n    hoverHandlers: {\n      onMouseEnter,\n      onMouseLeave,\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}