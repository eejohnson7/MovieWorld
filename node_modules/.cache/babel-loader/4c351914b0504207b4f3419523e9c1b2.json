{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport { getDragPercentage, getDragValue, isMouseEvent, isRangeSlider, isTouchEvent } from \"./utils\";\nvar VALID_KEYS = [\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"Home\", \"End\", \"PageUp\", \"PageDown\"];\n/**\n * This hook provides all the logic for updating the slider's when the user\n * interacts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useSliderControls(_a) {\n  var _b, _c;\n  var ref = _a.ref,\n    propThumb1Ref = _a.thumb1Ref,\n    propThumb2Ref = _a.thumb2Ref,\n    min = _a.min,\n    max = _a.max,\n    step = _a.step,\n    _d = _a.disabled,\n    disabled = _d === void 0 ? false : _d,\n    _e = _a.vertical,\n    vertical = _e === void 0 ? false : _e,\n    onBlur = _a.onBlur,\n    onKeyDown = _a.onKeyDown,\n    onMouseDown = _a.onMouseDown,\n    onTouchStart = _a.onTouchStart,\n    _f = _a.animationDuration,\n    animationDuration = _f === void 0 ? DEFAULT_SLIDER_ANIMATION_TIME : _f,\n    controls = __rest(_a, [\"ref\", \"thumb1Ref\", \"thumb2Ref\", \"min\", \"max\", \"step\", \"disabled\", \"vertical\", \"onBlur\", \"onKeyDown\", \"onMouseDown\", \"onTouchStart\", \"animationDuration\"]);\n  var trackRef = useRef(null);\n  var thumb1Ref = useRef(null);\n  var thumb2Ref = useRef(null);\n  var _g = __read(useState(false), 2),\n    dragging = _g[0],\n    setDragging = _g[1];\n  var _h = __read(useState(min), 2),\n    dragValue = _h[0],\n    setDragValue = _h[1];\n  var _j = __read(useState(null), 2),\n    draggingBy = _j[0],\n    setDraggingBy = _j[1];\n  var _k = __read(useState(null), 2),\n    draggingIndex = _k[0],\n    setDraggingIndex = _k[1];\n  var controlsRef = useRef(controls);\n  useIsomorphicLayoutEffect(function () {\n    controlsRef.current = controls;\n  });\n  var dir = useDir().dir;\n  var isRtl = dir === \"rtl\";\n  var thumb1Value;\n  var thumb1Percentage;\n  var thumb2Value;\n  var thumb2Percentage;\n  if (isRangeSlider(controls)) {\n    _b = __read(controls.value, 2), thumb1Value = _b[0], thumb2Value = _b[1];\n    _c = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      thumb2Value: thumb2Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }), thumb1Percentage = _c.thumb1Percentage, thumb2Percentage = _c.thumb2Percentage;\n  } else {\n    thumb1Value = controls.value;\n    thumb1Percentage = getDragPercentage({\n      min: min,\n      max: max,\n      thumb1Value: thumb1Value,\n      dragging: dragging,\n      dragValue: dragValue,\n      draggingIndex: draggingIndex\n    }).thumb1Percentage;\n  }\n  /**\n   * The main handler for updating the value of the slider. To help keep the\n   * drag experience smooth, some values are stored in refs to prevent the\n   * `useEffect` from being run during renders which adds and removes the move\n   * event handlers\n   */\n  var drag = useCallback(function (event) {\n    var track = trackRef.current;\n    var slider1 = thumb1Ref.current;\n    var slider2 = thumb2Ref.current;\n    var altKey = event.altKey,\n      ctrlKey = event.ctrlKey,\n      metaKey = event.metaKey,\n      shiftKey = event.shiftKey;\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !track || !slider1 || isMouseEvent(event) && event.button !== 0 || isTouchEvent(event) && event.changedTouches.length !== 1 || !isMouseEvent(event) && !isTouchEvent(event)) {\n      return;\n    }\n    // prevent text from being highlighted on desktop or the page from\n    // scrolling on mobile while dragging\n    if (!isTouchEvent(event) || event.type === \"touchmove\") {\n      event.preventDefault();\n    }\n    event.stopPropagation();\n    // get the current mouse/touch position to help determine hwo far the\n    // slider is being dragged\n    var clientX;\n    var clientY;\n    if (isMouseEvent(event)) {\n      clientX = event.clientX, clientY = event.clientY;\n    } else {\n      var touch = event.changedTouches[0];\n      clientX = touch.clientX, clientY = touch.clientY;\n    }\n    var index = 0;\n    var slider = slider1;\n    if (slider2) {\n      // if we aren't dragging yet, try to find the slider closest to the\n      // mouse/touch position and use that one\n      if (draggingIndex === null) {\n        var x1 = slider1.getBoundingClientRect().x;\n        var x2 = slider2.getBoundingClientRect().x;\n        var y1 = slider1.getBoundingClientRect().y;\n        var y2 = slider2.getBoundingClientRect().y;\n        if (vertical) {\n          index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n        } else {\n          index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n        }\n      } else {\n        index = draggingIndex;\n      }\n      slider = index === 0 ? slider1 : slider2;\n    }\n    // if we aren't dragging yet, want to focus the slider element to make it\n    // easier to switch between mouse dragging and keyboard \"dragging\"\n    if (draggingIndex !== index) {\n      slider.focus();\n      setDraggingIndex(index);\n    }\n    setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n    var _a = track.getBoundingClientRect(),\n      left = _a.left,\n      top = _a.top,\n      height = _a.height,\n      width = _a.width;\n    var options = {\n      min: min,\n      max: max,\n      step: step,\n      vertical: vertical,\n      clientX: clientX,\n      clientY: clientY,\n      left: left,\n      top: top,\n      height: height,\n      width: width,\n      isRtl: isRtl,\n      minValue: min,\n      maxValue: max\n    };\n    var controls = controlsRef.current;\n    if (isRangeSlider(controls)) {\n      var _b = __read(controls.value, 2),\n        thumb1Value_1 = _b[0],\n        thumb2Value_1 = _b[1];\n      var _c = getDragValue(__assign(__assign({}, options), {\n          minValue: index === 0 ? min : thumb1Value_1 + step,\n          maxValue: index === 1 ? max : thumb2Value_1 - step\n        })),\n        value = _c.value,\n        current = _c.current;\n      setDragValue(current);\n      controls.setValue(index === 0 ? [value, thumb2Value_1] : [thumb1Value_1, value]);\n    } else {\n      var _d = getDragValue(options),\n        value = _d.value,\n        current = _d.current;\n      setDragValue(current);\n      controls.setValue(value);\n    }\n  }, [disabled, isRtl, draggingIndex, max, min, step, vertical]);\n  var stop = useCallback(function () {\n    controlsRef.current.persist();\n    setDragging(false);\n    setDraggingIndex(null);\n    setDraggingBy(null);\n  }, []);\n  useEffect(function () {\n    if (draggingBy === null) {\n      return;\n    }\n    if (draggingBy === \"mouse\") {\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", stop);\n    } else {\n      window.addEventListener(\"touchmove\", drag, {\n        passive: false\n      });\n      window.addEventListener(\"touchend\", stop);\n    }\n    return function () {\n      if (draggingBy === \"mouse\") {\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", stop);\n      } else {\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", stop);\n      }\n    };\n  }, [draggingBy, drag, stop]);\n  useEffect(function () {\n    if (draggingIndex === null && draggingBy === null) {\n      return;\n    }\n    // I don't know how to reach this flow.. so maybe can be removed?\n    /* istanbul ignore if */\n    if (draggingIndex === null) {\n      setDragging(false);\n      return;\n    }\n    var timeout = window.setTimeout(function () {\n      setDragging(true);\n    }, animationDuration);\n    return function () {\n      window.clearTimeout(timeout);\n    };\n  }, [draggingIndex, draggingBy, animationDuration]);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    controlsRef.current.persist();\n  }, [onBlur]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  var handleMouseDown = useCallback(function (event) {\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n    // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the mouse appears over the slider\n    // thumb again\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onMouseDown]);\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  var handleTouchStart = useCallback(function (event) {\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n    // only call drag again when the dragging by isn't null since it can cause\n    // the \"drag\" events to be re-started if the user's finger appears over\n    // the slider thumb again\n    if (draggingBy === null) {\n      drag(event);\n    }\n  }, [drag, draggingBy, onTouchStart]);\n  /**\n   * Note: this should be attached to each `SliderThumb` component.\n   */\n  var handleKeyDown = useCallback(function (event) {\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n    var key = event.key,\n      altKey = event.altKey,\n      ctrlKey = event.ctrlKey,\n      metaKey = event.metaKey,\n      shiftKey = event.shiftKey;\n    if (altKey || ctrlKey || metaKey || shiftKey || disabled || !VALID_KEYS.includes(key)) {\n      return;\n    }\n    var controls;\n    if (isRangeSlider(controlsRef.current)) {\n      var _a = controlsRef.current,\n        increment_1 = _a.increment,\n        incrementJump_1 = _a.incrementJump,\n        decrement_1 = _a.decrement,\n        decrementJump_1 = _a.decrementJump,\n        minimum_1 = _a.minimum,\n        maximum_1 = _a.maximum;\n      var index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n      controls = {\n        increment: increment_1.bind(null, index),\n        incrementJump: incrementJump_1.bind(null, index),\n        decrement: decrement_1.bind(null, index),\n        decrementJump: decrementJump_1.bind(null, index),\n        minimum: minimum_1.bind(null, index),\n        maximum: maximum_1.bind(null, index)\n      };\n    } else {\n      controls = controlsRef.current;\n    }\n    var increment = controls.increment,\n      incrementJump = controls.incrementJump,\n      decrement = controls.decrement,\n      decrementJump = controls.decrementJump,\n      minimum = controls.minimum,\n      maximum = controls.maximum;\n    event.preventDefault();\n    event.stopPropagation();\n    switch (key) {\n      case \"ArrowUp\":\n      case \"ArrowRight\":\n        increment();\n        break;\n      case \"ArrowDown\":\n      case \"ArrowLeft\":\n        decrement();\n        break;\n      case \"Home\":\n        minimum();\n        break;\n      case \"End\":\n        maximum();\n        break;\n      case \"PageUp\":\n        incrementJump();\n        break;\n      case \"PageDown\":\n        decrementJump();\n        break;\n    }\n  }, [onKeyDown, disabled]);\n  var trackRefHandler = useCallback(function (instance) {\n    applyRef(instance, ref);\n    trackRef.current = instance;\n  }, [ref]);\n  var thumb1RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb1Ref);\n    thumb1Ref.current = instance;\n  }, [propThumb1Ref]);\n  var thumb2RefHandler = useCallback(function (instance) {\n    applyRef(instance, propThumb2Ref);\n    thumb2Ref.current = instance;\n  }, [propThumb2Ref]);\n  return {\n    thumb1Ref: thumb1RefHandler,\n    thumb1Value: thumb1Value,\n    thumb1Percentage: thumb1Percentage,\n    thumb2Ref: thumb2RefHandler,\n    thumb2Value: thumb2Value,\n    thumb2Percentage: thumb2Percentage,\n    dragging: dragging,\n    draggingIndex: draggingIndex,\n    ref: trackRefHandler,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    onMouseDown: handleMouseDown,\n    onTouchStart: handleTouchStart\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","applyRef","useDir","useIsomorphicLayoutEffect","DEFAULT_SLIDER_ANIMATION_TIME","getDragPercentage","getDragValue","isMouseEvent","isRangeSlider","isTouchEvent","VALID_KEYS","useSliderControls","_a","propThumb1Ref","propThumb2Ref","min","max","step","_d","disabled","_e","vertical","onBlur","onKeyDown","onMouseDown","onTouchStart","_f","animationDuration","controls","trackRef","thumb1Ref","thumb2Ref","dragging","setDragging","dragValue","setDragValue","draggingBy","setDraggingBy","draggingIndex","setDraggingIndex","controlsRef","current","isRtl","dir","thumb1Value","thumb1Percentage","thumb2Value","thumb2Percentage","_b","value","_c","drag","event","track","slider1","slider2","ctrlKey","metaKey","shiftKey","altKey","button","changedTouches","length","type","preventDefault","stopPropagation","clientX","clientY","touch","index","slider","x1","getBoundingClientRect","x","x2","y1","y","y2","Math","abs","focus","left","top","height","width","options","minValue","maxValue","thumb1Value_1","thumb2Value_1","setValue","stop","persist","window","addEventListener","passive","removeEventListener","timeout","setTimeout","clearTimeout","handleBlur","handleMouseDown","handleTouchStart","handleKeyDown","includes","key","increment_1","incrementJump_1","decrement_1","decrementJump_1","minimum_1","maximum_1","currentTarget","increment","bind","incrementJump","decrement","decrementJump","minimum","maximum","trackRefHandler","instance","ref","thumb1RefHandler","thumb2RefHandler"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/slider/useSliderControls.ts"],"sourcesContent":["import type {\n  KeyboardEventHandler,\n  MouseEventHandler,\n  FocusEventHandler,\n  Ref,\n  RefCallback,\n  TouchEventHandler,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { applyRef, useDir, useIsomorphicLayoutEffect } from \"@react-md/utils\";\n\nimport { DEFAULT_SLIDER_ANIMATION_TIME } from \"./constants\";\nimport type {\n  DefinedSliderValueOptions,\n  SliderControls,\n  SliderDragEvent,\n  SliderDraggingBy,\n  SliderEventHandlers,\n  SliderPresentation,\n  SliderThumbIndex,\n  ThumbIndex,\n} from \"./types\";\nimport type { CombinedSliderControls, SliderDragValues } from \"./utils\";\nimport {\n  getDragPercentage,\n  getDragValue,\n  isMouseEvent,\n  isRangeSlider,\n  isTouchEvent,\n} from \"./utils\";\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport type SliderControlsOptions = CombinedSliderControls &\n  SliderPresentation &\n  SliderEventHandlers &\n  DefinedSliderValueOptions & {\n    ref?: Ref<HTMLSpanElement | null>;\n    thumb1Ref?: Ref<HTMLSpanElement | null>;\n    thumb2Ref?: Ref<HTMLSpanElement | null>;\n    animationDuration?: number;\n  };\n\nconst VALID_KEYS = [\n  \"ArrowDown\",\n  \"ArrowUp\",\n  \"ArrowLeft\",\n  \"ArrowRight\",\n  \"Home\",\n  \"End\",\n  \"PageUp\",\n  \"PageDown\",\n];\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport interface SliderAndRangeSliderControls {\n  thumb1Ref: RefCallback<HTMLSpanElement | null>;\n  thumb1Value: number;\n  thumb1Percentage: string;\n  thumb2Ref: RefCallback<HTMLSpanElement | null>;\n  thumb2Value?: number;\n  thumb2Percentage?: string;\n  dragging: boolean;\n  draggingIndex: SliderThumbIndex;\n  ref: RefCallback<HTMLSpanElement | null>;\n  onBlur: FocusEventHandler<HTMLSpanElement>;\n  onKeyDown: KeyboardEventHandler<HTMLSpanElement>;\n  onMouseDown: MouseEventHandler<HTMLSpanElement>;\n  onTouchStart: TouchEventHandler<HTMLSpanElement>;\n}\n\n/**\n * This hook provides all the logic for updating the slider's when the user\n * interacts with the slider.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useSliderControls({\n  ref,\n  thumb1Ref: propThumb1Ref,\n  thumb2Ref: propThumb2Ref,\n  min,\n  max,\n  step,\n  disabled = false,\n  vertical = false,\n  onBlur,\n  onKeyDown,\n  onMouseDown,\n  onTouchStart,\n  animationDuration = DEFAULT_SLIDER_ANIMATION_TIME,\n  ...controls\n}: SliderControlsOptions): SliderAndRangeSliderControls {\n  const trackRef = useRef<HTMLSpanElement | null>(null);\n  const thumb1Ref = useRef<HTMLSpanElement | null>(null);\n  const thumb2Ref = useRef<HTMLSpanElement | null>(null);\n  const [dragging, setDragging] = useState(false);\n  const [dragValue, setDragValue] = useState<number>(min);\n  const [draggingBy, setDraggingBy] = useState<SliderDraggingBy>(null);\n  const [draggingIndex, setDraggingIndex] = useState<SliderThumbIndex>(null);\n  const controlsRef = useRef(controls);\n  useIsomorphicLayoutEffect(() => {\n    controlsRef.current = controls;\n  });\n\n  const { dir } = useDir();\n  const isRtl = dir === \"rtl\";\n\n  let thumb1Value: number;\n  let thumb1Percentage: string;\n  let thumb2Value: number | undefined;\n  let thumb2Percentage: string | undefined;\n  if (isRangeSlider(controls)) {\n    [thumb1Value, thumb2Value] = controls.value;\n    ({ thumb1Percentage, thumb2Percentage } = getDragPercentage({\n      min,\n      max,\n      thumb1Value,\n      thumb2Value,\n      dragging,\n      dragValue,\n      draggingIndex,\n    }));\n  } else {\n    thumb1Value = controls.value;\n    ({ thumb1Percentage } = getDragPercentage({\n      min,\n      max,\n      thumb1Value,\n      dragging,\n      dragValue,\n      draggingIndex,\n    }));\n  }\n\n  /**\n   * The main handler for updating the value of the slider. To help keep the\n   * drag experience smooth, some values are stored in refs to prevent the\n   * `useEffect` from being run during renders which adds and removes the move\n   * event handlers\n   */\n  const drag = useCallback(\n    (event: SliderDragEvent) => {\n      const track = trackRef.current;\n      const slider1 = thumb1Ref.current;\n      const slider2 = thumb2Ref.current;\n      const { altKey, ctrlKey, metaKey, shiftKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        shiftKey ||\n        disabled ||\n        !track ||\n        !slider1 ||\n        (isMouseEvent(event) && event.button !== 0) ||\n        (isTouchEvent(event) && event.changedTouches.length !== 1) ||\n        (!isMouseEvent(event) && !isTouchEvent(event))\n      ) {\n        return;\n      }\n\n      // prevent text from being highlighted on desktop or the page from\n      // scrolling on mobile while dragging\n      if (!isTouchEvent(event) || event.type === \"touchmove\") {\n        event.preventDefault();\n      }\n      event.stopPropagation();\n\n      // get the current mouse/touch position to help determine hwo far the\n      // slider is being dragged\n      let clientX: number;\n      let clientY: number;\n      if (isMouseEvent(event)) {\n        ({ clientX, clientY } = event);\n      } else {\n        const touch = event.changedTouches[0];\n        ({ clientX, clientY } = touch);\n      }\n\n      let index: ThumbIndex = 0;\n      let slider: HTMLSpanElement = slider1;\n      if (slider2) {\n        // if we aren't dragging yet, try to find the slider closest to the\n        // mouse/touch position and use that one\n        if (draggingIndex === null) {\n          const x1 = slider1.getBoundingClientRect().x;\n          const x2 = slider2.getBoundingClientRect().x;\n          const y1 = slider1.getBoundingClientRect().y;\n          const y2 = slider2.getBoundingClientRect().y;\n          if (vertical) {\n            index = Math.abs(clientY - y1) < Math.abs(clientY - y2) ? 0 : 1;\n          } else {\n            index = Math.abs(clientX - x1) < Math.abs(clientX - x2) ? 0 : 1;\n          }\n        } else {\n          index = draggingIndex;\n        }\n\n        slider = index === 0 ? slider1 : slider2;\n      }\n\n      // if we aren't dragging yet, want to focus the slider element to make it\n      // easier to switch between mouse dragging and keyboard \"dragging\"\n      if (draggingIndex !== index) {\n        slider.focus();\n        setDraggingIndex(index);\n      }\n\n      setDraggingBy(isMouseEvent(event) ? \"mouse\" : \"touch\");\n\n      const { left, top, height, width } = track.getBoundingClientRect();\n      const options: SliderDragValues = {\n        min,\n        max,\n        step,\n        vertical,\n        clientX,\n        clientY,\n        left,\n        top,\n        height,\n        width,\n        isRtl,\n        minValue: min,\n        maxValue: max,\n      };\n\n      const controls = controlsRef.current;\n      if (isRangeSlider(controls)) {\n        const [thumb1Value, thumb2Value] = controls.value;\n        const { value, current } = getDragValue({\n          ...options,\n          minValue: index === 0 ? min : thumb1Value + step,\n          maxValue: index === 1 ? max : thumb2Value - step,\n        });\n        setDragValue(current);\n        controls.setValue(\n          index === 0 ? [value, thumb2Value] : [thumb1Value, value]\n        );\n      } else {\n        const { value, current } = getDragValue(options);\n        setDragValue(current);\n        controls.setValue(value);\n      }\n    },\n    [disabled, isRtl, draggingIndex, max, min, step, vertical]\n  );\n  const stop = useCallback(() => {\n    controlsRef.current.persist();\n    setDragging(false);\n    setDraggingIndex(null);\n    setDraggingBy(null);\n  }, []);\n\n  useEffect(() => {\n    if (draggingBy === null) {\n      return;\n    }\n\n    if (draggingBy === \"mouse\") {\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", stop);\n    } else {\n      window.addEventListener(\"touchmove\", drag, { passive: false });\n      window.addEventListener(\"touchend\", stop);\n    }\n\n    return () => {\n      if (draggingBy === \"mouse\") {\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", stop);\n      } else {\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", stop);\n      }\n    };\n  }, [draggingBy, drag, stop]);\n\n  useEffect(() => {\n    if (draggingIndex === null && draggingBy === null) {\n      return;\n    }\n\n    // I don't know how to reach this flow.. so maybe can be removed?\n    /* istanbul ignore if */\n    if (draggingIndex === null) {\n      setDragging(false);\n      return;\n    }\n\n    const timeout = window.setTimeout(() => {\n      setDragging(true);\n    }, animationDuration);\n\n    return () => {\n      window.clearTimeout(timeout);\n    };\n  }, [draggingIndex, draggingBy, animationDuration]);\n\n  const handleBlur = useCallback<FocusEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      controlsRef.current.persist();\n    },\n    [onBlur]\n  );\n\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  const handleMouseDown = useCallback<MouseEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n\n      // only call drag again when the dragging by isn't null since it can cause\n      // the \"drag\" events to be re-started if the mouse appears over the slider\n      // thumb again\n      if (draggingBy === null) {\n        drag(event);\n      }\n    },\n    [drag, draggingBy, onMouseDown]\n  );\n\n  /**\n   * Note: this should be attached to the `SliderTrack` component.\n   */\n  const handleTouchStart = useCallback<TouchEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n\n      // only call drag again when the dragging by isn't null since it can cause\n      // the \"drag\" events to be re-started if the user's finger appears over\n      // the slider thumb again\n      if (draggingBy === null) {\n        drag(event);\n      }\n    },\n    [drag, draggingBy, onTouchStart]\n  );\n\n  /**\n   * Note: this should be attached to each `SliderThumb` component.\n   */\n  const handleKeyDown = useCallback<KeyboardEventHandler<HTMLSpanElement>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key, altKey, ctrlKey, metaKey, shiftKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        shiftKey ||\n        disabled ||\n        !VALID_KEYS.includes(key)\n      ) {\n        return;\n      }\n\n      let controls: Omit<SliderControls, \"setValue\" | \"value\" | \"persist\">;\n      if (isRangeSlider(controlsRef.current)) {\n        const {\n          increment,\n          incrementJump,\n          decrement,\n          decrementJump,\n          minimum,\n          maximum,\n        } = controlsRef.current;\n        const index = event.currentTarget === thumb2Ref.current ? 1 : 0;\n        controls = {\n          increment: increment.bind(null, index),\n          incrementJump: incrementJump.bind(null, index),\n          decrement: decrement.bind(null, index),\n          decrementJump: decrementJump.bind(null, index),\n          minimum: minimum.bind(null, index),\n          maximum: maximum.bind(null, index),\n        };\n      } else {\n        controls = controlsRef.current;\n      }\n\n      const {\n        increment,\n        incrementJump,\n        decrement,\n        decrementJump,\n        minimum,\n        maximum,\n      } = controls;\n      event.preventDefault();\n      event.stopPropagation();\n      switch (key) {\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n          increment();\n          break;\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n          decrement();\n          break;\n        case \"Home\":\n          minimum();\n          break;\n        case \"End\":\n          maximum();\n          break;\n        case \"PageUp\":\n          incrementJump();\n          break;\n        case \"PageDown\":\n          decrementJump();\n          break;\n      }\n    },\n    [onKeyDown, disabled]\n  );\n\n  const trackRefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, ref);\n      trackRef.current = instance;\n    },\n    [ref]\n  );\n\n  const thumb1RefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, propThumb1Ref);\n      thumb1Ref.current = instance;\n    },\n    [propThumb1Ref]\n  );\n\n  const thumb2RefHandler = useCallback(\n    (instance: HTMLSpanElement | null) => {\n      applyRef(instance, propThumb2Ref);\n      thumb2Ref.current = instance;\n    },\n    [propThumb2Ref]\n  );\n\n  return {\n    thumb1Ref: thumb1RefHandler,\n    thumb1Value,\n    thumb1Percentage,\n    thumb2Ref: thumb2RefHandler,\n    thumb2Value,\n    thumb2Percentage,\n    dragging,\n    draggingIndex,\n    ref: trackRefHandler,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    onMouseDown: handleMouseDown,\n    onTouchStart: handleTouchStart,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}