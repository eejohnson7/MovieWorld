{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useRef } from \"react\";\nimport { JumpMovementKey, MovementPresets, scrollIntoView, useActiveDescendantMovement, useIsUserInteractionMode } from \"@react-md/utils\";\nimport { useFlattenedTreeList } from \"./useFlattenedTreeList\";\nimport { useNestedTreeList } from \"./useNestedTreeList\";\n/**\n * This is a temporary workaround for allowing the navigation tree to scroll\n * correctly with keyboard movement since it manually sets the\n * `overflow: visible` which prevents scrolling. I'll need to think of a better\n * way to find/get the scrollable element (if any). It might also just go into\n * the `scrollIntoView` util.\n *\n * @remarks \\@since 2.5.3\n * @internal\n */\nvar getScrollContainer = function (target) {\n  if (target.classList.contains(\"rmd-layout-tree\")) {\n    return target.parentElement;\n  }\n  return target;\n};\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @internal\n */\nexport function useTreeMovement(_a) {\n  var id = _a.id,\n    data = _a.data,\n    rootId = _a.rootId,\n    sort = _a.sort,\n    onBlur = _a.onBlur,\n    onFocus = _a.onFocus,\n    onKeyDown = _a.onKeyDown,\n    multiSelect = _a.multiSelect,\n    selectedIds = _a.selectedIds,\n    onItemSelect = _a.onItemSelect,\n    onMultiItemSelect = _a.onMultiItemSelect,\n    expandedIds = _a.expandedIds,\n    onItemExpansion = _a.onItemExpansion,\n    onMultiItemExpansion = _a.onMultiItemExpansion,\n    valueKey = _a.valueKey,\n    getItemValue = _a.getItemValue;\n  var items = useNestedTreeList(data, sort, rootId);\n  var _b = __read(useFlattenedTreeList({\n      id: id,\n      items: items,\n      expandedIds: expandedIds,\n      rootId: rootId,\n      valueKey: valueKey,\n      getItemValue: getItemValue\n    }), 3),\n    visibleItems = _b[0],\n    itemIdRefs = _b[1],\n    flattenedItems = _b[2];\n  var isKeyboard = useIsUserInteractionMode(\"keyboard\");\n  var _c = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_TREE), {\n      items: visibleItems,\n      baseId: id,\n      getId: function (_baseId, index) {\n        return (visibleItems[index] || {\n          id: \"\"\n        }).id;\n      },\n      onSpace: function (focusedIndex) {\n        var item = visibleItems[focusedIndex];\n        if (!item) {\n          return;\n        }\n        var itemId = item.itemId;\n        onItemSelect(itemId);\n      },\n      onChange: function (data) {\n        var index = data.index,\n          target = data.target,\n          query = data.query;\n        var itemId = visibleItems[index].itemId;\n        // Note: have to do a custom `scrollIntoView` here instead of relying on\n        // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the\n        // tree renders with the ref behavior.\n        var item = itemIdRefs[itemId].ref.current;\n        var container = getScrollContainer(target);\n        if (item && container && container.scrollHeight > container.offsetHeight) {\n          scrollIntoView(container, item);\n        }\n        if (!multiSelect) {\n          return;\n        }\n        var isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n        var isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n        if (!isToStart && !isToEnd) {\n          return;\n        }\n        var start = isToStart ? 0 : focusedIndex;\n        var end = isToStart ? focusedIndex + 1 : undefined;\n        var jumpSelectedIds = visibleItems.slice(start, end).map(function (_a) {\n          var itemId = _a.itemId;\n          return itemId;\n        });\n        var uniqueSelectedIds = Array.from(new Set(__spreadArray(__spreadArray([], __read(selectedIds), false), __read(jumpSelectedIds), false)));\n        if (selectedIds.length !== uniqueSelectedIds.length) {\n          onMultiItemSelect(uniqueSelectedIds);\n        }\n      },\n      onKeyDown: function (event) {\n        var _a, _b, _c, _d;\n        if (onKeyDown) {\n          onKeyDown(event);\n        }\n        var item = visibleItems[focusedIndex];\n        if (!item) {\n          return;\n        }\n        var itemId = item.itemId,\n          parentId = item.parentId,\n          isParent = item.isParent;\n        switch (event.key) {\n          case \"Enter\":\n            {\n              if (isParent) {\n                onItemExpansion(itemId, !expandedIds.includes(itemId));\n                return;\n              }\n              var node = itemIdRefs[itemId].ref.current;\n              var anchor = node && node.getAttribute(\"role\") === \"none\" && node.querySelector(\"a[href]\");\n              if (!anchor) {\n                onItemSelect(itemId);\n                return;\n              }\n              // if a user is navigating through the app with a keyboard and presses\n              // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n              // be forcefully opened in a new tab irregardless of the target\n              // attribute on the anchor tag. Since a tree doesn't actually focus\n              // the link in this case, need to \"polyfill\" it with this workaround.\n              // the `meta` key is for Mac and `ctrlKey` for Windows\n              var forceNewTab = event.shiftKey && (event.metaKey || event.ctrlKey);\n              var prevTarget = anchor.target;\n              if (forceNewTab) {\n                anchor.target = \"_blank\";\n              }\n              anchor.click();\n              if (forceNewTab) {\n                anchor.target = prevTarget;\n              }\n              break;\n            }\n          case \"ArrowRight\":\n            if (!isParent) {\n              return;\n            }\n            if (!expandedIds.includes(itemId)) {\n              onItemExpansion(itemId, true);\n            } else {\n              var nextIndex = focusedIndex + 1;\n              var nextItem = (_b = itemIdRefs[(_a = visibleItems[nextIndex]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n              setFocusedIndex(nextIndex);\n              scrollIntoView(event.currentTarget, nextItem);\n            }\n            break;\n          case \"ArrowLeft\":\n            if (isParent && expandedIds.includes(itemId)) {\n              onItemExpansion(itemId, false);\n            } else if (parentId !== rootId) {\n              var parentIndex = visibleItems.findIndex(function (item) {\n                return item.itemId === parentId;\n              });\n              var parentItem = (_d = itemIdRefs[(_c = visibleItems[parentIndex]) === null || _c === void 0 ? void 0 : _c.itemId]) === null || _d === void 0 ? void 0 : _d.ref.current;\n              setFocusedIndex(parentIndex);\n              scrollIntoView(event.currentTarget, parentItem);\n            }\n            break;\n          case \"a\":\n            {\n              if (!multiSelect || !event.ctrlKey) {\n                return;\n              }\n              event.preventDefault();\n              var allItemIds = visibleItems.map(function (_a) {\n                var itemId = _a.itemId;\n                return itemId;\n              });\n              if (selectedIds.length === allItemIds.length) {\n                onMultiItemSelect([]);\n              } else {\n                onMultiItemSelect(allItemIds);\n              }\n              break;\n            }\n          case \"*\":\n            {\n              var item_1 = visibleItems[focusedIndex];\n              if (!item_1) {\n                return;\n              }\n              var expectedExpandedIds = visibleItems.filter(function (_a) {\n                var isParent = _a.isParent,\n                  parentId = _a.parentId;\n                return isParent && parentId === item_1.parentId;\n              }).map(function (_a) {\n                var itemId = _a.itemId;\n                return itemId;\n              });\n              var nextIds = Array.from(new Set(__spreadArray(__spreadArray([], __read(expandedIds), false), __read(expectedExpandedIds), false)));\n              if (nextIds.length !== expandedIds.length) {\n                onMultiItemExpansion(nextIds);\n                // since new items will be rendered, need to also update the focused\n                // index so the currently active item is still the \"focused\" item\n                //\n                // TODO: Look into a much better way to handle this sort of stuff..\n                // This still doesn't correctly scroll the active element into view.\n                // I should probably move all the scroll behavior into a useEffect\n                // for whenever the focusedIndex changes.\n                var visibleCount = 0;\n                var lookup = {};\n                for (var i = 0; i < flattenedItems.length; i += 1) {\n                  var item_2 = flattenedItems[i];\n                  var isVisible = item_2.parentId === rootId;\n                  if (item_2.parentId !== null && nextIds.includes(item_2.parentId)) {\n                    isVisible = !!lookup[item_2.parentId];\n                  }\n                  lookup[item_2.itemId] = isVisible;\n                  if (itemId === item_2.itemId) {\n                    setFocusedIndex(visibleCount);\n                    return;\n                  }\n                  if (isVisible) {\n                    visibleCount += 1;\n                  }\n                }\n              }\n            }\n          // no default\n        }\n      }\n    })),\n    activeId = _c.activeId,\n    handleKeyDown = _c.onKeyDown,\n    focusedIndex = _c.focusedIndex,\n    setFocusedIndex = _c.setFocusedIndex;\n  var lastFocus = useRef(0);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    if (document.activeElement && event.currentTarget.contains(document.activeElement)) {\n      return;\n    }\n    lastFocus.current = focusedIndex;\n    setFocusedIndex(-1);\n  }, [focusedIndex, onBlur, setFocusedIndex]);\n  var handleFocus = useCallback(function (event) {\n    var _a, _b;\n    if (onFocus) {\n      onFocus(event);\n    }\n    if (focusedIndex !== -1) {\n      // this happens when a tree item is clicked with the mouse or touch\n      return;\n    }\n    var index = -1;\n    // try to \"focus\" the first selected itemId if there is a selection.\n    if (selectedIds.length) {\n      index = visibleItems.findIndex(function (item) {\n        return selectedIds.includes(item.itemId);\n      });\n    }\n    // fallback to the first visible tree item if there were no selected ids\n    if (index === -1) {\n      index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n    }\n    var currentItem = (_b = itemIdRefs[(_a = visibleItems[index]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;\n    if (currentItem && isKeyboard) {\n      scrollIntoView(getScrollContainer(event.currentTarget), currentItem);\n    }\n    setFocusedIndex(index);\n  }, [focusedIndex, isKeyboard, itemIdRefs, onFocus, selectedIds, setFocusedIndex, visibleItems]);\n  var setActiveId = useCallback(function (itemId) {\n    var index = visibleItems.findIndex(function (item) {\n      return item.itemId === itemId;\n    });\n    if (index !== -1) {\n      setFocusedIndex(index);\n    }\n  }, [setFocusedIndex, visibleItems]);\n  return {\n    items: items,\n    activeId: activeId,\n    setActiveId: setActiveId,\n    itemIdRefs: itemIdRefs,\n    handleBlur: handleBlur,\n    handleFocus: handleFocus,\n    handleKeyDown: handleKeyDown\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useRef","JumpMovementKey","MovementPresets","scrollIntoView","useActiveDescendantMovement","useIsUserInteractionMode","useFlattenedTreeList","useNestedTreeList","getScrollContainer","target","classList","contains","parentElement","useTreeMovement","_a","id","data","rootId","sort","onBlur","onFocus","onKeyDown","multiSelect","selectedIds","onItemSelect","onMultiItemSelect","expandedIds","onItemExpansion","onMultiItemExpansion","valueKey","getItemValue","items","visibleItems","itemIdRefs","flattenedItems","isKeyboard","VERTICAL_TREE","baseId","getId","_baseId","index","onSpace","focusedIndex","item","itemId","onChange","query","ref","current","container","scrollHeight","offsetHeight","isToStart","endsWith","ControlShiftHome","isToEnd","ControlShiftEnd","start","end","undefined","jumpSelectedIds","slice","map","uniqueSelectedIds","Array","from","Set","length","event","parentId","isParent","key","includes","node","anchor","getAttribute","querySelector","forceNewTab","shiftKey","metaKey","ctrlKey","prevTarget","click","nextIndex","nextItem","setFocusedIndex","currentTarget","parentIndex","findIndex","parentItem","preventDefault","allItemIds","item_1","expectedExpandedIds","filter","nextIds","visibleCount","lookup","i","item_2","isVisible","activeId","handleKeyDown","lastFocus","handleBlur","document","activeElement","handleFocus","Math","max","min","currentItem","setActiveId"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/tree/src/useTreeMovement.ts"],"sourcesContent":["import type { FocusEventHandler, KeyboardEventHandler } from \"react\";\nimport { useCallback, useRef } from \"react\";\nimport type { ListElement } from \"@react-md/list\";\nimport {\n  JumpMovementKey,\n  MovementPresets,\n  scrollIntoView,\n  useActiveDescendantMovement,\n  useIsUserInteractionMode,\n} from \"@react-md/utils\";\n\nimport type { TreeItemId, TreeProps, UnknownTreeItem } from \"./types\";\nimport type {\n  MetadataRecord,\n  SearchableTreeItem,\n} from \"./useFlattenedTreeList\";\nimport { useFlattenedTreeList } from \"./useFlattenedTreeList\";\nimport type { NestedTreeItem } from \"./useNestedTreeList\";\nimport { useNestedTreeList } from \"./useNestedTreeList\";\n\ntype Options = Pick<\n  TreeProps<UnknownTreeItem>,\n  | \"id\"\n  | \"data\"\n  | \"sort\"\n  | \"onBlur\"\n  | \"onFocus\"\n  | \"onKeyDown\"\n  | \"multiSelect\"\n  | \"selectedIds\"\n  | \"onItemSelect\"\n  | \"onMultiItemSelect\"\n  | \"expandedIds\"\n  | \"onItemExpansion\"\n  | \"onMultiItemExpansion\"\n> &\n  Required<\n    Pick<TreeProps<UnknownTreeItem>, \"valueKey\" | \"getItemValue\" | \"rootId\">\n  >;\n\ninterface ReturnValue {\n  /**\n   * A nested list representation of the provided tree data. This is used for\n   * rendering all the treeitem nodes.\n   */\n  items: readonly NestedTreeItem<UnknownTreeItem>[];\n\n  /**\n   * The current treeitem's DOM id that is currently keyboard focused.\n   */\n  activeId: string;\n\n  /**\n   * A function that updates the `activeId` based on the provided `itemId`. This\n   * should really only be used whenever an item is clicked with a mouse or\n   * touch since the `activeId` will be updated automatically for all the other\n   * flows.\n   */\n  setActiveId(itemId: TreeItemId): void;\n\n  /**\n   * A record containing the DOM ids for each tree item along with a ref object\n   * to provide to the itemRenderer for that item. This is just for a quick\n   * lookup to help with all the tree traversal and keyboard movement.\n   */\n  itemIdRefs: MetadataRecord;\n\n  /**\n   * A blur handler that should be passed to the tree list element that handles\n   * removing the `aria-activedescendant` when the tree is no longer within\n   * focus. This will also call the optional `onBlur` prop.\n   */\n  handleBlur: FocusEventHandler<ListElement>;\n\n  /**\n   * A focus handler that should be passed to the tree element that handles\n   * conditionally setting the default `aria-activedescendant` id on first\n   * focus. This will also call the optional `onFocus` prop.\n   */\n  handleFocus: FocusEventHandler<ListElement>;\n\n  /**\n   * The keydown handler that should be passed to the tree list element that\n   * handles all the keyboard functionality and movement.\n   *\n   * This will also call the optional `onKeyDown` prop.\n   */\n  handleKeyDown: KeyboardEventHandler<ListElement>;\n}\n\n/**\n * This is a temporary workaround for allowing the navigation tree to scroll\n * correctly with keyboard movement since it manually sets the\n * `overflow: visible` which prevents scrolling. I'll need to think of a better\n * way to find/get the scrollable element (if any). It might also just go into\n * the `scrollIntoView` util.\n *\n * @remarks \\@since 2.5.3\n * @internal\n */\nconst getScrollContainer = (target: HTMLElement): HTMLElement | null => {\n  if (target.classList.contains(\"rmd-layout-tree\")) {\n    return target.parentElement;\n  }\n\n  return target;\n};\n\n/**\n * This hook handles all the complex and \"fun\" stuff for selecting keyboard\n * accessibility within a tree and enabling keyboard movement, selection, and\n * expansion.\n *\n * @internal\n */\nexport function useTreeMovement({\n  id,\n  data,\n  rootId,\n  sort,\n  onBlur,\n  onFocus,\n  onKeyDown,\n  multiSelect,\n  selectedIds,\n  onItemSelect,\n  onMultiItemSelect,\n  expandedIds,\n  onItemExpansion,\n  onMultiItemExpansion,\n  valueKey,\n  getItemValue,\n}: Options): ReturnValue {\n  const items = useNestedTreeList(data, sort, rootId);\n  const [visibleItems, itemIdRefs, flattenedItems] = useFlattenedTreeList({\n    id,\n    items,\n    expandedIds,\n    rootId,\n    valueKey,\n    getItemValue,\n  });\n\n  const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n\n  const {\n    activeId,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  } = useActiveDescendantMovement<\n    SearchableTreeItem,\n    ListElement,\n    HTMLLIElement\n  >({\n    ...MovementPresets.VERTICAL_TREE,\n    items: visibleItems,\n    baseId: id,\n    getId(_baseId, index) {\n      return (visibleItems[index] || { id: \"\" }).id;\n    },\n    onSpace(focusedIndex) {\n      const item = visibleItems[focusedIndex];\n      if (!item) {\n        return;\n      }\n\n      const { itemId } = item;\n      onItemSelect(itemId);\n    },\n    onChange(data) {\n      const { index, target, query } = data;\n      const { itemId } = visibleItems[index];\n      // Note: have to do a custom `scrollIntoView` here instead of relying on\n      // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the\n      // tree renders with the ref behavior.\n      const item = itemIdRefs[itemId].ref.current;\n      const container = getScrollContainer(target);\n      if (\n        item &&\n        container &&\n        container.scrollHeight > container.offsetHeight\n      ) {\n        scrollIntoView(container, item);\n      }\n\n      if (!multiSelect) {\n        return;\n      }\n\n      const isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);\n      const isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);\n      if (!isToStart && !isToEnd) {\n        return;\n      }\n\n      const start = isToStart ? 0 : focusedIndex;\n      const end = isToStart ? focusedIndex + 1 : undefined;\n      const jumpSelectedIds = visibleItems\n        .slice(start, end)\n        .map(({ itemId }) => itemId);\n      const uniqueSelectedIds = Array.from(\n        new Set([...selectedIds, ...jumpSelectedIds])\n      );\n      if (selectedIds.length !== uniqueSelectedIds.length) {\n        onMultiItemSelect(uniqueSelectedIds);\n      }\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const item = visibleItems[focusedIndex];\n      if (!item) {\n        return;\n      }\n\n      const { itemId, parentId, isParent } = item;\n      switch (event.key) {\n        case \"Enter\": {\n          if (isParent) {\n            onItemExpansion(itemId, !expandedIds.includes(itemId));\n            return;\n          }\n\n          const node = itemIdRefs[itemId].ref.current;\n          const anchor =\n            node &&\n            node.getAttribute(\"role\") === \"none\" &&\n            node.querySelector<HTMLAnchorElement>(\"a[href]\");\n          if (!anchor) {\n            onItemSelect(itemId);\n            return;\n          }\n\n          // if a user is navigating through the app with a keyboard and presses\n          // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will\n          // be forcefully opened in a new tab irregardless of the target\n          // attribute on the anchor tag. Since a tree doesn't actually focus\n          // the link in this case, need to \"polyfill\" it with this workaround.\n          // the `meta` key is for Mac and `ctrlKey` for Windows\n          const forceNewTab =\n            event.shiftKey && (event.metaKey || event.ctrlKey);\n\n          const prevTarget = anchor.target;\n          if (forceNewTab) {\n            anchor.target = \"_blank\";\n          }\n          anchor.click();\n          if (forceNewTab) {\n            anchor.target = prevTarget;\n          }\n\n          break;\n        }\n        case \"ArrowRight\":\n          if (!isParent) {\n            return;\n          }\n\n          if (!expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, true);\n          } else {\n            const nextIndex = focusedIndex + 1;\n            const nextItem =\n              itemIdRefs[visibleItems[nextIndex]?.itemId]?.ref.current;\n\n            setFocusedIndex(nextIndex);\n            scrollIntoView(event.currentTarget, nextItem);\n          }\n          break;\n        case \"ArrowLeft\":\n          if (isParent && expandedIds.includes(itemId)) {\n            onItemExpansion(itemId, false);\n          } else if (parentId !== rootId) {\n            const parentIndex = visibleItems.findIndex(\n              (item) => item.itemId === parentId\n            );\n            const parentItem =\n              itemIdRefs[visibleItems[parentIndex]?.itemId]?.ref.current;\n\n            setFocusedIndex(parentIndex);\n            scrollIntoView(event.currentTarget, parentItem);\n          }\n          break;\n        case \"a\": {\n          if (!multiSelect || !event.ctrlKey) {\n            return;\n          }\n\n          event.preventDefault();\n          const allItemIds = visibleItems.map(({ itemId }) => itemId);\n          if (selectedIds.length === allItemIds.length) {\n            onMultiItemSelect([]);\n          } else {\n            onMultiItemSelect(allItemIds);\n          }\n          break;\n        }\n        case \"*\": {\n          const item = visibleItems[focusedIndex];\n          if (!item) {\n            return;\n          }\n\n          const expectedExpandedIds = visibleItems\n            .filter(\n              ({ isParent, parentId }) => isParent && parentId === item.parentId\n            )\n            .map(({ itemId }) => itemId);\n          const nextIds = Array.from(\n            new Set([...expandedIds, ...expectedExpandedIds])\n          );\n          if (nextIds.length !== expandedIds.length) {\n            onMultiItemExpansion(nextIds);\n\n            // since new items will be rendered, need to also update the focused\n            // index so the currently active item is still the \"focused\" item\n            //\n            // TODO: Look into a much better way to handle this sort of stuff..\n            // This still doesn't correctly scroll the active element into view.\n            // I should probably move all the scroll behavior into a useEffect\n            // for whenever the focusedIndex changes.\n            let visibleCount = 0;\n            const lookup: Record<TreeItemId, boolean> = {};\n            for (let i = 0; i < flattenedItems.length; i += 1) {\n              const item = flattenedItems[i];\n              let isVisible = item.parentId === rootId;\n              if (item.parentId !== null && nextIds.includes(item.parentId)) {\n                isVisible = !!lookup[item.parentId];\n              }\n\n              lookup[item.itemId] = isVisible;\n\n              if (itemId === item.itemId) {\n                setFocusedIndex(visibleCount);\n                return;\n              }\n\n              if (isVisible) {\n                visibleCount += 1;\n              }\n            }\n          }\n        }\n        // no default\n      }\n    },\n  });\n\n  const lastFocus = useRef(0);\n  const handleBlur = useCallback(\n    (event: React.FocusEvent<ListElement>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      if (\n        document.activeElement &&\n        event.currentTarget.contains(document.activeElement)\n      ) {\n        return;\n      }\n\n      lastFocus.current = focusedIndex;\n      setFocusedIndex(-1);\n    },\n    [focusedIndex, onBlur, setFocusedIndex]\n  );\n\n  const handleFocus = useCallback(\n    (event: React.FocusEvent<ListElement>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      if (focusedIndex !== -1) {\n        // this happens when a tree item is clicked with the mouse or touch\n        return;\n      }\n\n      let index = -1;\n      // try to \"focus\" the first selected itemId if there is a selection.\n      if (selectedIds.length) {\n        index = visibleItems.findIndex((item) =>\n          selectedIds.includes(item.itemId)\n        );\n      }\n\n      // fallback to the first visible tree item if there were no selected ids\n      if (index === -1) {\n        index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));\n      }\n\n      const currentItem = itemIdRefs[visibleItems[index]?.itemId]?.ref.current;\n      if (currentItem && isKeyboard) {\n        scrollIntoView(getScrollContainer(event.currentTarget), currentItem);\n      }\n      setFocusedIndex(index);\n    },\n    [\n      focusedIndex,\n      isKeyboard,\n      itemIdRefs,\n      onFocus,\n      selectedIds,\n      setFocusedIndex,\n      visibleItems,\n    ]\n  );\n\n  const setActiveId = useCallback(\n    (itemId: TreeItemId) => {\n      const index = visibleItems.findIndex((item) => item.itemId === itemId);\n      if (index !== -1) {\n        setFocusedIndex(index);\n      }\n    },\n    [setFocusedIndex, visibleItems]\n  );\n\n  return {\n    items,\n    activeId,\n    setActiveId,\n    itemIdRefs,\n    handleBlur,\n    handleFocus,\n    handleKeyDown,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}