{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\nimport { GridCell } from \"./GridCell\";\n/**\n * This CSS Variable allows you to override the number of columns that should be\n * displayed in the grid. This is automatically updated with media queries with\n * the default grid implementation, but is used here to add additional\n * inline-style overrides.\n *\n * @internal\n */\nexport var GRID_COLUMNS_VAR = \"--rmd-grid-cols\";\n/**\n * This CSS Variable allows you to override the gutter (grid-gap) between each\n * cell in the grid.\n *\n * @internal\n */\nexport var GRID_GUTTER_VAR = \"--rmd-grid-gutter\";\nvar block = bem(\"rmd-grid\");\n/**\n * The grid component is generally used for a base layout in your app to provide\n * nice padding and spacing between each item.\n *\n * Note: This component relies on the `AppSizeListener` as a parent component to\n * work and will throw an error if it does not exist as a parent.\n */\nexport var Grid = forwardRef(function Grid(_a, ref) {\n  var _b;\n  var style = _a.style,\n    className = _a.className,\n    children = _a.children,\n    _c = _a.clone,\n    clone = _c === void 0 ? false : _c,\n    _d = _a.cloneStyles,\n    cloneStyles = _d === void 0 ? false : _d,\n    _e = _a.wrapOnly,\n    wrapOnly = _e === void 0 ? false : _e,\n    columns = _a.columns,\n    phoneColumns = _a.phoneColumns,\n    tabletColumns = _a.tabletColumns,\n    desktopColumns = _a.desktopColumns,\n    largeDesktopColumns = _a.largeDesktopColumns,\n    padding = _a.padding,\n    gutter = _a.gutter,\n    minCellWidth = _a.minCellWidth,\n    props = __rest(_a, [\"style\", \"className\", \"children\", \"clone\", \"cloneStyles\", \"wrapOnly\", \"columns\", \"phoneColumns\", \"tabletColumns\", \"desktopColumns\", \"largeDesktopColumns\", \"padding\", \"gutter\", \"minCellWidth\"]);\n  var _f = useAppSize(),\n    isPhone = _f.isPhone,\n    isTablet = _f.isTablet,\n    isDesktop = _f.isDesktop,\n    isLargeDesktop = _f.isLargeDesktop;\n  var mergedStyle = __assign(__assign({\n    padding: padding !== 0 && padding || undefined,\n    gridTemplateColumns: minCellWidth ? \"repeat(auto-fill, minmax(\".concat(minCellWidth, \", 1fr))\") : undefined\n  }, style), (_b = {}, _b[GRID_COLUMNS_VAR] = isPhone && phoneColumns || isTablet && tabletColumns || isLargeDesktop && largeDesktopColumns || isDesktop && desktopColumns || columns, _b[GRID_GUTTER_VAR] = gutter, _b));\n  var mergedClassName = cn(block({\n    \"no-padding\": padding === 0\n  }), className);\n  if (cloneStyles && isValidElement(children)) {\n    var child = Children.only(children);\n    return cloneElement(child, {\n      style: __assign(__assign({}, mergedStyle), child.props.style),\n      className: cn(mergedClassName, child.props.className)\n    });\n  }\n  var content = children;\n  if (clone || wrapOnly) {\n    content = Children.map(children, function (child) {\n      return child && _jsx(GridCell, __assign({\n        clone: clone\n      }, {\n        children: child\n      }));\n    });\n  }\n  return _jsx(\"div\", __assign({}, props, {\n    ref: ref,\n    style: mergedStyle,\n    className: mergedClassName\n  }, {\n    children: content\n  }));\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;AACA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,UAAU,EAAEC,cAAc,QAAQ,OAAO;AAC1E,OAAOC,EAAE,MAAM,YAAY;AAE3B,SAASC,GAAG,QAAQ,QAAQ;AAC5B,SAASC,UAAU,QAAQ,sBAAsB;AACjD,SAASC,QAAQ,QAAQ,YAAY;AAErC;;;;;;;;AAQA,OAAO,IAAMC,gBAAgB,GAAG,iBAAiB;AAEjD;;;;;;AAMA,OAAO,IAAMC,eAAe,GAAG,mBAAmB;AAkGlD,IAAMC,KAAK,GAAGL,GAAG,CAAC,UAAU,CAAC;AAE7B;;;;;;;AAOA,OAAO,IAAMM,IAAI,GAAGT,UAAU,CAA4B,SAASS,IAAI,CACrEC,EAgBC,EACDC,GAAG;;EAhBD,SAAK;IACLC,SAAS;IACTC,QAAQ;IACRC,aAAa;IAAbC,KAAK,mBAAG,KAAK;IACbC,mBAAmB;IAAnBC,WAAW,mBAAG,KAAK;IACnBC,gBAAgB;IAAhBC,QAAQ,mBAAG,KAAK;IAChBC,OAAO;IACPC,YAAY;IACZC,aAAa;IACbC,cAAc;IACdC,mBAAmB;IACnBC,OAAO;IACPC,MAAM;IACNC,YAAY;IACTC,KAAK,cAfV,gMAgBC,CADS;EAIJ,SAAmDxB,UAAU,EAAE;IAA7DyB,OAAO;IAAEC,QAAQ;IAAEC,SAAS;IAAEC,cAAc,oBAAiB;EAErE,IAAMC,WAAW;IACfR,OAAO,EAAGA,OAAO,KAAK,CAAC,IAAIA,OAAO,IAAKS,SAAS;IAChDC,mBAAmB,EAAER,YAAY,GAC7B,mCAA4BA,YAAY,YAAS,GACjDO;EAAS,GACVE,KAAK,gBACP9B,gBAAgB,IACduB,OAAO,IAAIR,YAAY,IACvBS,QAAQ,IAAIR,aAAc,IAC1BU,cAAc,IAAIR,mBAAoB,IACtCO,SAAS,IAAIR,cAAe,IAC7BH,OAAO,KACRb,eAAe,IAAGmB,MAAM,MAC1B;EACD,IAAMW,eAAe,GAAGnC,EAAE,CAACM,KAAK,CAAC;IAAE,YAAY,EAAEiB,OAAO,KAAK;EAAC,CAAE,CAAC,EAAEb,SAAS,CAAC;EAE7E,IAAIK,WAAW,IAAIhB,cAAc,CAACY,QAAQ,CAAC,EAAE;IAC3C,IAAMyB,KAAK,GAAGxC,QAAQ,CAACyC,IAAI,CAAC1B,QAAQ,CAAC;IAErC,OAAOd,YAAY,CAACuC,KAAK,EAAE;MACzBF,KAAK,wBAAOH,WAAW,GAAKK,KAAK,CAACV,KAAK,CAACQ,KAAK,CAAE;MAC/CxB,SAAS,EAAEV,EAAE,CAACmC,eAAe,EAAEC,KAAK,CAACV,KAAK,CAAChB,SAAS;KACrD,CAAC;;EAGJ,IAAI4B,OAAO,GAAG3B,QAAQ;EACtB,IAAIE,KAAK,IAAII,QAAQ,EAAE;IACrBqB,OAAO,GAAG1C,QAAQ,CAAC2C,GAAG,CACpB5B,QAAQ,EACR,UAACyB,KAAK;MAAK,YAAK,IAAII,KAACrC,QAAQ;QAACU,KAAK,EAAEA;MAAK;QAAAF,UAAGyB;MAAK,GAAY;IAAnD,CAAmD,CAC/D;;EAGH,OACEI,yBAASd,KAAK;IAAEjB,GAAG,EAAEA,GAAG;IAAEyB,KAAK,EAAEH,WAAW;IAAErB,SAAS,EAAEyB;EAAe;IAAAxB,UACrE2B;EAAO,GACJ;AAEV,CAAC,CAAC","names":["Children","cloneElement","forwardRef","isValidElement","cn","bem","useAppSize","GridCell","GRID_COLUMNS_VAR","GRID_GUTTER_VAR","block","Grid","_a","ref","className","children","_c","clone","_d","cloneStyles","_e","wrapOnly","columns","phoneColumns","tabletColumns","desktopColumns","largeDesktopColumns","padding","gutter","minCellWidth","props","isPhone","isTablet","isDesktop","isLargeDesktop","mergedStyle","undefined","gridTemplateColumns","style","mergedClassName","child","only","content","map","_jsx"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/layout/Grid.tsx"],"sourcesContent":["import type { HTMLAttributes } from \"react\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\n\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\nimport { GridCell } from \"./GridCell\";\n\n/**\n * This CSS Variable allows you to override the number of columns that should be\n * displayed in the grid. This is automatically updated with media queries with\n * the default grid implementation, but is used here to add additional\n * inline-style overrides.\n *\n * @internal\n */\nexport const GRID_COLUMNS_VAR = \"--rmd-grid-cols\";\n\n/**\n * This CSS Variable allows you to override the gutter (grid-gap) between each\n * cell in the grid.\n *\n * @internal\n */\nexport const GRID_GUTTER_VAR = \"--rmd-grid-gutter\";\n\nexport interface GridProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * Boolean if the `children` should have the grid `style` and `className`\n   * props cloned using `React.cloneElement`. This is useful if you just want to\n   * use the grid styles without the additional wrapper `<div>`.\n   *\n   * Note: if this prop is provided, all of the `HTMLAttributes` props will be\n   * ignored as well as the `clone` and `wrapOnly` props.\n   *\n   * @remarks \\@since 2.3.0\n   */\n  cloneStyles?: boolean;\n\n  /**\n   * Boolean if the `children` should be updated to be wrapped in the `GridCell`\n   * component and clone the `className` into each child automatically. This is\n   * really just a convenience prop so you don't always need to import both the\n   * `Grid` and `GridCell` components to create a grid.\n   */\n  clone?: boolean;\n\n  /**\n   * Boolean if the `children` should be updated to be wrapped in the `GridCell`\n   * component.  This is really just a convenience prop so you don't always need\n   * to import both the `Grid` and `GridCell` components to create a grid/\n   */\n  wrapOnly?: boolean;\n\n  /**\n   * This prop allows you to generate your grid with a dynamic amount of columns\n   * instead of a static size. This will update the grid to ignore all the\n   * `columns` props and update the grid to show as many columns as possible by\n   * updating the `grid-template-columns` style to be:\n   *\n   * ```scss\n   * grid-template-columns: repeat(auto-fill, minmax($min-cell-width, 1fr));\n   * ```\n   *\n   * This **needs to be a number with a unit**. Check out the documentation on\n   * the `minmax` css function for some more info.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/minmax\n   */\n  minCellWidth?: \"min-content\" | \"max-content\" | \"auto\" | string;\n\n  /**\n   * An optional number of columns to apply for all media types. Providing one\n   * of the media-specific column props will override this value for those\n   * breakpoints still.\n   */\n  columns?: number;\n\n  /**\n   * An optional number of columns to display for phones.\n   */\n  phoneColumns?: number;\n\n  /**\n   * An optional number of columns to display for tablets.\n   */\n  tabletColumns?: number;\n\n  /**\n   * An optional number of columns to display for desktop screens.\n   */\n  desktopColumns?: number;\n\n  /**\n   * An optional number of columns to display for large desktop screens.\n   */\n  largeDesktopColumns?: number;\n\n  /**\n   * This is really just a pass-through of the `style` prop that allows you to\n   * quickly update the base padding for the grid.\n   */\n  padding?: number | string;\n\n  /**\n   * This will override the default grid cell's gutter value (the space between\n   * each cell). This **needs to be a number with a unit** since it is set to a\n   * css variable. Examples:\n   *\n   * - `1rem`\n   * - `16px`\n   * - `1em`\n   * - `5%`\n   */\n  gutter?: string;\n}\n\ntype CSSProperties = React.CSSProperties & {\n  [GRID_GUTTER_VAR]?: string;\n  [GRID_COLUMNS_VAR]?: number;\n};\n\nconst block = bem(\"rmd-grid\");\n\n/**\n * The grid component is generally used for a base layout in your app to provide\n * nice padding and spacing between each item.\n *\n * Note: This component relies on the `AppSizeListener` as a parent component to\n * work and will throw an error if it does not exist as a parent.\n */\nexport const Grid = forwardRef<HTMLDivElement, GridProps>(function Grid(\n  {\n    style,\n    className,\n    children,\n    clone = false,\n    cloneStyles = false,\n    wrapOnly = false,\n    columns,\n    phoneColumns,\n    tabletColumns,\n    desktopColumns,\n    largeDesktopColumns,\n    padding,\n    gutter,\n    minCellWidth,\n    ...props\n  },\n  ref\n) {\n  const { isPhone, isTablet, isDesktop, isLargeDesktop } = useAppSize();\n\n  const mergedStyle: CSSProperties = {\n    padding: (padding !== 0 && padding) || undefined,\n    gridTemplateColumns: minCellWidth\n      ? `repeat(auto-fill, minmax(${minCellWidth}, 1fr))`\n      : undefined,\n    ...style,\n    [GRID_COLUMNS_VAR]:\n      (isPhone && phoneColumns) ||\n      (isTablet && tabletColumns) ||\n      (isLargeDesktop && largeDesktopColumns) ||\n      (isDesktop && desktopColumns) ||\n      columns,\n    [GRID_GUTTER_VAR]: gutter,\n  };\n  const mergedClassName = cn(block({ \"no-padding\": padding === 0 }), className);\n\n  if (cloneStyles && isValidElement(children)) {\n    const child = Children.only(children);\n\n    return cloneElement(child, {\n      style: { ...mergedStyle, ...child.props.style },\n      className: cn(mergedClassName, child.props.className),\n    });\n  }\n\n  let content = children;\n  if (clone || wrapOnly) {\n    content = Children.map(\n      children,\n      (child) => child && <GridCell clone={clone}>{child}</GridCell>\n    );\n  }\n\n  return (\n    <div {...props} ref={ref} style={mergedStyle} className={mergedClassName}>\n      {content}\n    </div>\n  );\n});\n"]},"metadata":{},"sourceType":"module"}