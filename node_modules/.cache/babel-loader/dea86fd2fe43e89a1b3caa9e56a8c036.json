{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport { MovementPresets, scrollIntoView, useActiveDescendantMovement, useCloseOnOutsideClick, useEnsuredRef, useIsUserInteractionMode, useToggle } from \"@react-md/utils\";\nimport { getFilterFunction } from \"./utils\";\n/**\n * This hook handles all the autocomplete's \"logic\" and behavior.\n *\n * @internal\n */\nexport function useAutoComplete(_a) {\n  var _b;\n  var suggestionsId = _a.suggestionsId,\n    data = _a.data,\n    propValue = _a.propValue,\n    _c = _a.defaultValue,\n    defaultValue = _c === void 0 ? \"\" : _c,\n    filterFn = _a.filter,\n    filterOptions = _a.filterOptions,\n    filterOnNoValue = _a.filterOnNoValue,\n    valueKey = _a.valueKey,\n    getResultId = _a.getResultId,\n    getResultValue = _a.getResultValue,\n    onBlur = _a.onBlur,\n    onFocus = _a.onFocus,\n    onClick = _a.onClick,\n    onChange = _a.onChange,\n    onKeyDown = _a.onKeyDown,\n    forwardedRef = _a.forwardedRef,\n    onAutoComplete = _a.onAutoComplete,\n    clearOnAutoComplete = _a.clearOnAutoComplete,\n    anchor = _a.anchor,\n    xMargin = _a.xMargin,\n    yMargin = _a.yMargin,\n    vwMargin = _a.vwMargin,\n    vhMargin = _a.vhMargin,\n    transformOrigin = _a.transformOrigin,\n    listboxWidth = _a.listboxWidth,\n    listboxStyle = _a.listboxStyle,\n    preventOverlap = _a.preventOverlap,\n    disableSwapping = _a.disableSwapping,\n    disableVHBounds = _a.disableVHBounds,\n    closeOnResize = _a.closeOnResize,\n    closeOnScroll = _a.closeOnScroll,\n    propDisableShowOnFocus = _a.disableShowOnFocus,\n    isListAutocomplete = _a.isListAutocomplete,\n    isInlineAutocomplete = _a.isInlineAutocomplete;\n  var _d = __read(useEnsuredRef(forwardedRef), 2),\n    ref = _d[0],\n    refHandler = _d[1];\n  var filter = getFilterFunction(filterFn);\n  var _e = __read(useState(function () {\n      var _a;\n      var options = __assign(__assign({}, filterOptions), {\n        valueKey: valueKey,\n        getItemValue: getResultValue,\n        startsWith: (_a = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _a !== void 0 ? _a : isInlineAutocomplete\n      });\n      var value = propValue !== null && propValue !== void 0 ? propValue : defaultValue;\n      var filteredData = filterOnNoValue || value ? filter(value, data, options) : data;\n      var match = value;\n      if (isInlineAutocomplete && filteredData.length) {\n        match = getResultValue(filteredData[0], valueKey);\n      }\n      return {\n        value: value,\n        match: match,\n        filteredData: filteredData\n      };\n    }), 2),\n    _f = _e[0],\n    stateValue = _f.value,\n    match = _f.match,\n    stateFilteredData = _f.filteredData,\n    setState = _e[1];\n  var filteredData = filterFn === \"none\" ? data : stateFilteredData;\n  var startsWith = (_b = filterOptions === null || filterOptions === void 0 ? void 0 : filterOptions.startsWith) !== null && _b !== void 0 ? _b : isInlineAutocomplete;\n  var value = propValue !== null && propValue !== void 0 ? propValue : stateValue;\n  var setValue = useCallback(function (nextValue) {\n    var isBackspace = value.length > nextValue.length || !!match && value.length === nextValue.length;\n    var filtered = data;\n    if (nextValue || filterOnNoValue) {\n      var options = __assign(__assign({}, filterOptions), {\n        valueKey: valueKey,\n        getItemValue: getResultValue,\n        startsWith: startsWith\n      });\n      filtered = filter(nextValue, data, options);\n    }\n    var nextMatch = nextValue;\n    if (isInlineAutocomplete && filtered.length && !isBackspace) {\n      nextMatch = getResultValue(filtered[0], valueKey);\n      var input = ref.current;\n      if (input && !isBackspace) {\n        input.value = nextMatch;\n        input.setSelectionRange(nextValue.length, nextMatch.length);\n      }\n    }\n    setState({\n      value: nextValue,\n      match: nextMatch,\n      filteredData: filtered\n    });\n  }, [ref, data, filter, filterOnNoValue, filterOptions, isInlineAutocomplete, getResultValue, value, match, startsWith, valueKey]);\n  // this is really just a hacky way to make sure that once a value has been\n  // autocompleted, the menu doesn't immediately re-appear due to the hook below\n  // for showing when the value/ filtered data list change\n  var autocompleted = useRef(false);\n  var handleChange = useCallback(function (event) {\n    if (onChange) {\n      onChange(event);\n    }\n    autocompleted.current = false;\n    setValue(event.currentTarget.value);\n  }, [setValue, onChange]);\n  var _g = __read(useToggle(false), 3),\n    visible = _g[0],\n    show = _g[1],\n    hide = _g[2];\n  var isTouch = useIsUserInteractionMode(\"touch\");\n  var disableShowOnFocus = propDisableShowOnFocus !== null && propDisableShowOnFocus !== void 0 ? propDisableShowOnFocus : isTouch;\n  var focused = useRef(false);\n  var handleBlur = useCallback(function (event) {\n    if (onBlur) {\n      onBlur(event);\n    }\n    focused.current = false;\n  }, [onBlur]);\n  var handleFocus = useCallback(function (event) {\n    if (onFocus) {\n      onFocus(event);\n    }\n    if (disableShowOnFocus) {\n      return;\n    }\n    focused.current = true;\n    if (isListAutocomplete && filteredData.length) {\n      show();\n    }\n  }, [filteredData, isListAutocomplete, onFocus, show, disableShowOnFocus]);\n  var handleClick = useCallback(function (event) {\n    if (onClick) {\n      onClick(event);\n    }\n    // since click events also trigger focus events right beforehand, want to\n    // skip the first click handler and require a second click to show it.\n    // this is why the focused.current isn't set onFocus for\n    // disableShowOnFocus\n    if (disableShowOnFocus && !focused.current) {\n      focused.current = true;\n      return;\n    }\n    if (isListAutocomplete && filteredData.length) {\n      show();\n    }\n  }, [disableShowOnFocus, filteredData.length, isListAutocomplete, onClick, show]);\n  var handleAutoComplete = useCallback(function (index) {\n    var result = filteredData[index];\n    var resultValue = getResultValue(result, valueKey);\n    if (onAutoComplete) {\n      onAutoComplete({\n        value: resultValue,\n        index: index,\n        result: result,\n        dataIndex: data.findIndex(function (datum) {\n          return getResultValue(datum, valueKey) === resultValue;\n        }),\n        filteredData: filteredData\n      });\n    }\n    setValue(clearOnAutoComplete ? \"\" : resultValue);\n    autocompleted.current = true;\n  }, [clearOnAutoComplete, data, filteredData, getResultValue, onAutoComplete, valueKey, setValue]);\n  var nodeRef = useRef(null);\n  var _h = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_COMBOBOX), {\n      getId: getResultId,\n      items: filteredData,\n      baseId: suggestionsId,\n      onChange: function (_a, itemRefs) {\n        var index = _a.index,\n          items = _a.items,\n          target = _a.target;\n        // the default scroll into view behavior for aria-activedescendant\n        // movement won't work here since the \"target\" element will actually be\n        // the input element instead of the listbox. So need to implement the\n        // scroll into view behavior manually from the listbox instead.\n        var item = itemRefs[index] && itemRefs[index].current;\n        var listbox = nodeRef.current;\n        if (item && listbox && listbox.scrollHeight > listbox.offsetHeight) {\n          scrollIntoView(listbox, item);\n        }\n        if (!isInlineAutocomplete) {\n          return;\n        }\n        var nextMatch = getResultValue(items[index], valueKey);\n        target.value = nextMatch;\n        target.setSelectionRange(0, nextMatch.length);\n        setState(function (prevState) {\n          return __assign(__assign({}, prevState), {\n            value: nextMatch,\n            match: nextMatch\n          });\n        });\n      },\n      onKeyDown: function (event) {\n        if (onKeyDown) {\n          onKeyDown(event);\n        }\n        var input = event.currentTarget;\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (isListAutocomplete && event.altKey && !visible && filteredData.length) {\n              // don't want the cursor to move if there is text\n              event.preventDefault();\n              event.stopPropagation();\n              show();\n              setFocusedIndex(-1);\n            }\n            break;\n          case \"ArrowUp\":\n            if (isListAutocomplete && event.altKey && visible) {\n              // don't want the cursor to move if there is text\n              event.preventDefault();\n              event.stopPropagation();\n              hide();\n            }\n            break;\n          case \"Tab\":\n            event.stopPropagation();\n            hide();\n            break;\n          case \"ArrowRight\":\n            if (isInlineAutocomplete && input.selectionStart !== input.selectionEnd) {\n              var index = focusedIndex !== -1 ? focusedIndex : 0;\n              hide();\n              handleAutoComplete(index);\n            }\n            break;\n          case \"Enter\":\n            if (visible && focusedIndex >= 0) {\n              event.stopPropagation();\n              handleAutoComplete(focusedIndex);\n              hide();\n            }\n            break;\n          case \"Escape\":\n            if (visible) {\n              event.stopPropagation();\n              hide();\n            } else if (value) {\n              event.stopPropagation();\n              setValue(\"\");\n            }\n            break;\n          // no default\n        }\n      }\n    })),\n    activeId = _h.activeId,\n    itemRefs = _h.itemRefs,\n    handleKeyDown = _h.onKeyDown,\n    focusedIndex = _h.focusedIndex,\n    setFocusedIndex = _h.setFocusedIndex;\n  useCloseOnOutsideClick({\n    enabled: visible,\n    element: ref.current,\n    onOutsideClick: hide\n  });\n  var _j = useFixedPositioning({\n      fixedTo: ref,\n      nodeRef: nodeRef,\n      anchor: anchor,\n      onScroll: function (_event, _a) {\n        var visible = _a.visible;\n        if (closeOnScroll || !visible) {\n          hide();\n        }\n      },\n      onResize: closeOnResize ? hide : undefined,\n      width: listboxWidth,\n      xMargin: xMargin,\n      yMargin: yMargin,\n      vwMargin: vwMargin,\n      vhMargin: vhMargin,\n      transformOrigin: transformOrigin,\n      preventOverlap: preventOverlap,\n      disableSwapping: disableSwapping,\n      disableVHBounds: disableVHBounds\n    }),\n    listboxRef = _j.ref,\n    style = _j.style,\n    callbacks = _j.callbacks,\n    updateStyle = _j.updateStyle;\n  useEffect(function () {\n    if (!focused.current || autocompleted.current) {\n      return;\n    }\n    if (filteredData.length && !visible && value.length && isListAutocomplete) {\n      show();\n    } else if (!filteredData.length && visible) {\n      hide();\n    }\n    // this effect is just for toggling the visibility states as needed if the\n    // value or filter data list changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filteredData, value]);\n  useEffect(function () {\n    if (!visible) {\n      setFocusedIndex(-1);\n      return;\n    }\n    updateStyle();\n    // only want to trigger on data changes and setFocusedIndex shouldn't change\n    // anyways\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [visible, filteredData]);\n  return {\n    ref: refHandler,\n    value: value,\n    match: match,\n    visible: visible,\n    activeId: activeId,\n    itemRefs: itemRefs,\n    filteredData: filteredData,\n    fixedStyle: __assign(__assign({}, style), listboxStyle),\n    transitionHooks: callbacks,\n    listboxRef: listboxRef,\n    handleBlur: handleBlur,\n    handleFocus: handleFocus,\n    handleClick: handleClick,\n    handleChange: handleChange,\n    handleKeyDown: handleKeyDown,\n    handleAutoComplete: handleAutoComplete\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","useFixedPositioning","MovementPresets","scrollIntoView","useActiveDescendantMovement","useCloseOnOutsideClick","useEnsuredRef","useIsUserInteractionMode","useToggle","getFilterFunction","useAutoComplete","_a","suggestionsId","data","propValue","_c","defaultValue","filterFn","filterOptions","filterOnNoValue","valueKey","getResultId","getResultValue","onBlur","onFocus","onClick","onChange","onKeyDown","forwardedRef","onAutoComplete","clearOnAutoComplete","anchor","xMargin","yMargin","vwMargin","vhMargin","transformOrigin","listboxWidth","listboxStyle","preventOverlap","disableSwapping","disableVHBounds","closeOnResize","closeOnScroll","propDisableShowOnFocus","isListAutocomplete","isInlineAutocomplete","ref","refHandler","filter","options","getItemValue","startsWith","value","filteredData","match","length","_f","stateValue","stateFilteredData","setState","setValue","nextValue","isBackspace","filtered","nextMatch","input","current","setSelectionRange","autocompleted","handleChange","event","currentTarget","visible","show","hide","isTouch","disableShowOnFocus","focused","handleBlur","handleFocus","handleClick","handleAutoComplete","index","result","resultValue","dataIndex","findIndex","datum","nodeRef","VERTICAL_COMBOBOX","getId","items","baseId","itemRefs","target","item","listbox","scrollHeight","offsetHeight","prevState","key","altKey","preventDefault","stopPropagation","setFocusedIndex","selectionStart","selectionEnd","focusedIndex","activeId","handleKeyDown","enabled","element","onOutsideClick","fixedTo","onScroll","_event","onResize","undefined","width","listboxRef","style","callbacks","updateStyle","fixedStyle","transitionHooks"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/autocomplete/src/useAutoComplete.ts"],"sourcesContent":["import type {\n  ChangeEventHandler,\n  CSSProperties,\n  FocusEventHandler,\n  HTMLAttributes,\n  KeyboardEventHandler,\n  MouseEventHandler,\n  Ref,\n} from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { ListElement } from \"@react-md/list\";\nimport type { FixedPositioningTransitionCallbacks } from \"@react-md/transition\";\nimport { useFixedPositioning } from \"@react-md/transition\";\nimport type { ItemRefList } from \"@react-md/utils\";\nimport {\n  MovementPresets,\n  scrollIntoView,\n  useActiveDescendantMovement,\n  useCloseOnOutsideClick,\n  useEnsuredRef,\n  useIsUserInteractionMode,\n  useToggle,\n} from \"@react-md/utils\";\n\nimport type {\n  AutoCompleteData,\n  AutoCompleteListboxPositionOptions,\n  AutoCompleteProps,\n} from \"./types\";\nimport { getFilterFunction } from \"./utils\";\n\ntype EventHandlers = Pick<\n  HTMLAttributes<HTMLInputElement>,\n  \"onBlur\" | \"onFocus\" | \"onChange\" | \"onClick\" | \"onKeyDown\"\n>;\n\nexport type RequiredAutoCompleteProps = Required<\n  Pick<\n    AutoCompleteProps,\n    | \"data\"\n    | \"filter\"\n    | \"filterOptions\"\n    | \"filterOnNoValue\"\n    | \"valueKey\"\n    | \"getResultId\"\n    | \"getResultValue\"\n    | \"clearOnAutoComplete\"\n  >\n>;\n\nexport type OptionalAutoCompleteProps = Pick<\n  AutoCompleteProps,\n  \"onAutoComplete\" | \"disableShowOnFocus\"\n>;\n\nexport interface AutoCompleteOptions\n  extends EventHandlers,\n    OptionalAutoCompleteProps,\n    RequiredAutoCompleteProps,\n    AutoCompleteListboxPositionOptions {\n  isListAutocomplete: boolean;\n  isInlineAutocomplete: boolean;\n  forwardedRef?: Ref<HTMLInputElement>;\n  suggestionsId: string;\n  propValue?: string;\n  defaultValue?: string;\n}\n\nexport interface AutoCompleteReturnValue {\n  ref: (instance: HTMLInputElement | null) => void;\n  match: string;\n  value: string;\n  visible: boolean;\n  activeId: string;\n  itemRefs: ItemRefList<HTMLLIElement>;\n  filteredData: readonly AutoCompleteData[];\n  listboxRef: Ref<ListElement>;\n  handleBlur: FocusEventHandler<HTMLInputElement>;\n  handleFocus: FocusEventHandler<HTMLInputElement>;\n  handleClick: MouseEventHandler<HTMLInputElement>;\n  handleChange: ChangeEventHandler<HTMLInputElement>;\n  handleKeyDown: KeyboardEventHandler<HTMLInputElement>;\n  handleAutoComplete: (index: number) => void;\n  fixedStyle: CSSProperties | undefined;\n  transitionHooks: Required<FixedPositioningTransitionCallbacks>;\n}\n\n/**\n * This hook handles all the autocomplete's \"logic\" and behavior.\n *\n * @internal\n */\nexport function useAutoComplete({\n  suggestionsId,\n  data,\n  propValue,\n  defaultValue = \"\",\n  filter: filterFn,\n  filterOptions,\n  filterOnNoValue,\n  valueKey,\n  getResultId,\n  getResultValue,\n  onBlur,\n  onFocus,\n  onClick,\n  onChange,\n  onKeyDown,\n  forwardedRef,\n  onAutoComplete,\n  clearOnAutoComplete,\n  anchor,\n  xMargin,\n  yMargin,\n  vwMargin,\n  vhMargin,\n  transformOrigin,\n  listboxWidth,\n  listboxStyle,\n  preventOverlap,\n  disableSwapping,\n  disableVHBounds,\n  closeOnResize,\n  closeOnScroll,\n  disableShowOnFocus: propDisableShowOnFocus,\n  isListAutocomplete,\n  isInlineAutocomplete,\n}: AutoCompleteOptions): AutoCompleteReturnValue {\n  const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n  const filter = getFilterFunction(filterFn);\n  const [\n    { value: stateValue, match, filteredData: stateFilteredData },\n    setState,\n  ] = useState(() => {\n    const options = {\n      ...filterOptions,\n      valueKey,\n      getItemValue: getResultValue,\n      startsWith: filterOptions?.startsWith ?? isInlineAutocomplete,\n    };\n    const value = propValue ?? defaultValue;\n    const filteredData =\n      filterOnNoValue || value ? filter(value, data, options) : data;\n\n    let match = value;\n    if (isInlineAutocomplete && filteredData.length) {\n      match = getResultValue(filteredData[0], valueKey);\n    }\n\n    return {\n      value,\n      match,\n      filteredData,\n    };\n  });\n  const filteredData = filterFn === \"none\" ? data : stateFilteredData;\n  const startsWith = filterOptions?.startsWith ?? isInlineAutocomplete;\n  const value = propValue ?? stateValue;\n\n  const setValue = useCallback(\n    (nextValue: string) => {\n      const isBackspace =\n        value.length > nextValue.length ||\n        (!!match && value.length === nextValue.length);\n\n      let filtered = data;\n      if (nextValue || filterOnNoValue) {\n        const options = {\n          ...filterOptions,\n          valueKey,\n          getItemValue: getResultValue,\n          startsWith,\n        };\n\n        filtered = filter(nextValue, data, options);\n      }\n\n      let nextMatch = nextValue;\n      if (isInlineAutocomplete && filtered.length && !isBackspace) {\n        nextMatch = getResultValue(filtered[0], valueKey);\n\n        const input = ref.current;\n        if (input && !isBackspace) {\n          input.value = nextMatch;\n          input.setSelectionRange(nextValue.length, nextMatch.length);\n        }\n      }\n\n      setState({ value: nextValue, match: nextMatch, filteredData: filtered });\n    },\n    [\n      ref,\n      data,\n      filter,\n      filterOnNoValue,\n      filterOptions,\n      isInlineAutocomplete,\n      getResultValue,\n      value,\n      match,\n      startsWith,\n      valueKey,\n    ]\n  );\n\n  // this is really just a hacky way to make sure that once a value has been\n  // autocompleted, the menu doesn't immediately re-appear due to the hook below\n  // for showing when the value/ filtered data list change\n  const autocompleted = useRef(false);\n\n  const handleChange = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      if (onChange) {\n        onChange(event);\n      }\n\n      autocompleted.current = false;\n      setValue(event.currentTarget.value);\n    },\n    [setValue, onChange]\n  );\n\n  const [visible, show, hide] = useToggle(false);\n  const isTouch = useIsUserInteractionMode(\"touch\");\n  const disableShowOnFocus = propDisableShowOnFocus ?? isTouch;\n\n  const focused = useRef(false);\n  const handleBlur = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      if (onBlur) {\n        onBlur(event);\n      }\n\n      focused.current = false;\n    },\n    [onBlur]\n  );\n  const handleFocus = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      if (onFocus) {\n        onFocus(event);\n      }\n\n      if (disableShowOnFocus) {\n        return;\n      }\n\n      focused.current = true;\n      if (isListAutocomplete && filteredData.length) {\n        show();\n      }\n    },\n    [filteredData, isListAutocomplete, onFocus, show, disableShowOnFocus]\n  );\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLInputElement>) => {\n      if (onClick) {\n        onClick(event);\n      }\n\n      // since click events also trigger focus events right beforehand, want to\n      // skip the first click handler and require a second click to show it.\n      // this is why the focused.current isn't set onFocus for\n      // disableShowOnFocus\n      if (disableShowOnFocus && !focused.current) {\n        focused.current = true;\n        return;\n      }\n\n      if (isListAutocomplete && filteredData.length) {\n        show();\n      }\n    },\n    [disableShowOnFocus, filteredData.length, isListAutocomplete, onClick, show]\n  );\n\n  const handleAutoComplete = useCallback(\n    (index: number) => {\n      const result = filteredData[index];\n      const resultValue = getResultValue(result, valueKey);\n      if (onAutoComplete) {\n        onAutoComplete({\n          value: resultValue,\n          index,\n          result,\n          dataIndex: data.findIndex(\n            (datum) => getResultValue(datum, valueKey) === resultValue\n          ),\n          filteredData,\n        });\n      }\n\n      setValue(clearOnAutoComplete ? \"\" : resultValue);\n      autocompleted.current = true;\n    },\n    [\n      clearOnAutoComplete,\n      data,\n      filteredData,\n      getResultValue,\n      onAutoComplete,\n      valueKey,\n      setValue,\n    ]\n  );\n\n  const nodeRef = useRef<ListElement | null>(null);\n  const {\n    activeId,\n    itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  } = useActiveDescendantMovement<\n    AutoCompleteData,\n    HTMLInputElement,\n    HTMLLIElement\n  >({\n    ...MovementPresets.VERTICAL_COMBOBOX,\n    getId: getResultId,\n    items: filteredData,\n    baseId: suggestionsId,\n    onChange({ index, items, target }, itemRefs) {\n      // the default scroll into view behavior for aria-activedescendant\n      // movement won't work here since the \"target\" element will actually be\n      // the input element instead of the listbox. So need to implement the\n      // scroll into view behavior manually from the listbox instead.\n      const item = itemRefs[index] && itemRefs[index].current;\n      const { current: listbox } = nodeRef;\n      if (item && listbox && listbox.scrollHeight > listbox.offsetHeight) {\n        scrollIntoView(listbox, item);\n      }\n\n      if (!isInlineAutocomplete) {\n        return;\n      }\n\n      const nextMatch = getResultValue(items[index], valueKey);\n      target.value = nextMatch;\n      target.setSelectionRange(0, nextMatch.length);\n      setState((prevState) => ({\n        ...prevState,\n        value: nextMatch,\n        match: nextMatch,\n      }));\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const input = event.currentTarget;\n      switch (event.key) {\n        case \"ArrowDown\":\n          if (\n            isListAutocomplete &&\n            event.altKey &&\n            !visible &&\n            filteredData.length\n          ) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            show();\n            setFocusedIndex(-1);\n          }\n          break;\n        case \"ArrowUp\":\n          if (isListAutocomplete && event.altKey && visible) {\n            // don't want the cursor to move if there is text\n            event.preventDefault();\n            event.stopPropagation();\n            hide();\n          }\n          break;\n        case \"Tab\":\n          event.stopPropagation();\n          hide();\n          break;\n        case \"ArrowRight\":\n          if (\n            isInlineAutocomplete &&\n            input.selectionStart !== input.selectionEnd\n          ) {\n            const index = focusedIndex !== -1 ? focusedIndex : 0;\n            hide();\n            handleAutoComplete(index);\n          }\n          break;\n        case \"Enter\":\n          if (visible && focusedIndex >= 0) {\n            event.stopPropagation();\n            handleAutoComplete(focusedIndex);\n            hide();\n          }\n          break;\n        case \"Escape\":\n          if (visible) {\n            event.stopPropagation();\n            hide();\n          } else if (value) {\n            event.stopPropagation();\n            setValue(\"\");\n          }\n          break;\n        // no default\n      }\n    },\n  });\n\n  useCloseOnOutsideClick({\n    enabled: visible,\n    element: ref.current,\n    onOutsideClick: hide,\n  });\n\n  const {\n    ref: listboxRef,\n    style,\n    callbacks,\n    updateStyle,\n  } = useFixedPositioning({\n    fixedTo: ref,\n    nodeRef,\n    anchor,\n    onScroll(_event, { visible }) {\n      if (closeOnScroll || !visible) {\n        hide();\n      }\n    },\n    onResize: closeOnResize ? hide : undefined,\n    width: listboxWidth,\n    xMargin,\n    yMargin,\n    vwMargin,\n    vhMargin,\n    transformOrigin,\n    preventOverlap,\n    disableSwapping,\n    disableVHBounds,\n  });\n\n  useEffect(() => {\n    if (!focused.current || autocompleted.current) {\n      return;\n    }\n\n    if (filteredData.length && !visible && value.length && isListAutocomplete) {\n      show();\n    } else if (!filteredData.length && visible) {\n      hide();\n    }\n\n    // this effect is just for toggling the visibility states as needed if the\n    // value or filter data list changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filteredData, value]);\n\n  useEffect(() => {\n    if (!visible) {\n      setFocusedIndex(-1);\n      return;\n    }\n\n    updateStyle();\n\n    // only want to trigger on data changes and setFocusedIndex shouldn't change\n    // anyways\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [visible, filteredData]);\n\n  return {\n    ref: refHandler,\n    value,\n    match,\n    visible,\n    activeId,\n    itemRefs,\n    filteredData,\n    fixedStyle: { ...style, ...listboxStyle },\n    transitionHooks: callbacks,\n    listboxRef,\n    handleBlur,\n    handleFocus,\n    handleClick,\n    handleChange,\n    handleKeyDown,\n    handleAutoComplete,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}