{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { nanoid } from \"nanoid\";\n/**\n * An error that will be created if a user tries dragging and dropping files\n * from a shared directory that they do not have access to. This error will not\n * occur much.\n *\n * @remarks \\@since 2.9.0\n */\nvar FileAccessError = /** @class */function (_super) {\n  __extends(FileAccessError, _super);\n  /**\n   *\n   * @param message - An optional message for the error.\n   */\n  function FileAccessError(message) {\n    var _this = _super.call(this, message) || this;\n    _this.key = nanoid();\n    _this.name = \"FileAccessError\";\n    return _this;\n  }\n  return FileAccessError;\n}(Error);\nexport { FileAccessError };\n/**\n * An error that just requires a `File` to be passed as the first argument.\n *\n * @remarks \\@since 2.9.0\n */\nvar GenericFileError = /** @class */function (_super) {\n  __extends(GenericFileError, _super);\n  /**\n   *\n   * @param files - A list of files that caused the error.\n   * @param reason - An optional reason for the error\n   */\n  function GenericFileError(files, reason) {\n    var _this = _super.call(this, \"Invalid files\") || this;\n    _this.files = files;\n    _this.reason = reason;\n    _this.key = nanoid();\n    _this.name = \"GenericFileError\";\n    return _this;\n  }\n  return GenericFileError;\n}(Error);\nexport { GenericFileError };\n/**\n * An error that is created during the upload process if the number of files\n * exceeds the {@link FileUploadOptions.maxFiles} amount.\n *\n * @remarks \\@since 2.9.0\n */\nvar TooManyFilesError = /** @class */function (_super) {\n  __extends(TooManyFilesError, _super);\n  /**\n   *\n   * @param files - The list of files that could not be uploaded due to the file\n   * limit defined.\n   * @param limit - The max limit of files allowed.\n   */\n  function TooManyFilesError(files, limit) {\n    var _this = _super.call(this, files, \"file limit\") || this;\n    _this.limit = limit;\n    _this.name = \"TooManyFilesError\";\n    return _this;\n  }\n  return TooManyFilesError;\n}(GenericFileError);\nexport { TooManyFilesError };\n/**\n * An error that will be created if a user tries to upload a file that\n * is either:\n * - less than the {@link FileValidationOptions.minFileSize}\n * - greater than the {@link FileValidationOptions.maxFileSize}\n * - including the file would be greater than the {@link FileValidationOptions.totalFileSize}\n *\n * @remarks \\@since 2.9.0\n */\nvar FileSizeError = /** @class */function (_super) {\n  __extends(FileSizeError, _super);\n  /**\n   *\n   * @param files - The list of files that have the file size error\n   * @param type - The file size error type\n   * @param limit - The number of bytes allowed based on the type\n   */\n  function FileSizeError(files, type, limit) {\n    var _this = _super.call(this, files, \"file size\") || this;\n    _this.type = type;\n    _this.limit = limit;\n    _this.name = \"FileSizeError\";\n    return _this;\n  }\n  return FileSizeError;\n}(GenericFileError);\nexport { FileSizeError };\n/**\n * An error that will be created if a user tries to upload a file that does not\n * end with one of the {@link FileValidationOptions.extensions}.\n *\n * @remarks \\@since 2.9.0\n */\nvar FileExtensionError = /** @class */function (_super) {\n  __extends(FileExtensionError, _super);\n  /**\n   *\n   * @param files - The file that caused the error\n   * @param extensions - The allowed list of file extensions\n   */\n  function FileExtensionError(files, extensions) {\n    var _this = _super.call(this, files, \"extension\") || this;\n    _this.extensions = extensions;\n    _this.name = \"FileExtensionError\";\n    return _this;\n  }\n  return FileExtensionError;\n}(GenericFileError);\nexport { FileExtensionError };\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link GenericFileError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\nexport function isGenericFileError(error) {\n  return \"name\" in error && error.name === \"GenericFileError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileAccessError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\nexport function isFileAccessError(error) {\n  return \"name\" in error && error.name === \"FileAccessError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link TooManyFilesError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link TooManyFilesError}\n */\nexport function isTooManyFilesError(error) {\n  return \"name\" in error && error.name === \"TooManyFilesError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileSizeError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileSizeError}\n */\nexport function isFileSizeError(error) {\n  return \"name\" in error && error.name === \"FileSizeError\";\n}\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileExtensionError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileExtensionError}\n */\nexport function isFileExtensionError(error) {\n  return \"name\" in error && error.name === \"FileExtensionError\";\n}\n/**\n *\n * @defaultValue `matcher?.test(file.name) ?? true`\n * @remarks \\@since 3.1.0\n */\nexport var isValidFileName = function (file, matcher) {\n  var _a;\n  return (_a = matcher === null || matcher === void 0 ? void 0 : matcher.test(file.name)) !== null && _a !== void 0 ? _a : true;\n};\n/**\n * A pretty decent default implementation for validating files with the\n * {@link useFileUpload} that ensures the {@link FilesValidationOptions} are\n * enforced before allowing a file to be uploaded.\n *\n * @typeparam E - An optional custom file validation error.\n * @param files - The list of files to check\n * @param options - The {@link FilesValidationOptions}\n * @returns the {@link ValidatedFilesResult}\n * @remarks \\@since 2.9.0\n */\nexport function validateFiles(files, _a) {\n  var maxFiles = _a.maxFiles,\n    extensions = _a.extensions,\n    minFileSize = _a.minFileSize,\n    maxFileSize = _a.maxFileSize,\n    totalBytes = _a.totalBytes,\n    totalFiles = _a.totalFiles,\n    totalFileSize = _a.totalFileSize,\n    isValidFileName = _a.isValidFileName;\n  var errors = [];\n  var pending = [];\n  var extraFiles = [];\n  var extensionRegExp = extensions.length > 0 ? new RegExp(\"\\\\.(\".concat(extensions.join(\"|\"), \")$\"), \"i\") : undefined;\n  var maxFilesReached = maxFiles > 0 && totalFiles >= maxFiles;\n  var remainingBytes = totalFileSize - totalBytes;\n  var extensionErrors = [];\n  var minErrors = [];\n  var maxErrors = [];\n  var totalSizeErrors = [];\n  for (var i = 0; i < files.length; i += 1) {\n    var file = files[i];\n    var valid = true;\n    var size = file.size;\n    if (!isValidFileName(file, extensionRegExp, extensions)) {\n      valid = false;\n      extensionErrors.push(file);\n    }\n    if (minFileSize > 0 && size < minFileSize) {\n      valid = false;\n      minErrors.push(file);\n    }\n    if (maxFileSize > 0 && size > maxFileSize) {\n      valid = false;\n      maxErrors.push(file);\n    } else if (totalFileSize > 0 && remainingBytes - file.size < 0) {\n      // don't want both errors displaying\n      valid = false;\n      totalSizeErrors.push(file);\n    }\n    if (maxFilesReached && valid) {\n      extraFiles.push(file);\n    } else if (!maxFilesReached && valid) {\n      pending.push(file);\n      remainingBytes -= file.size;\n      maxFilesReached = maxFilesReached || maxFiles > 0 && totalFiles + pending.length >= maxFiles;\n    }\n  }\n  if (extensionErrors.length) {\n    errors.push(new FileExtensionError(extensionErrors, extensions));\n  }\n  if (minErrors.length) {\n    errors.push(new FileSizeError(minErrors, \"min\", minFileSize));\n  }\n  if (maxErrors.length) {\n    errors.push(new FileSizeError(maxErrors, \"max\", maxFileSize));\n  }\n  if (totalSizeErrors.length) {\n    errors.push(new FileSizeError(totalSizeErrors, \"total\", totalFileSize));\n  }\n  if (extraFiles.length) {\n    errors.push(new TooManyFilesError(extraFiles, maxFiles));\n  }\n  return {\n    pending: pending,\n    errors: errors\n  };\n}\n/**\n * This will first check if the mime-type of the file starts with `text/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text-content file.\n * @remarks \\@since 2.9.0\n */\nexport function isTextFile(file) {\n  return /\\.((j|t)sx?|json|lock|hbs|ya?ml|log|txt|md)$/i.test(file.name);\n}\n/**\n * This will first check if the mime-type of the file starts with `text\\/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text content file.\n * @remarks \\@since 2.9.0\n */\nexport function isImageFile(file) {\n  return /\\.(a?png|avif|svg|tiff|gifv?|jpe?g)/i.test(file.name);\n}\n/**\n * This will first check if the mime-type of the file starts with `audio/` and\n * fallback to checking a few file names or extensions that should be considered\n * audio.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a audio content file.\n * @remarks \\@since 2.9.0\n */\nexport function isAudioFile(file) {\n  return /\\.(mp3|wav|ogg|m4p|flac)$/i.test(file.name);\n}\n/**\n * This will first check if the mime-type of the file starts with `video/` and\n * fallback to checking a few file names or extensions that should be considered\n * video.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a video content file.\n * @remarks \\@since 2.9.0\n */\nexport function isVideoFile(file) {\n  return /\\.(mkv|mpe?g|mov|avi|flv|webm|mp4)$/i.test(file.name);\n}\n/**\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file matches an image, audio, or video file.\n * @remarks \\@since 2.9.0\n */\nexport function isMediaFile(file) {\n  return isImageFile(file) || isAudioFile(file) || isVideoFile(file);\n}\n/**\n * This function will attempt to read:\n * - media (image, audio, and video) files as a data url so they can be\n *   previewed in `<img>`, `<audio>`, and `<video>` tags\n * - text files as plain text\n * - everything else as an `ArrayBuffer` which can be manually converted into a\n *   data url if needed with `URL.createObjectURL`\n *\n * @remarks \\@since 2.9.0\n */\nexport var getFileParser = function (file) {\n  if (isMediaFile(file)) {\n    return \"readAsDataURL\";\n  }\n  if (isTextFile(file)) {\n    return \"readAsText\";\n  }\n  return \"readAsArrayBuffer\";\n};\n/**\n * This util will split all the current upload stats by status.\n *\n * @param stats - The {@link FileUploadStats} list generally returned by the\n * {@link useFileUpload} hook.\n * @returns the {@link SplitFileUploads}.\n * @remarks \\@since 2.9.0\n */\nexport function getSplitFileUploads(stats) {\n  var pending = [];\n  var uploading = [];\n  var complete = [];\n  stats.forEach(function (stat) {\n    if (stat.status === \"pending\") {\n      pending.push(stat);\n    } else if (stat.status === \"uploading\") {\n      uploading.push(stat);\n    } else if (stat.status === \"complete\") {\n      complete.push(stat);\n    } else {\n      /* istanbul ignore next */\n      throw new Error(\"Invalid upload stat\");\n    }\n  });\n  return {\n    pending: pending,\n    uploading: uploading,\n    complete: complete\n  };\n}","map":{"version":3,"mappings":"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","names":["nanoid","__extends","message","_super","_this","key","name","Error","files","reason","limit","GenericFileError","type","extensions","isGenericFileError","error","isFileAccessError","isTooManyFilesError","isFileSizeError","isFileExtensionError","isValidFileName","file","matcher","test","validateFiles","_a","maxFiles","minFileSize","maxFileSize","totalBytes","totalFiles","totalFileSize","errors","pending","extraFiles","extensionRegExp","length","RegExp","join","undefined","maxFilesReached","remainingBytes","extensionErrors","minErrors","maxErrors","totalSizeErrors","i","valid","push","size","FileExtensionError","FileSizeError","TooManyFilesError","isTextFile","isImageFile","isAudioFile","isVideoFile","isMediaFile","getFileParser","getSplitFileUploads","stats","uploading","complete","forEach","stat","status"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/file-input/utils.ts"],"sourcesContent":["import type { ChangeEventHandler, DragEventHandler } from \"react\";\nimport { nanoid } from \"nanoid\";\n\n/** @remarks \\@since 2.9.0 */\nexport interface BaseFileUploadStats {\n  /**\n   * A unique key associated with each upload generated by `nanoid`.\n   */\n  key: string;\n\n  /**\n   * The file instance that is being uploaded.\n   */\n  file: File;\n\n  /**\n   * The current upload progress as a percentage from 0 - 100 percent.\n   */\n  progress: number;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport interface ProcessingFileUploadStats extends BaseFileUploadStats {\n  status: \"pending\" | \"uploading\";\n}\n\n/** @remarks \\@since 2.9.0 */\nexport type FileReaderResult = FileReader[\"result\"];\n\n/** @remarks \\@since 2.9.0 */\nexport interface CompletedFileUploadStats extends BaseFileUploadStats {\n  status: \"complete\";\n\n  /**\n   * The result after a `FileReader` has read a file completely.\n   *\n   * Note: This _should_ be an `ArrayBuffer` if the next step is to upload to a\n   * server.\n   *\n   * @see {@link FileReaderParser}\n   * @see {@link getFileParser}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader | FileReader}\n   */\n  result: FileReaderResult;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport type FileUploadStats =\n  | ProcessingFileUploadStats\n  | CompletedFileUploadStats;\n\n/** @remarks \\@since 2.9.0 */\nexport type FileUploadStatus = FileUploadStats[\"status\"];\n\n/** @remarks \\@since 2.9.0 */\nexport interface FileUploadHandlers<E extends HTMLElement> {\n  onDrop?: DragEventHandler<E>;\n  onChange?: ChangeEventHandler<HTMLInputElement>;\n}\n\n/**\n * An error that will be created if a user tries dragging and dropping files\n * from a shared directory that they do not have access to. This error will not\n * occur much.\n *\n * @remarks \\@since 2.9.0\n */\nexport class FileAccessError extends Error {\n  /**\n   * A unique key generated by `nanoid` that can be used as a `React` key\n   */\n  public key: string;\n\n  /**\n   *\n   * @param message - An optional message for the error.\n   */\n  constructor(message?: string) {\n    super(message);\n    this.key = nanoid();\n    this.name = \"FileAccessError\";\n  }\n}\n\n/**\n * An error that just requires a `File` to be passed as the first argument.\n *\n * @remarks \\@since 2.9.0\n */\nexport class GenericFileError extends Error {\n  /**\n   * A unique key generated by `nanoid` that can be used as a `React` key\n   */\n  public key: string;\n\n  /**\n   *\n   * @param files - A list of files that caused the error.\n   * @param reason - An optional reason for the error\n   */\n  constructor(public files: readonly File[], public reason?: string) {\n    super(\"Invalid files\");\n    this.key = nanoid();\n    this.name = \"GenericFileError\";\n  }\n}\n\n/**\n * An error that is created during the upload process if the number of files\n * exceeds the {@link FileUploadOptions.maxFiles} amount.\n *\n * @remarks \\@since 2.9.0\n */\nexport class TooManyFilesError extends GenericFileError {\n  /**\n   *\n   * @param files - The list of files that could not be uploaded due to the file\n   * limit defined.\n   * @param limit - The max limit of files allowed.\n   */\n  constructor(files: readonly File[], public limit: number) {\n    super(files, \"file limit\");\n    this.name = \"TooManyFilesError\";\n  }\n}\n\n/**\n * An error that will be created if a user tries to upload a file that\n * is either:\n * - less than the {@link FileValidationOptions.minFileSize}\n * - greater than the {@link FileValidationOptions.maxFileSize}\n * - including the file would be greater than the {@link FileValidationOptions.totalFileSize}\n *\n * @remarks \\@since 2.9.0\n */\nexport class FileSizeError extends GenericFileError {\n  /**\n   *\n   * @param files - The list of files that have the file size error\n   * @param type - The file size error type\n   * @param limit - The number of bytes allowed based on the type\n   */\n  constructor(\n    files: readonly File[],\n    public type: \"min\" | \"max\" | \"total\",\n    public limit: number\n  ) {\n    super(files, \"file size\");\n    this.name = \"FileSizeError\";\n  }\n}\n\n/**\n * An error that will be created if a user tries to upload a file that does not\n * end with one of the {@link FileValidationOptions.extensions}.\n *\n * @remarks \\@since 2.9.0\n */\nexport class FileExtensionError extends GenericFileError {\n  /**\n   *\n   * @param files - The file that caused the error\n   * @param extensions - The allowed list of file extensions\n   */\n  constructor(files: readonly File[], public extensions: readonly string[]) {\n    super(files, \"extension\");\n    this.name = \"FileExtensionError\";\n  }\n}\n\n/**\n * Mostly an internal type that is used to allow custom validation errors\n *\n * @remarks \\@since 2.9.0\n */\nexport type FileValidationError<E = GenericFileError> =\n  | FileAccessError\n  | TooManyFilesError\n  | FileSizeError\n  | FileExtensionError\n  | E;\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link GenericFileError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\nexport function isGenericFileError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is GenericFileError {\n  return \"name\" in error && error.name === \"GenericFileError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileAccessError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileAccessError}\n */\nexport function isFileAccessError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is FileAccessError {\n  return \"name\" in error && error.name === \"FileAccessError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link TooManyFilesError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link TooManyFilesError}\n */\nexport function isTooManyFilesError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is TooManyFilesError {\n  return \"name\" in error && error.name === \"TooManyFilesError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileSizeError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileSizeError}\n */\nexport function isFileSizeError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is FileSizeError {\n  return \"name\" in error && error.name === \"FileSizeError\";\n}\n\n/**\n * A simple type-guard that can be used to check if the\n * {@link FileValidationError} is the {@link FileExtensionError} which can be\n * useful when displaying the errors to the user.\n *\n * @param error - The error to check\n * @returns true if the error is a {@link FileExtensionError}\n */\nexport function isFileExtensionError<CustomError>(\n  error: FileValidationError<CustomError>\n): error is FileExtensionError {\n  return \"name\" in error && error.name === \"FileExtensionError\";\n}\n\n/**\n * This function is used to determine if a file should be added to the\n * {@link FileExtensionError}. The default implementation should work for most\n * use cases except when files that do not have extensions can be uploaded. i.e.\n * LICENSE files.\n *\n * @param file - The file being checked\n * @param extensionRegExp - A regex that will only be defined if the\n * `extensions` list had at least one value.\n * @param extensions - The list of extensions allowed\n * @returns true if the file has a valid name.\n * @remarks \\@since 3.1.0\n */\nexport type IsValidFileName = (\n  file: File,\n  extensionRegExp: RegExp | undefined,\n  extensions: readonly string[]\n) => boolean;\n\n/**\n *\n * @defaultValue `matcher?.test(file.name) ?? true`\n * @remarks \\@since 3.1.0\n */\nexport const isValidFileName: IsValidFileName = (file, matcher) =>\n  matcher?.test(file.name) ?? true;\n\n/** @remarks \\@since 2.9.0 */\nexport interface FileValidationOptions {\n  /**\n   * If the number of files should be limited, set this value to a number\n   * greater than `0`.\n   *\n   * Note: This still allows \"infinite\" files when set to `0` since the\n   * `<input>` element should normally be set to `disabled` if files should not\n   * be able to be uploaded.\n   *\n   * @defaultValue `-1`\n   */\n  maxFiles?: number;\n\n  /**\n   * An optional minimum file size to enforce for each file. This will only be\n   * used when it is greater than `0`.\n   *\n   * @defaultValue `-1`\n   */\n  minFileSize?: number;\n\n  /**\n   * An optional maximum file size to enforce for each file. This will only be\n   * used when it is greater than `0`.\n   *\n   * @defaultValue `-1`\n   */\n  maxFileSize?: number;\n\n  /**\n   * An optional list of extensions to enforce when uploading files.\n   *\n   * Note: The extensions and file names will be compared ignoring case.\n   *\n   * @example\n   * Only Allow Images\n   * ```ts\n   * const extensions = [\"png\", \"jpeg\", \"jpg\", \"gif\"];\n   * ```\n   */\n  extensions?: readonly string[];\n\n  /** {@inheritDoc IsValidFileName} */\n  isValidFileName?: IsValidFileName;\n\n  /**\n   * An optional total file size to enforce when the {@link maxFiles} option is\n   * not set to `1`.\n   *\n   * @defaultValue `-1`\n   */\n  totalFileSize?: number;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport interface FilesValidationOptions\n  extends Required<FileValidationOptions> {\n  /**\n   * The total number of bytes in the {@link FileUploadHookReturnValue.stats}\n   * list. This is really just:\n   *\n   * ```ts\n   * const totalBytes = stats.reduce((total, stat) => total + stat.file.size, 0);\n   * ```\n   */\n  totalBytes: number;\n\n  /**\n   * The total number of files in the {@link FileUploadHookReturnValue.stats}.\n   */\n  totalFiles: number;\n}\n\n/** @remarks \\@since 2.9.0 */\nexport interface ValidatedFilesResult<CustomError> {\n  /**\n   * A filtered list of files that have been validated and can be queued for the\n   * upload process.\n   */\n  pending: readonly File[];\n\n  /**\n   * A list of {@link FileValidationError} that occurred during the validation\n   * step.\n   *\n   * Note: If an error has occurred, the file **should not** be added to the\n   * {@link pending} list of files.\n   */\n  errors: readonly FileValidationError<CustomError>[];\n}\n\n/**\n * This function will be called whenever a file has been uploaded by the user\n * either through an `<input type=\"file\">` or drag and drop behavior.\n *\n * @example\n * Simple Example\n * ```ts\n * const validateFiles: FilesValidator = (files, options) => {\n *   const invalid: File[] = [];\n *   const pending: File[] = [];\n *   for (const file of files) {\n *     if (!/\\.(jpe?g|svg|png)$/i.test(name)) {\n *       invalid.push(file);\n *     } else {\n *       pending.push(file);\n *     }\n *   }\n *\n *   const errors: FileValidationError[] = [];\n *   if (invalid.length) {\n *     errors.push(new GenericFileError(invalid))\n *   }\n *\n *   return { pending, errors };\n * };\n * ```\n *\n * @typeparam E - An optional custom file validation error.\n * @param files - The list of files to check\n * @param options - The {@link FilesValidationOptions}\n * @returns the {@link ValidatedFilesResult}\n * @see {@link validateFiles} for the default implementation\n * @remarks \\@since 2.9.0\n */\nexport type FilesValidator<CustomError = never> = (\n  files: readonly File[],\n  options: FilesValidationOptions\n) => ValidatedFilesResult<CustomError>;\n\n/**\n * A pretty decent default implementation for validating files with the\n * {@link useFileUpload} that ensures the {@link FilesValidationOptions} are\n * enforced before allowing a file to be uploaded.\n *\n * @typeparam E - An optional custom file validation error.\n * @param files - The list of files to check\n * @param options - The {@link FilesValidationOptions}\n * @returns the {@link ValidatedFilesResult}\n * @remarks \\@since 2.9.0\n */\nexport function validateFiles<CustomError>(\n  files: readonly File[],\n  {\n    maxFiles,\n    extensions,\n    minFileSize,\n    maxFileSize,\n    totalBytes,\n    totalFiles,\n    totalFileSize,\n    isValidFileName,\n  }: FilesValidationOptions\n): ValidatedFilesResult<CustomError> {\n  const errors: FileValidationError<CustomError>[] = [];\n  const pending: File[] = [];\n  const extraFiles: File[] = [];\n  const extensionRegExp =\n    extensions.length > 0\n      ? new RegExp(`\\\\.(${extensions.join(\"|\")})$`, \"i\")\n      : undefined;\n\n  let maxFilesReached = maxFiles > 0 && totalFiles >= maxFiles;\n  let remainingBytes = totalFileSize - totalBytes;\n  const extensionErrors: File[] = [];\n  const minErrors: File[] = [];\n  const maxErrors: File[] = [];\n  const totalSizeErrors: File[] = [];\n  for (let i = 0; i < files.length; i += 1) {\n    const file = files[i];\n\n    let valid = true;\n    const { size } = file;\n    if (!isValidFileName(file, extensionRegExp, extensions)) {\n      valid = false;\n      extensionErrors.push(file);\n    }\n\n    if (minFileSize > 0 && size < minFileSize) {\n      valid = false;\n      minErrors.push(file);\n    }\n\n    if (maxFileSize > 0 && size > maxFileSize) {\n      valid = false;\n      maxErrors.push(file);\n    } else if (totalFileSize > 0 && remainingBytes - file.size < 0) {\n      // don't want both errors displaying\n      valid = false;\n      totalSizeErrors.push(file);\n    }\n\n    if (maxFilesReached && valid) {\n      extraFiles.push(file);\n    } else if (!maxFilesReached && valid) {\n      pending.push(file);\n      remainingBytes -= file.size;\n      maxFilesReached =\n        maxFilesReached ||\n        (maxFiles > 0 && totalFiles + pending.length >= maxFiles);\n    }\n  }\n\n  if (extensionErrors.length) {\n    errors.push(new FileExtensionError(extensionErrors, extensions));\n  }\n\n  if (minErrors.length) {\n    errors.push(new FileSizeError(minErrors, \"min\", minFileSize));\n  }\n\n  if (maxErrors.length) {\n    errors.push(new FileSizeError(maxErrors, \"max\", maxFileSize));\n  }\n\n  if (totalSizeErrors.length) {\n    errors.push(new FileSizeError(totalSizeErrors, \"total\", totalFileSize));\n  }\n\n  if (extraFiles.length) {\n    errors.push(new TooManyFilesError(extraFiles, maxFiles));\n  }\n\n  return { pending, errors };\n}\n\n/**\n * This will first check if the mime-type of the file starts with `text/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text-content file.\n * @remarks \\@since 2.9.0\n */\nexport function isTextFile(file: File): boolean {\n  return /\\.((j|t)sx?|json|lock|hbs|ya?ml|log|txt|md)$/i.test(file.name);\n}\n\n/**\n * This will first check if the mime-type of the file starts with `text\\/` and\n * fallback to checking a few file names or extensions that should be considered\n * text.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a text content file.\n * @remarks \\@since 2.9.0\n */\nexport function isImageFile(file: File): boolean {\n  return /\\.(a?png|avif|svg|tiff|gifv?|jpe?g)/i.test(file.name);\n}\n\n/**\n * This will first check if the mime-type of the file starts with `audio/` and\n * fallback to checking a few file names or extensions that should be considered\n * audio.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a audio content file.\n * @remarks \\@since 2.9.0\n */\nexport function isAudioFile(file: File): boolean {\n  return /\\.(mp3|wav|ogg|m4p|flac)$/i.test(file.name);\n}\n\n/**\n * This will first check if the mime-type of the file starts with `video/` and\n * fallback to checking a few file names or extensions that should be considered\n * video.\n *\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file should be considered as a video content file.\n * @remarks \\@since 2.9.0\n */\nexport function isVideoFile(file: File): boolean {\n  return /\\.(mkv|mpe?g|mov|avi|flv|webm|mp4)$/i.test(file.name);\n}\n\n/**\n * This function is not guaranteed to be 100% correct and is only useful if\n * trying to generate a preview of files uploaded to the browser.\n *\n * @param file - The file to check\n * @returns `true` if the file matches an image, audio, or video file.\n * @remarks \\@since 2.9.0\n */\nexport function isMediaFile(file: File): boolean {\n  return isImageFile(file) || isAudioFile(file) || isVideoFile(file);\n}\n\n/**\n * One of the function names from a `FileReader` to upload a file to the\n * client.\n *\n * Note: If this file does not need to be previewed in the browser and will\n * immediately be uploaded to a server, use `readAsArrayBuffer`.\n *\n * @remarks \\@since 2.9.0\n */\nexport type FileReaderParser =\n  | \"readAsText\"\n  | \"readAsDataURL\"\n  | \"readAsBinaryString\"\n  | \"readAsArrayBuffer\";\n\n/**\n * A function that should return one of the {@link FileReaderParser} functions\n * to start uploading a file to the browser.\n *\n * @example\n * The Default File Upload Parser\n * ```ts\n * export const getFileParser: GetFileParser = (file) => {\n *   if (isMediaFile(file)) {\n *     return \"readAsDataURL\";\n *   }\n *\n *   if (isTextFile(file)) {\n *     return \"readAsText\";\n *   }\n *\n *   return \"readAsArrayBuffer\";\n * };\n * ```\n *\n * @param file - The file to get a parser for\n * @returns the {@link FileReaderParser} string.\n * @remarks \\@since 2.9.0\n */\nexport type GetFileParser = (file: File) => FileReaderParser;\n\n/**\n * This function will attempt to read:\n * - media (image, audio, and video) files as a data url so they can be\n *   previewed in `<img>`, `<audio>`, and `<video>` tags\n * - text files as plain text\n * - everything else as an `ArrayBuffer` which can be manually converted into a\n *   data url if needed with `URL.createObjectURL`\n *\n * @remarks \\@since 2.9.0\n */\nexport const getFileParser: GetFileParser = (file) => {\n  if (isMediaFile(file)) {\n    return \"readAsDataURL\";\n  }\n\n  if (isTextFile(file)) {\n    return \"readAsText\";\n  }\n\n  return \"readAsArrayBuffer\";\n};\n\n/** @remarks \\@since 2.9.0 */\nexport interface SplitFileUploads {\n  readonly pending: readonly ProcessingFileUploadStats[];\n  readonly uploading: readonly ProcessingFileUploadStats[];\n  readonly complete: readonly CompletedFileUploadStats[];\n}\n\n/**\n * This util will split all the current upload stats by status.\n *\n * @param stats - The {@link FileUploadStats} list generally returned by the\n * {@link useFileUpload} hook.\n * @returns the {@link SplitFileUploads}.\n * @remarks \\@since 2.9.0\n */\nexport function getSplitFileUploads(\n  stats: readonly FileUploadStats[]\n): SplitFileUploads {\n  const pending: ProcessingFileUploadStats[] = [];\n  const uploading: ProcessingFileUploadStats[] = [];\n  const complete: CompletedFileUploadStats[] = [];\n  stats.forEach((stat) => {\n    if (stat.status === \"pending\") {\n      pending.push(stat);\n    } else if (stat.status === \"uploading\") {\n      uploading.push(stat);\n    } else if (stat.status === \"complete\") {\n      complete.push(stat);\n    } else {\n      /* istanbul ignore next */\n      throw new Error(\"Invalid upload stat\");\n    }\n  });\n\n  return { pending, uploading, complete };\n}\n"]},"metadata":{},"sourceType":"module"}