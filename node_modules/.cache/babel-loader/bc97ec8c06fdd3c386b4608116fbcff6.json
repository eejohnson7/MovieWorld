{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useCallback, useContext, useMemo, useState } from \"react\";\nvar noop = function () {\n  // do nothing\n};\nvar context = createContext({\n  stack: [],\n  add: noop,\n  remove: noop\n});\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== \"production\") {\n  context.displayName = \"NestedDialogContext\";\n}\nvar Provider = context.Provider;\n/**\n * This component is used to help with handling nested dialogs by:\n * - preventing all dialogs to be closed when the escape key is pressed\n * - hiding the overlays for dialogs that are not the top-most focus\n *\n * This should be added to the root of your app if you would like to enable this\n * feature.\n */\nexport function NestedDialogContextProvider(_a) {\n  var children = _a.children;\n  var _b = __read(useState([]), 2),\n    stack = _b[0],\n    setStack = _b[1];\n  var add = useCallback(function (dialogId) {\n    setStack(function (prevStack) {\n      /* istanbul ignore next */\n      if (process.env.NODE_ENV !== \"production\" && prevStack.includes(dialogId)) {\n        /* eslint-disable no-console */\n        console.warn(\"Tried to add a duplicate dialog id to the `NestedDialogContext`.\");\n        console.warn(\"This means that you have two dialogs with the same id: `\".concat(dialogId, \"`.\"));\n        console.warn(\"This should be fixed before moving to production since this will break accessibility and is technically invalid.\");\n      }\n      return prevStack.concat(dialogId);\n    });\n  }, []);\n  var remove = useCallback(function (dialogId) {\n    setStack(function (prevStack) {\n      return prevStack.filter(function (id) {\n        return id !== dialogId;\n      });\n    });\n  }, []);\n  var value = useMemo(function () {\n    return {\n      stack: stack,\n      add: add,\n      remove: remove\n    };\n  }, [add, remove, stack]);\n  return _jsx(Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}\n/**\n * Gets the current nested dialog context. This shouldn't really be used\n * externally and is a private context hook.\n *\n * @internal\n */\nexport function useNestedDialogContext() {\n  return useContext(context);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SACEA,aAAa,EACbC,WAAW,EACXC,UAAU,EACVC,OAAO,EACPC,QAAQ,QACH,OAAO;AAQd,IAAMC,IAAI,GAAG;EACX;AACF,CAAC;AAED,IAAMC,OAAO,GAAGN,aAAa,CAAsB;EACjDO,KAAK,EAAE,EAAE;EACTC,GAAG,EAAEH,IAAI;EACTI,MAAM,EAAEJ;CACT,CAAC;AAEF;AACA,IAAIK,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;EACzCN,OAAO,CAACO,WAAW,GAAG,qBAAqB;;AAGrC,YAAQ,GAAKP,OAAO,SAAZ;AAMhB;;;;;;;;AAQA,OAAM,SAAUQ,2BAA2B,CAACC,EAET;MADjCC,QAAQ;EAEF,gBAAoBZ,QAAQ,CAAoB,EAAE,CAAC;IAAlDG,KAAK;IAAEU,QAAQ,QAAmC;EACzD,IAAMT,GAAG,GAAGP,WAAW,CAAC,UAACiB,QAAgB;IACvCD,QAAQ,CAAC,UAACE,SAAS;MACjB;MACA,IACET,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IACrCO,SAAS,CAACC,QAAQ,CAACF,QAAQ,CAAC,EAC5B;QACA;QACAG,OAAO,CAACC,IAAI,CACV,kEAAkE,CACnE;QACDD,OAAO,CAACC,IAAI,CACV,kEAA4DJ,QAAQ,OAAK,CAC1E;QACDG,OAAO,CAACC,IAAI,CACV,kHAAkH,CACnH;;MAGH,OAAOH,SAAS,CAACI,MAAM,CAACL,QAAQ,CAAC;IACnC,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,IAAMT,MAAM,GAAGR,WAAW,CAAC,UAACiB,QAAgB;IAC1CD,QAAQ,CAAC,UAACE,SAAS;MAAK,gBAAS,CAACK,MAAM,CAAC,UAACC,EAAE;QAAK,SAAE,KAAKP,QAAQ;MAAf,CAAe,CAAC;IAAzC,CAAyC,CAAC;EACpE,CAAC,EAAE,EAAE,CAAC;EACN,IAAMQ,KAAK,GAAGvB,OAAO,CAAC;IAAM,OAAC;MAAEI,KAAK;MAAEC,GAAG;MAAEC,MAAM;IAAA,CAAE;EAAvB,CAAwB,EAAE,CAACD,GAAG,EAAEC,MAAM,EAAEF,KAAK,CAAC,CAAC;EAE3E,OAAOoB,KAACC,QAAQ;IAACF,KAAK,EAAEA;EAAK;IAAAV,UAAGA;EAAQ,GAAY;AACtD;AAEA;;;;;;AAMA,OAAM,SAAUa,sBAAsB;EACpC,OAAO3B,UAAU,CAACI,OAAO,CAAC;AAC5B","names":["createContext","useCallback","useContext","useMemo","useState","noop","context","stack","add","remove","process","env","NODE_ENV","displayName","NestedDialogContextProvider","_a","children","setStack","dialogId","prevStack","includes","console","warn","concat","filter","id","value","_jsx","Provider","useNestedDialogContext"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/dialog/src/NestedDialogContext.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n} from \"react\";\n\ninterface NestedDialogContext {\n  stack: readonly string[];\n  add: (dialogId: string) => void;\n  remove: (dialogId: string) => void;\n}\n\nconst noop = (): void => {\n  // do nothing\n};\n\nconst context = createContext<NestedDialogContext>({\n  stack: [],\n  add: noop,\n  remove: noop,\n});\n\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== \"production\") {\n  context.displayName = \"NestedDialogContext\";\n}\n\nconst { Provider } = context;\n\nexport interface NestedDialogContextProviderProps {\n  children: ReactNode;\n}\n\n/**\n * This component is used to help with handling nested dialogs by:\n * - preventing all dialogs to be closed when the escape key is pressed\n * - hiding the overlays for dialogs that are not the top-most focus\n *\n * This should be added to the root of your app if you would like to enable this\n * feature.\n */\nexport function NestedDialogContextProvider({\n  children,\n}: NestedDialogContextProviderProps): ReactElement {\n  const [stack, setStack] = useState<readonly string[]>([]);\n  const add = useCallback((dialogId: string) => {\n    setStack((prevStack) => {\n      /* istanbul ignore next */\n      if (\n        process.env.NODE_ENV !== \"production\" &&\n        prevStack.includes(dialogId)\n      ) {\n        /* eslint-disable no-console */\n        console.warn(\n          \"Tried to add a duplicate dialog id to the `NestedDialogContext`.\"\n        );\n        console.warn(\n          `This means that you have two dialogs with the same id: \\`${dialogId}\\`.`\n        );\n        console.warn(\n          \"This should be fixed before moving to production since this will break accessibility and is technically invalid.\"\n        );\n      }\n\n      return prevStack.concat(dialogId);\n    });\n  }, []);\n  const remove = useCallback((dialogId: string) => {\n    setStack((prevStack) => prevStack.filter((id) => id !== dialogId));\n  }, []);\n  const value = useMemo(() => ({ stack, add, remove }), [add, remove, stack]);\n\n  return <Provider value={value}>{children}</Provider>;\n}\n\n/**\n * Gets the current nested dialog context. This shouldn't really be used\n * externally and is a private context hook.\n *\n * @internal\n */\nexport function useNestedDialogContext(): NestedDialogContext {\n  return useContext(context);\n}\n"]},"metadata":{},"sourceType":"module"}