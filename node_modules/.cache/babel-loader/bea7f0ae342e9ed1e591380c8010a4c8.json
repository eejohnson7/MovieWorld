{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\nexport function throttle(fn, wait) {\n  var lastCalledTime = 0;\n  var timeout;\n  var result;\n  var args;\n  function trailingCall() {\n    lastCalledTime = Date.now();\n    timeout = undefined;\n    result = fn.apply(void 0, __spreadArray([], __read(args), false));\n  }\n  return function throttled() {\n    var nextArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nextArgs[_i] = arguments[_i];\n    }\n    args = nextArgs;\n    var now = Date.now();\n    var remaining = wait - (now - lastCalledTime);\n    if (remaining <= 0 || remaining > wait) {\n      lastCalledTime = now;\n      result = fn.apply(void 0, __spreadArray([], __read(args), false));\n    } else if (!timeout) {\n      timeout = window.setTimeout(trailingCall, remaining);\n    }\n    return result;\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUA,QAAQ,CACtBC,EAAK,EACLC,IAAY;EAEZ,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,OAA2B;EAC/B,IAAIC,MAAqB;EACzB,IAAIC,IAAmB;EAEvB,SAASC,YAAY;IACnBJ,cAAc,GAAGK,IAAI,CAACC,GAAG,EAAE;IAC3BL,OAAO,GAAGM,SAAS;IACnBL,MAAM,GAAGJ,EAAE,wCAAIK,IAAI,UAAC;EACtB;EAEA,OAAO,SAASK,SAAS;IAAC;SAAA,UAA0B,EAA1BC,qBAA0B,EAA1BA,IAA0B;MAA1BC;;IACxBP,IAAI,GAAGO,QAAQ;IAEf,IAAMJ,GAAG,GAAGD,IAAI,CAACC,GAAG,EAAE;IACtB,IAAMK,SAAS,GAAGZ,IAAI,IAAIO,GAAG,GAAGN,cAAc,CAAC;IAC/C,IAAIW,SAAS,IAAI,CAAC,IAAIA,SAAS,GAAGZ,IAAI,EAAE;MACtCC,cAAc,GAAGM,GAAG;MACpBJ,MAAM,GAAGJ,EAAE,wCAAIK,IAAI,UAAC;KACrB,MAAM,IAAI,CAACF,OAAO,EAAE;MACnBA,OAAO,GAAGW,MAAM,CAACC,UAAU,CAACT,YAAY,EAAEO,SAAS,CAAC;;IAGtD,OAAOT,MAAM;EACf,CAAC;AACH","names":["throttle","fn","wait","lastCalledTime","timeout","result","args","trailingCall","Date","now","undefined","throttled","_i","nextArgs","remaining","window","setTimeout"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/throttle.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * This is really the type definition for the Parameters type provided by TS,\n * but created a type alias to help with documentation.\n */\nexport type ThrottleableFunction = (...args: any[]) => any;\n\n/**\n * A strongly typed throttled version of a throttleable function.\n */\nexport type ThrottledFunction<F extends ThrottleableFunction> = (\n  ...args: Parameters<F>\n) => ReturnType<F>;\n\n/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\nexport function throttle<F extends ThrottleableFunction>(\n  fn: F,\n  wait: number\n): ThrottledFunction<F> {\n  let lastCalledTime = 0;\n  let timeout: number | undefined;\n  let result: ReturnType<F>;\n  let args: Parameters<F>;\n\n  function trailingCall(): void {\n    lastCalledTime = Date.now();\n    timeout = undefined;\n    result = fn(...args);\n  }\n\n  return function throttled(...nextArgs: Parameters<F>): ReturnType<F> {\n    args = nextArgs;\n\n    const now = Date.now();\n    const remaining = wait - (now - lastCalledTime);\n    if (remaining <= 0 || remaining > wait) {\n      lastCalledTime = now;\n      result = fn(...args);\n    } else if (!timeout) {\n      timeout = window.setTimeout(trailingCall, remaining);\n    }\n\n    return result;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}