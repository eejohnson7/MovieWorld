{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { DEFAULT_DESKTOP_LARGE_MIN_WIDTH, DEFAULT_DESKTOP_MIN_WIDTH, DEFAULT_PHONE_MAX_WIDTH, DEFAULT_TABLET_MAX_WIDTH, DEFAULT_TABLET_MIN_WIDTH } from \"./constants\";\nimport { AppSizeContext } from \"./useAppSize\";\nimport { DEFAULT_APP_SIZE, useAppSizeMedia } from \"./useAppSizeMedia\";\n/**\n * This component should be mounted near the top of your app as it will keep\n * track of the current app size based on the provided breakpoint widths.\n */\nexport function AppSizeListener(_a) {\n  var children = _a.children,\n    onChange = _a.onChange,\n    _b = _a.phoneMaxWidth,\n    phoneMaxWidth = _b === void 0 ? DEFAULT_PHONE_MAX_WIDTH : _b,\n    _c = _a.tabletMinWidth,\n    tabletMinWidth = _c === void 0 ? DEFAULT_TABLET_MIN_WIDTH : _c,\n    _d = _a.tabletMaxWidth,\n    tabletMaxWidth = _d === void 0 ? DEFAULT_TABLET_MAX_WIDTH : _d,\n    _e = _a.desktopMinWidth,\n    desktopMinWidth = _e === void 0 ? DEFAULT_DESKTOP_MIN_WIDTH : _e,\n    _f = _a.desktopLargeMinWidth,\n    desktopLargeMinWidth = _f === void 0 ? DEFAULT_DESKTOP_LARGE_MIN_WIDTH : _f,\n    _g = _a.defaultSize,\n    defaultSize = _g === void 0 ? DEFAULT_APP_SIZE : _g;\n  var appSize = useAppSizeMedia({\n    phoneMaxWidth: phoneMaxWidth,\n    tabletMaxWidth: tabletMaxWidth,\n    tabletMinWidth: tabletMinWidth,\n    desktopMinWidth: desktopMinWidth,\n    desktopLargeMinWidth: desktopLargeMinWidth,\n    defaultSize: defaultSize\n  });\n  var lastValue = useRef(appSize);\n  useEffect(function () {\n    // trigger the onChange prop on mount only if there is a difference between\n    // the defaultSize and the mounted size.\n    if (onChange && (defaultSize.isPhone !== appSize.isPhone || defaultSize.isTablet !== appSize.isTablet || defaultSize.isDesktop !== appSize.isDesktop || defaultSize.isLargeDesktop !== appSize.isLargeDesktop || defaultSize.isLandscape !== appSize.isLandscape)) {\n      onChange(appSize, defaultSize);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useEffect(function () {\n    if (lastValue.current !== appSize) {\n      if (onChange) {\n        onChange(appSize, lastValue.current);\n      }\n      lastValue.current = appSize;\n    }\n  });\n  var value = useMemo(function () {\n    return __assign(__assign({}, appSize), {\n      __initialized: true\n    });\n  }, [appSize]);\n  return _jsx(AppSizeContext.Provider, __assign({\n    value: value\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"mappings":";;;;;;;;;;;AACA,SAASA,SAAS,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AAElD,SACEC,+BAA+B,EAC/BC,yBAAyB,EACzBC,uBAAuB,EACvBC,wBAAwB,EACxBC,wBAAwB,QACnB,aAAa;AACpB,SAASC,cAAc,QAAQ,cAAc;AAE7C,SAASC,gBAAgB,EAAEC,eAAe,QAAQ,mBAAmB;AAarE;;;;AAIA,OAAM,SAAUC,eAAe,CAACC,EAST;MARrBC,QAAQ;IACRC,QAAQ;IACRC,qBAAuC;IAAvCC,aAAa,mBAAGX,uBAAuB;IACvCY,sBAAyC;IAAzCC,cAAc,mBAAGX,wBAAwB;IACzCY,sBAAyC;IAAzCC,cAAc,mBAAGd,wBAAwB;IACzCe,uBAA2C;IAA3CC,eAAe,mBAAGlB,yBAAyB;IAC3CmB,4BAAsD;IAAtDC,oBAAoB,mBAAGrB,+BAA+B;IACtDsB,mBAA8B;IAA9BC,WAAW,mBAAGjB,gBAAgB;EAE9B,IAAMkB,OAAO,GAAGjB,eAAe,CAAC;IAC9BM,aAAa;IACbI,cAAc;IACdF,cAAc;IACdI,eAAe;IACfE,oBAAoB;IACpBE,WAAW;GACZ,CAAC;EACF,IAAME,SAAS,GAAG1B,MAAM,CAACyB,OAAO,CAAC;EAEjC3B,SAAS,CAAC;IACR;IACA;IACA,IACEc,QAAQ,KACPY,WAAW,CAACG,OAAO,KAAKF,OAAO,CAACE,OAAO,IACtCH,WAAW,CAACI,QAAQ,KAAKH,OAAO,CAACG,QAAQ,IACzCJ,WAAW,CAACK,SAAS,KAAKJ,OAAO,CAACI,SAAS,IAC3CL,WAAW,CAACM,cAAc,KAAKL,OAAO,CAACK,cAAc,IACrDN,WAAW,CAACO,WAAW,KAAKN,OAAO,CAACM,WAAW,CAAC,EAClD;MACAnB,QAAQ,CAACa,OAAO,EAAED,WAAW,CAAC;;IAGhC;EACF,CAAC,EAAE,EAAE,CAAC;EAEN1B,SAAS,CAAC;IACR,IAAI4B,SAAS,CAACM,OAAO,KAAKP,OAAO,EAAE;MACjC,IAAIb,QAAQ,EAAE;QACZA,QAAQ,CAACa,OAAO,EAAEC,SAAS,CAACM,OAAO,CAAC;;MAGtCN,SAAS,CAACM,OAAO,GAAGP,OAAO;;EAE/B,CAAC,CAAC;EAEF,IAAMQ,KAAK,GAAGlC,OAAO,CACnB;IAAM,6BACD0B,OAAO;MACVS,aAAa,EAAE;IAAI;EAFf,CAGJ,EACF,CAACT,OAAO,CAAC,CACV;EACD,OACEU,KAAC7B,cAAc,CAAC8B,QAAQ;IAACH,KAAK,EAAEA;EAAK;IAAAtB,UAAGA;EAAQ,GAA2B;AAE/E","names":["useEffect","useMemo","useRef","DEFAULT_DESKTOP_LARGE_MIN_WIDTH","DEFAULT_DESKTOP_MIN_WIDTH","DEFAULT_PHONE_MAX_WIDTH","DEFAULT_TABLET_MAX_WIDTH","DEFAULT_TABLET_MIN_WIDTH","AppSizeContext","DEFAULT_APP_SIZE","useAppSizeMedia","AppSizeListener","_a","children","onChange","_b","phoneMaxWidth","_c","tabletMinWidth","_d","tabletMaxWidth","_e","desktopMinWidth","_f","desktopLargeMinWidth","_g","defaultSize","appSize","lastValue","isPhone","isTablet","isDesktop","isLargeDesktop","isLandscape","current","value","__initialized","_jsx","Provider"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/sizing/AppSizeListener.tsx"],"sourcesContent":["import type { ReactElement, ReactNode } from \"react\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\nimport {\n  DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  DEFAULT_DESKTOP_MIN_WIDTH,\n  DEFAULT_PHONE_MAX_WIDTH,\n  DEFAULT_TABLET_MAX_WIDTH,\n  DEFAULT_TABLET_MIN_WIDTH,\n} from \"./constants\";\nimport { AppSizeContext } from \"./useAppSize\";\nimport type { AppSize, AppSizeOptions } from \"./useAppSizeMedia\";\nimport { DEFAULT_APP_SIZE, useAppSizeMedia } from \"./useAppSizeMedia\";\n\nexport interface AppSizeListenerProps extends AppSizeOptions {\n  children: ReactNode;\n\n  /**\n   * An change handler for the app size. This will be called each time the app\n   * size changes based on a window resize event and will be provided the next\n   * size and the previous size.\n   */\n  onChange?: (nextSize: AppSize, lastSize: AppSize) => void;\n}\n\n/**\n * This component should be mounted near the top of your app as it will keep\n * track of the current app size based on the provided breakpoint widths.\n */\nexport function AppSizeListener({\n  children,\n  onChange,\n  phoneMaxWidth = DEFAULT_PHONE_MAX_WIDTH,\n  tabletMinWidth = DEFAULT_TABLET_MIN_WIDTH,\n  tabletMaxWidth = DEFAULT_TABLET_MAX_WIDTH,\n  desktopMinWidth = DEFAULT_DESKTOP_MIN_WIDTH,\n  desktopLargeMinWidth = DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  defaultSize = DEFAULT_APP_SIZE,\n}: AppSizeListenerProps): ReactElement {\n  const appSize = useAppSizeMedia({\n    phoneMaxWidth,\n    tabletMaxWidth,\n    tabletMinWidth,\n    desktopMinWidth,\n    desktopLargeMinWidth,\n    defaultSize,\n  });\n  const lastValue = useRef(appSize);\n\n  useEffect(() => {\n    // trigger the onChange prop on mount only if there is a difference between\n    // the defaultSize and the mounted size.\n    if (\n      onChange &&\n      (defaultSize.isPhone !== appSize.isPhone ||\n        defaultSize.isTablet !== appSize.isTablet ||\n        defaultSize.isDesktop !== appSize.isDesktop ||\n        defaultSize.isLargeDesktop !== appSize.isLargeDesktop ||\n        defaultSize.isLandscape !== appSize.isLandscape)\n    ) {\n      onChange(appSize, defaultSize);\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (lastValue.current !== appSize) {\n      if (onChange) {\n        onChange(appSize, lastValue.current);\n      }\n\n      lastValue.current = appSize;\n    }\n  });\n\n  const value = useMemo(\n    () => ({\n      ...appSize,\n      __initialized: true,\n    }),\n    [appSize]\n  );\n  return (\n    <AppSizeContext.Provider value={value}>{children}</AppSizeContext.Provider>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}