{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useIsUserInteractionMode } from \"@react-md/utils\";\n/**\n * @internal\n */\nvar noop = function () {\n  // do nothing\n};\n/**\n * This is a completely internal hook that helps control the visibility of the\n * discrete value tooltip's visibility for the `Slider` and `RangeSlider`.\n *\n * Note: This isn't 100% there since the tooltip doesn't animate in when the\n * user holds the mouse down in the same spot for the `animationDuration`.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useDiscreteValueVisibility(_a) {\n  var active = _a.active,\n    animate = _a.animate,\n    animationDuration = _a.animationDuration,\n    discrete = _a.discrete,\n    disabled = _a.disabled,\n    _b = _a.onBlur,\n    propOnBlur = _b === void 0 ? noop : _b,\n    _c = _a.onFocus,\n    propOnFocus = _c === void 0 ? noop : _c;\n  var ref = useRef(null);\n  var isKeyboard = useIsUserInteractionMode(\"keyboard\");\n  // when the user interaction mode changes from keyboard -> mouse by clicking\n  // on the track, need to make sure that the thumb value has the animation\n  // state enabled so it moves at the same speed as the thumb instead of jumping\n  // immediately\n  var _d = __read(useState(false), 2),\n    isModeTransition = _d[0],\n    setModeTransition = _d[1];\n  var _e = __read(useState(false), 2),\n    visible = _e[0],\n    setVisible = _e[1];\n  useEffect(function () {\n    if (!discrete) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    }\n    if (discrete && visible && disabled) {\n      setVisible(false);\n      return;\n    }\n    if (!isKeyboard) {\n      // only considered a \"transition\" when the tooltip is already visible and\n      // switching away from keyboard mode\n      setModeTransition(visible);\n      return;\n    }\n    // when swapping from mouse/touch -> keyboard, the tooltip's visibility will\n    // need to be enabled since default drag behavior is to hide on drag end.\n    // The drag process automatically focuses the current \"target\" thumb to help\n    // the user switch between the modes more easily so if the active element is\n    // the current thumb, we're good to go\n    setModeTransition(false);\n    setVisible(!disabled && document.activeElement === ref.current);\n  }, [isKeyboard, visible, discrete, disabled]);\n  useEffect(function () {\n    if (!discrete) {\n      return;\n    }\n    if (!active) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    }\n    // need to delay the visibility for the same `animationDuration` as the\n    // thumb's active state so that the tooltip appears at the same time the\n    // thumb stops animating with click drag events\n    var timeout = window.setTimeout(function () {\n      setVisible(true);\n      setModeTransition(false);\n    }, animationDuration);\n    return function () {\n      window.clearTimeout(timeout);\n    };\n  }, [active, animationDuration, discrete]);\n  var onBlur = useCallback(function (event) {\n    propOnBlur(event);\n    var track = event.currentTarget.parentElement;\n    // need to hide on blur because it _usually_ means the user clicked\n    // somewhere else on the page after using the keyboard. However, it is\n    // possible the user used the keyboard to update the value and then\n    // clicked on the track to update more quickly, so verify that the next\n    // focus element isn't the track or any children of the track.\n    if (!track || document.activeElement || !track.contains(document.activeElement)) {\n      ref.current = null;\n      setVisible(false);\n    }\n  }, [propOnBlur]);\n  var onFocus = useCallback(function (event) {\n    ref.current = event.currentTarget;\n    propOnFocus(event);\n    if (discrete && isKeyboard) {\n      setVisible(true);\n    }\n  }, [discrete, propOnFocus, isKeyboard]);\n  return {\n    onBlur: onBlur,\n    onFocus: onFocus,\n    animateValue: isModeTransition || animate && isKeyboard,\n    visible: visible\n  };\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useState","useIsUserInteractionMode","noop","useDiscreteValueVisibility","_a","active","animate","animationDuration","discrete","disabled","_b","propOnBlur","_c","propOnFocus","ref","isKeyboard","isModeTransition","setModeTransition","visible","setVisible","document","activeElement","current","timeout","window","setTimeout","clearTimeout","onBlur","event","track","currentTarget","parentElement","contains","onFocus","animateValue"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/slider/useDiscreteValueVisibility.ts"],"sourcesContent":["import type { FocusEvent, FocusEventHandler } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useIsUserInteractionMode } from \"@react-md/utils\";\n\n/**\n * @internal\n */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\ninterface Options {\n  active: boolean;\n  animate: boolean;\n  animationDuration: number;\n  discrete: boolean;\n  disabled: boolean;\n  onBlur?: FocusEventHandler<HTMLSpanElement>;\n  onFocus?: FocusEventHandler<HTMLSpanElement>;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\ninterface ReturnedProps {\n  /**\n   * Boolean if the value should animate the `left`, `right`, `top`, and\n   * `bottom` values to match the speed of the thumb.\n   */\n  animateValue: boolean;\n  visible: boolean;\n  onBlur: FocusEventHandler<HTMLSpanElement>;\n  onFocus: FocusEventHandler<HTMLSpanElement>;\n}\n\n/**\n * This is a completely internal hook that helps control the visibility of the\n * discrete value tooltip's visibility for the `Slider` and `RangeSlider`.\n *\n * Note: This isn't 100% there since the tooltip doesn't animate in when the\n * user holds the mouse down in the same spot for the `animationDuration`.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport function useDiscreteValueVisibility({\n  active,\n  animate,\n  animationDuration,\n  discrete,\n  disabled,\n  onBlur: propOnBlur = noop,\n  onFocus: propOnFocus = noop,\n}: Options): ReturnedProps {\n  const ref = useRef<HTMLSpanElement | null>(null);\n  const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n\n  // when the user interaction mode changes from keyboard -> mouse by clicking\n  // on the track, need to make sure that the thumb value has the animation\n  // state enabled so it moves at the same speed as the thumb instead of jumping\n  // immediately\n  const [isModeTransition, setModeTransition] = useState(false);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (!discrete) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    }\n\n    if (discrete && visible && disabled) {\n      setVisible(false);\n      return;\n    }\n\n    if (!isKeyboard) {\n      // only considered a \"transition\" when the tooltip is already visible and\n      // switching away from keyboard mode\n      setModeTransition(visible);\n      return;\n    }\n\n    // when swapping from mouse/touch -> keyboard, the tooltip's visibility will\n    // need to be enabled since default drag behavior is to hide on drag end.\n    // The drag process automatically focuses the current \"target\" thumb to help\n    // the user switch between the modes more easily so if the active element is\n    // the current thumb, we're good to go\n    setModeTransition(false);\n    setVisible(!disabled && document.activeElement === ref.current);\n  }, [isKeyboard, visible, discrete, disabled]);\n\n  useEffect(() => {\n    if (!discrete) {\n      return;\n    }\n\n    if (!active) {\n      setVisible(false);\n      setModeTransition(false);\n      return;\n    }\n\n    // need to delay the visibility for the same `animationDuration` as the\n    // thumb's active state so that the tooltip appears at the same time the\n    // thumb stops animating with click drag events\n    const timeout = window.setTimeout(() => {\n      setVisible(true);\n      setModeTransition(false);\n    }, animationDuration);\n\n    return () => {\n      window.clearTimeout(timeout);\n    };\n  }, [active, animationDuration, discrete]);\n\n  const onBlur = useCallback(\n    (event: FocusEvent<HTMLSpanElement>) => {\n      propOnBlur(event);\n\n      const track = event.currentTarget.parentElement;\n      // need to hide on blur because it _usually_ means the user clicked\n      // somewhere else on the page after using the keyboard. However, it is\n      // possible the user used the keyboard to update the value and then\n      // clicked on the track to update more quickly, so verify that the next\n      // focus element isn't the track or any children of the track.\n      if (\n        !track ||\n        document.activeElement ||\n        !track.contains(document.activeElement)\n      ) {\n        ref.current = null;\n        setVisible(false);\n      }\n    },\n    [propOnBlur]\n  );\n\n  const onFocus = useCallback(\n    (event: FocusEvent<HTMLSpanElement>) => {\n      ref.current = event.currentTarget;\n      propOnFocus(event);\n      if (discrete && isKeyboard) {\n        setVisible(true);\n      }\n    },\n    [discrete, propOnFocus, isKeyboard]\n  );\n\n  return {\n    onBlur,\n    onFocus,\n    animateValue: isModeTransition || (animate && isKeyboard),\n    visible,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}