{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, isValidElement } from \"react\";\nimport { Button } from \"@react-md/button\";\nimport { useMessageQueueActions, useMessageVisibility } from \"./MessageQueueContext\";\nimport { Snackbar } from \"./Snackbar\";\nimport { Toast } from \"./Toast\";\nfunction getId(snackbarId, toastId, actionId) {\n  if (actionId) {\n    return actionId;\n  }\n  if (toastId) {\n    return \"\".concat(toastId, \"-action\");\n  }\n  return \"\".concat(snackbarId, \"-action\");\n}\n/**\n * Because the toast renderer is a callback function instead of a React\n * component, it's actually required to create a separate component instance so\n * that the context API can be\n *\n * @internal\n */\nfunction SnackbarQueueT(_a, ref) {\n  var queue = _a.queue,\n    onActionClick = _a.onActionClick,\n    props = __rest(_a, [\"queue\", \"onActionClick\"]);\n  var _b = __read(queue, 1),\n    toast = _b[0];\n  var visible = useMessageVisibility();\n  var _c = useMessageQueueActions(),\n    popMessage = _c.popMessage,\n    hideMessage = _c.hideMessage,\n    startTimer = _c.startTimer;\n  var content = null;\n  if (toast) {\n    var snackbarId = props.id;\n    var toastId = toast.id;\n    var _messageId = toast.messageId,\n      _messagePriority = toast.messagePriority,\n      _d = toast.disableAutohide,\n      disableAutohide = _d === void 0 ? false : _d,\n      _e = toast.disableActionHide,\n      disableActionHide_1 = _e === void 0 ? false : _e,\n      providedAction = toast.action,\n      toastProps = __rest(toast, [\"messageId\", \"messagePriority\", \"disableAutohide\", \"disableActionHide\", \"action\"]);\n    var action = null;\n    if (providedAction) {\n      var actionProps_1 = providedAction;\n      var onClick = function (event) {\n        if (onActionClick) {\n          onActionClick(toast, event);\n        }\n        if (actionProps_1.onClick) {\n          actionProps_1.onClick(event);\n        }\n        if (!disableActionHide_1) {\n          hideMessage();\n        }\n      };\n      var t = typeof providedAction;\n      if (isValidElement(providedAction) || t !== \"object\") {\n        action = _jsx(Button, __assign({\n          id: getId(snackbarId, toastId, undefined),\n          onClick: onClick,\n          theme: \"secondary\"\n        }, {\n          children: providedAction\n        }));\n      } else {\n        action = _jsx(Button, __assign({\n          id: getId(snackbarId, toastId, actionProps_1.id),\n          theme: \"secondary\"\n        }, actionProps_1, {\n          onClick: onClick\n        }));\n      }\n    }\n    content = _jsx(Toast, __assign({}, toastProps, {\n      action: action,\n      visible: visible,\n      onEntered: disableAutohide ? undefined : startTimer,\n      onExited: popMessage\n    }));\n  }\n  return _jsx(Snackbar, __assign({}, props, {\n    ref: ref\n  }, {\n    children: content\n  }));\n}\nexport var SnackbarQueue = forwardRef(SnackbarQueueT);","map":{"version":3,"mappings":"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","names":["forwardRef","isValidElement","Button","useMessageQueueActions","useMessageVisibility","Snackbar","Toast","getId","snackbarId","toastId","actionId","SnackbarQueueT","_a","ref","onActionClick","props","queue","toast","visible","popMessage","hideMessage","startTimer","content","id","_messageId","_messagePriority","_d","disableAutohide","_e","disableActionHide_1","providedAction","toastProps","action","actionProps_1","onClick","event","t","_jsx","undefined","theme","children","onEntered","onExited","SnackbarQueue"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/alert/src/SnackbarQueue.tsx"],"sourcesContent":["import type { ReactElement, ReactNode, Ref } from \"react\";\nimport { forwardRef, isValidElement } from \"react\";\nimport type { ButtonProps } from \"@react-md/button\";\nimport { Button } from \"@react-md/button\";\n\nimport type { ToastMessage } from \"./MessageQueueContext\";\nimport {\n  useMessageQueueActions,\n  useMessageVisibility,\n} from \"./MessageQueueContext\";\nimport type { SnackbarProps } from \"./Snackbar\";\nimport { Snackbar } from \"./Snackbar\";\nimport { Toast } from \"./Toast\";\n\nexport type ActionEventHandler<M extends ToastMessage> = (\n  message: M,\n  event: React.MouseEvent<HTMLButtonElement>\n) => void;\n\nexport interface SnackbarQueueProps<M extends ToastMessage>\n  extends SnackbarProps {\n  queue: readonly M[];\n  onActionClick?: ActionEventHandler<M>;\n}\n\nfunction getId(\n  snackbarId: string,\n  toastId: string | undefined,\n  actionId: string | undefined\n): string | undefined {\n  if (actionId) {\n    return actionId;\n  }\n\n  if (toastId) {\n    return `${toastId}-action`;\n  }\n\n  return `${snackbarId}-action`;\n}\n\n/**\n * Because the toast renderer is a callback function instead of a React\n * component, it's actually required to create a separate component instance so\n * that the context API can be\n *\n * @internal\n */\nfunction SnackbarQueueT<M extends ToastMessage = ToastMessage>(\n  { queue, onActionClick, ...props }: SnackbarQueueProps<M>,\n  ref?: Ref<HTMLDivElement>\n): ReactElement {\n  const [toast] = queue;\n  const visible = useMessageVisibility();\n  const { popMessage, hideMessage, startTimer } = useMessageQueueActions();\n\n  let content = null;\n  if (toast) {\n    const snackbarId = props.id;\n    const toastId = toast.id;\n    const {\n      messageId: _messageId,\n      messagePriority: _messagePriority,\n      disableAutohide = false,\n      disableActionHide = false,\n      action: providedAction,\n      ...toastProps\n    } = toast;\n\n    let action: ReactNode = null;\n    if (providedAction) {\n      const actionProps = providedAction as ButtonProps;\n      const onClick: React.MouseEventHandler<HTMLButtonElement> = (event) => {\n        if (onActionClick) {\n          onActionClick(toast, event);\n        }\n\n        if (actionProps.onClick) {\n          actionProps.onClick(event);\n        }\n\n        if (!disableActionHide) {\n          hideMessage();\n        }\n      };\n\n      const t = typeof providedAction;\n      if (isValidElement(providedAction) || t !== \"object\") {\n        action = (\n          <Button\n            id={getId(snackbarId, toastId, undefined)}\n            onClick={onClick}\n            theme=\"secondary\"\n          >\n            {providedAction}\n          </Button>\n        );\n      } else {\n        action = (\n          <Button\n            id={getId(snackbarId, toastId, actionProps.id)}\n            theme=\"secondary\"\n            {...actionProps}\n            onClick={onClick}\n          />\n        );\n      }\n    }\n\n    content = (\n      <Toast\n        {...toastProps}\n        action={action}\n        visible={visible}\n        onEntered={disableAutohide ? undefined : startTimer}\n        onExited={popMessage}\n      />\n    );\n  }\n\n  return (\n    <Snackbar {...props} ref={ref}>\n      {content}\n    </Snackbar>\n  );\n}\n\nexport const SnackbarQueue = forwardRef<\n  HTMLDivElement,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  SnackbarQueueProps<any>\n>(SnackbarQueueT);\n"]},"metadata":{},"sourceType":"module"}