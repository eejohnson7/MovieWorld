{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useMemo } from \"react\";\n/**\n * This util performantly builds a nested list of tree items from a giant flat\n * list of items by linking items together with the provided `parentId`. This\n * will also recursively build the tree and _hopefully_ all items will be added.\n *\n * If there are no children for a specific item\n *\n * TODO: Add a dev-only warning/error if the tree is built, but there are some\n * items that never referenced another `itemId`\n *\n * @internal\n */\nexport function buildTree(parentId, items, sort) {\n  var childItems = [];\n  // doing a \"reverse\" order filter/move so that the items array shrinks while\n  // looping. This makes it so that the entire items array doesn't need to\n  // continually be looped through as more items are added to the tree, only the\n  // remaining items will have to be looped\n  var i = items.length;\n  while (i > 0) {\n    i -= 1;\n    if (items[i] && items[i].parentId === parentId) {\n      var _a = __read(items.splice(i, 1), 1),\n        item = _a[0];\n      // shallow cloning so childItems doesn't get applied to the original data\n      // set\n      childItems.unshift(__assign({}, item));\n    }\n  }\n  if (!childItems.length) {\n    return undefined;\n  }\n  childItems.forEach(function (childItem) {\n    childItem.childItems = buildTree(childItem.itemId, items, sort);\n  });\n  return sort ? sort(childItems) : childItems;\n}\n/**\n * This is an internal hook that will create a renderable nested list view of\n * the tree data.\n *\n * @internal\n * @param tree - The full tree to convert to a nested list representation\n * @param sort - An optional function that sorts the items at each level\n * @param rootId - The starting `parentId` to use while building the tree. This\n * defaults to `null` since this is most likely the general use case, but if\n * there's a different unique identifier for the \"root level\" items, that can be\n * used instead.\n */\nexport function useNestedTreeList(tree, sort, rootId) {\n  if (rootId === void 0) {\n    rootId = null;\n  }\n  return useMemo(function () {\n    return buildTree(rootId, Object.values(tree), sort) || [];\n  }, [rootId, sort, tree]);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,OAAO,QAAQ,OAAO;AAgB/B;;;;;;;;;;;;AAYA,OAAM,SAAUC,SAAS,CACvBC,QAA2B,EAC3BC,KAAU,EACVC,IAAwB;EAExB,IAAMC,UAAU,GAAwB,EAAE;EAE1C;EACA;EACA;EACA;EACA,IAAIC,CAAC,GAAGH,KAAK,CAACI,MAAM;EACpB,OAAOD,CAAC,GAAG,CAAC,EAAE;IACZA,CAAC,IAAI,CAAC;IACN,IAAIH,KAAK,CAACG,CAAC,CAAC,IAAIH,KAAK,CAACG,CAAC,CAAC,CAACJ,QAAQ,KAAKA,QAAQ,EAAE;MACxC,gBAASC,KAAK,CAACK,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC;QAA1BG,IAAI,QAAsB;MACjC;MACA;MACAJ,UAAU,CAACK,OAAO,cAAMD,IAAI,EAAG;;;EAInC,IAAI,CAACJ,UAAU,CAACE,MAAM,EAAE;IACtB,OAAOI,SAAS;;EAGlBN,UAAU,CAACO,OAAO,CAAC,UAACC,SAAS;IAC3BA,SAAS,CAACR,UAAU,GAAGJ,SAAS,CAACY,SAAS,CAACC,MAAM,EAAEX,KAAK,EAAEC,IAAI,CAAC;EACjE,CAAC,CAAC;EAEF,OAAOA,IAAI,GAAGA,IAAI,CAACC,UAAU,CAAC,GAAGA,UAAU;AAC7C;AAEA;;;;;;;;;;;;AAYA,OAAM,SAAUU,iBAAiB,CAC/BC,IAAiB,EACjBZ,IAAwB,EACxBa,MAAgC;EAAhC;IAAAA,aAAgC;EAAA;EAEhC,OAAOjB,OAAO,CACZ;IAAM,gBAAS,CAACiB,MAAM,EAAEC,MAAM,CAACC,MAAM,CAACH,IAAI,CAAC,EAAEZ,IAAI,CAAC,IAAI,EAAE;EAAlD,CAAkD,EACxD,CAACa,MAAM,EAAEb,IAAI,EAAEY,IAAI,CAAC,CACrB;AACH","names":["useMemo","buildTree","parentId","items","sort","childItems","i","length","splice","item","unshift","undefined","forEach","childItem","itemId","useNestedTreeList","tree","rootId","Object","values"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/tree/src/useNestedTreeList.ts"],"sourcesContent":["import { useMemo } from \"react\";\n\nimport type {\n  BaseTreeItem,\n  TreeData,\n  TreeItemId,\n  TreeItemSorter,\n} from \"./types\";\n\n/**\n * @internal\n */\nexport type NestedTreeItem<T extends BaseTreeItem> = T & {\n  childItems?: readonly NestedTreeItem<T>[];\n};\n\n/**\n * This util performantly builds a nested list of tree items from a giant flat\n * list of items by linking items together with the provided `parentId`. This\n * will also recursively build the tree and _hopefully_ all items will be added.\n *\n * If there are no children for a specific item\n *\n * TODO: Add a dev-only warning/error if the tree is built, but there are some\n * items that never referenced another `itemId`\n *\n * @internal\n */\nexport function buildTree<T extends BaseTreeItem>(\n  parentId: null | TreeItemId,\n  items: T[],\n  sort?: TreeItemSorter<T>\n): readonly NestedTreeItem<T>[] | undefined {\n  const childItems: NestedTreeItem<T>[] = [];\n\n  // doing a \"reverse\" order filter/move so that the items array shrinks while\n  // looping. This makes it so that the entire items array doesn't need to\n  // continually be looped through as more items are added to the tree, only the\n  // remaining items will have to be looped\n  let i = items.length;\n  while (i > 0) {\n    i -= 1;\n    if (items[i] && items[i].parentId === parentId) {\n      const [item] = items.splice(i, 1);\n      // shallow cloning so childItems doesn't get applied to the original data\n      // set\n      childItems.unshift({ ...item });\n    }\n  }\n\n  if (!childItems.length) {\n    return undefined;\n  }\n\n  childItems.forEach((childItem) => {\n    childItem.childItems = buildTree(childItem.itemId, items, sort);\n  });\n\n  return sort ? sort(childItems) : childItems;\n}\n\n/**\n * This is an internal hook that will create a renderable nested list view of\n * the tree data.\n *\n * @internal\n * @param tree - The full tree to convert to a nested list representation\n * @param sort - An optional function that sorts the items at each level\n * @param rootId - The starting `parentId` to use while building the tree. This\n * defaults to `null` since this is most likely the general use case, but if\n * there's a different unique identifier for the \"root level\" items, that can be\n * used instead.\n */\nexport function useNestedTreeList<T extends BaseTreeItem>(\n  tree: TreeData<T>,\n  sort?: TreeItemSorter<T>,\n  rootId: null | TreeItemId = null\n): readonly NestedTreeItem<T>[] {\n  return useMemo(\n    () => buildTree(rootId, Object.values(tree), sort) || [],\n    [rootId, sort, tree]\n  );\n}\n"]},"metadata":{},"sourceType":"module"}