{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { hexToRGB } from \"./hexToRGB\";\nvar RED_MULTIPLIER = 0.2126;\nvar GREEN_MULTIPLIER = 0.7152;\nvar BLUE_MULTIPLIER = 0.0722;\n/**\n * I really couldn't figure out how to name these \"magic\" numbers since the\n * formula doesn't really describe it much:\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\nfunction get8BitColor(color) {\n  color /= 255;\n  if (color <= 0.03928) {\n    return color / 12.92;\n  }\n  return Math.pow((color + 0.055) / 1.055, 2.4);\n}\n/**\n * A number closest to 0 should be closest to black while a number closest to 1\n * should be closest to white.\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\nexport function getLuminance(color) {\n  var _a = __read(hexToRGB(color), 3),\n    r = _a[0],\n    g = _a[1],\n    b = _a[2];\n  var red = get8BitColor(r) * RED_MULTIPLIER;\n  var green = get8BitColor(g) * GREEN_MULTIPLIER;\n  var blue = get8BitColor(b) * BLUE_MULTIPLIER;\n  return red + green + blue;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,QAAQ,QAAQ,YAAY;AAErC,IAAMC,cAAc,GAAG,MAAM;AAC7B,IAAMC,gBAAgB,GAAG,MAAM;AAC/B,IAAMC,eAAe,GAAG,MAAM;AAE9B;;;;;;;AAOA,SAASC,YAAY,CAACC,KAAa;EACjCA,KAAK,IAAI,GAAG;EAEZ,IAAIA,KAAK,IAAI,OAAO,EAAE;IACpB,OAAOA,KAAK,GAAG,KAAK;;EAGtB,OAAOC,SAAC,CAACD,KAAK,GAAG,KAAK,IAAI,KAAK,EAAK,GAAG;AACzC;AAEA;;;;;;;AAOA,OAAM,SAAUE,YAAY,CAACF,KAAgB;EACrC,gBAAYL,QAAQ,CAACK,KAAK,CAAC;IAA1BG,CAAC;IAAEC,CAAC;IAAEC,CAAC,QAAmB;EAEjC,IAAMC,GAAG,GAAGP,YAAY,CAACI,CAAC,CAAC,GAAGP,cAAc;EAC5C,IAAMW,KAAK,GAAGR,YAAY,CAACK,CAAC,CAAC,GAAGP,gBAAgB;EAChD,IAAMW,IAAI,GAAGT,YAAY,CAACM,CAAC,CAAC,GAAGP,eAAe;EAE9C,OAAOQ,GAAG,GAAGC,KAAK,GAAGC,IAAI;AAC3B","names":["hexToRGB","RED_MULTIPLIER","GREEN_MULTIPLIER","BLUE_MULTIPLIER","get8BitColor","color","Math","getLuminance","r","g","b","red","green","blue"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/colors/getLuminance.ts"],"sourcesContent":["import type { HexString } from \"./hexToRGB\";\nimport { hexToRGB } from \"./hexToRGB\";\n\nconst RED_MULTIPLIER = 0.2126;\nconst GREEN_MULTIPLIER = 0.7152;\nconst BLUE_MULTIPLIER = 0.0722;\n\n/**\n * I really couldn't figure out how to name these \"magic\" numbers since the\n * formula doesn't really describe it much:\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\nfunction get8BitColor(color: number): number {\n  color /= 255;\n\n  if (color <= 0.03928) {\n    return color / 12.92;\n  }\n\n  return ((color + 0.055) / 1.055) ** 2.4;\n}\n\n/**\n * A number closest to 0 should be closest to black while a number closest to 1\n * should be closest to white.\n *\n * @see https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests\n * @internal\n */\nexport function getLuminance(color: HexString): number {\n  const [r, g, b] = hexToRGB(color);\n\n  const red = get8BitColor(r) * RED_MULTIPLIER;\n  const green = get8BitColor(g) * GREEN_MULTIPLIER;\n  const blue = get8BitColor(b) * BLUE_MULTIPLIER;\n\n  return red + green + blue;\n}\n"]},"metadata":{},"sourceType":"module"}