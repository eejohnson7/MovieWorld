{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { ResizeObserver } from \"@juggle/resize-observer\";\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n/**\n * @internal\n */\nfunction isHeightChange(prevSize, nextSize) {\n  return !prevSize || prevSize.height !== nextSize.height || prevSize.scrollHeight !== nextSize.scrollHeight;\n}\n/**\n * @internal\n */\nfunction isWidthChange(prevSize, nextSize) {\n  return !prevSize || prevSize.width !== nextSize.width || prevSize.scrollWidth !== nextSize.scrollWidth;\n}\n/**\n * Why is there a single shared observer instead of multiple and a\n * \"subscription\" model?\n *\n * Note: Probably a bit of a premature optimization right now...\n *\n * @see https://github.com/WICG/resize-observer/issues/59\n * @internal\n */\nvar sharedObserver;\n/**\n *\n * @internal\n */\nvar subscriptions = [];\n/**\n * Lazy initializes the shared resize observer which will loop through all the\n * subscriptions when a resize event is called.\n *\n * @internal\n */\nfunction init() {\n  if (sharedObserver || typeof document === \"undefined\") {\n    return;\n  }\n  sharedObserver = new ResizeObserver(function (entries) {\n    var _loop_1 = function (i) {\n      var entry = entries[i];\n      var currentSubscriptions = subscriptions.filter(function (_a) {\n        var target = _a.target;\n        return target === entry.target;\n      });\n      if (!currentSubscriptions.length) {\n        return {\n          value: void 0\n        };\n      }\n      var _a = entry.contentRect,\n        height = _a.height,\n        width = _a.width;\n      var _b = entry.target,\n        scrollHeight = _b.scrollHeight,\n        scrollWidth = _b.scrollWidth;\n      var nextSize = {\n        height: height,\n        width: width,\n        scrollHeight: scrollHeight,\n        scrollWidth: scrollWidth\n      };\n      for (var j = 0; j < currentSubscriptions.length; j += 1) {\n        var subscription = currentSubscriptions[j];\n        var handler = subscription.handler,\n          prevSize = subscription.prevSize,\n          disableHeight = subscription.disableHeight,\n          disableWidth = subscription.disableWidth;\n        var isNewHeight = isHeightChange(prevSize, nextSize);\n        var isNewWidth = isWidthChange(prevSize, nextSize);\n        if (isNewHeight && !disableHeight || isNewWidth && !disableWidth) {\n          subscription.prevSize = nextSize;\n          handler(__assign(__assign({}, nextSize), {\n            element: entry.target\n          }));\n        }\n      }\n    };\n    // Note: might need to wait until an requestAnimationFrame has completed to\n    // fix the resize observer loop exceeded error if switching to\n    // `useIsomorphicLayoutEffect` and a shared observer didn't fix that error:\n    // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n    for (var i = 0; i < entries.length; i += 1) {\n      var state_1 = _loop_1(i);\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n  });\n}\n/**\n *\n * @internal\n */\nfunction subscribe(target, onResize, disableHeight, disableWidth) {\n  var exists = subscriptions.find(function (sub) {\n    return sub.target === target;\n  });\n  subscriptions.push({\n    target: target,\n    handler: onResize,\n    disableWidth: disableWidth,\n    disableHeight: disableHeight,\n    prevSize: undefined\n  });\n  if (!exists) {\n    // I'll silently fail non-initialized observers for now until it becomes an\n    // issue... But how will I ever know?\n    sharedObserver === null || sharedObserver === void 0 ? void 0 : sharedObserver.observe(target);\n  }\n}\n/**\n *\n * @internal\n */\nfunction unsubscribe(target, onResize, disableHeight, disableWidth) {\n  var i = subscriptions.findIndex(function (sub) {\n    return sub.target === target && sub.handler === onResize && sub.disableWidth === disableWidth && sub.disableHeight === disableHeight;\n  });\n  if (i !== -1) {\n    subscriptions.splice(i, 1);\n  }\n  var remaining = subscriptions.some(function (sub) {\n    return sub.target === target;\n  });\n  if (!remaining) {\n    // I'll silently fail non-initialized observers for now until it becomes an\n    // issue... But how will I ever know?\n    sharedObserver === null || sharedObserver === void 0 ? void 0 : sharedObserver.unobserve(target);\n  }\n}\n/**\n * The new resize observer API that returns a `refHandler` to attach to a DOM\n * node instead of using the weird `target` API.\n *\n * @remarks \\@since 2.3.0\n * @param onResize - The resize handler to call when the element has changed\n * height or width. If you notice performance issues or other oddities, it is\n * recommended to wrap this function in `useCallback`.\n * @param options - Any additional options to use for the resize observer.\n */\nexport function useResizeObserver(onResize, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var propRef = options.ref,\n    _a = options.disableWidth,\n    disableWidth = _a === void 0 ? false : _a,\n    _b = options.disableHeight,\n    disableHeight = _b === void 0 ? false : _b;\n  var _c = __read(useEnsuredRef(propRef), 2),\n    ref = _c[0],\n    refHandler = _c[1];\n  useIsomorphicLayoutEffect(function () {\n    var target = ref.current;\n    if (disableHeight && disableWidth || !target) {\n      return;\n    }\n    init();\n    subscribe(target, onResize, disableHeight, disableWidth);\n    return function () {\n      unsubscribe(target, onResize, disableHeight, disableWidth);\n    };\n  }, [disableHeight, disableWidth, onResize]);\n  return [ref, refHandler];\n}","map":{"version":3,"mappings":"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","names":["ResizeObserver","useEnsuredRef","useIsomorphicLayoutEffect","isHeightChange","prevSize","nextSize","height","scrollHeight","isWidthChange","width","scrollWidth","sharedObserver","subscriptions","init","document","entries","i","entry","currentSubscriptions","filter","_a","target","length","contentRect","j","subscription","disableHeight","disableWidth","isNewHeight","isNewWidth","handler","element","subscribe","onResize","exists","find","sub","push","undefined","observe","unsubscribe","findIndex","splice","remaining","some","unobserve","useResizeObserver","options","propRef","_b","ref","refHandler","current"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/utils/src/sizing/useResizeObserver.ts"],"sourcesContent":["import type { Ref } from \"react\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\n\nimport type { EnsuredRefs } from \"../useEnsuredRef\";\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface UseResizeObserverOptions<E extends HTMLElement> {\n  /**\n   * An optional ref to merge with the returned ref handler function\n   */\n  ref?: Ref<E | null>;\n\n  /**\n   * Boolean if the `onResize` callback should not be triggered if only the\n   * height has changed for the watched element.\n   */\n  disableHeight?: boolean;\n\n  /**\n   * Boolean if the `onResize` callback should not be triggered if only the\n   * width has changed for the watched element.\n   */\n  disableWidth?: boolean;\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface ResizeObserverElementSize {\n  /**\n   * The height for the element that was changed.\n   */\n  height: number;\n\n  /**\n   * The width for the element that was changed.\n   */\n  width: number;\n\n  /**\n   * The scroll height for the element that was changed.\n   */\n  scrollHeight: number;\n\n  /**\n   * The scroll height for the element that was changed.\n   */\n  scrollWidth: number;\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface ResizeObserverElementData<E extends HTMLElement = HTMLElement>\n  extends ResizeObserverElementSize {\n  /**\n   * The element that changed due to the resize observer.\n   */\n  element: E;\n}\n\n/**\n * The callback that is triggered each time an element's size change has been\n * observed.\n * @remarks \\@since 2.3.0\n */\nexport type OnResizeObserverChange<E extends HTMLElement = HTMLElement> = (\n  resizeData: ResizeObserverElementData<E>\n) => void;\n\n/**\n * @internal\n */\ninterface ResizeObserverSubscription<E extends HTMLElement> {\n  readonly target: E;\n  readonly handler: OnResizeObserverChange<E>;\n  readonly disableHeight: boolean;\n  readonly disableWidth: boolean;\n  prevSize: ResizeObserverElementSize | undefined;\n}\n\n/**\n * @internal\n */\nfunction isHeightChange(\n  prevSize: ResizeObserverElementSize | undefined,\n  nextSize: ResizeObserverElementSize\n): boolean {\n  return (\n    !prevSize ||\n    prevSize.height !== nextSize.height ||\n    prevSize.scrollHeight !== nextSize.scrollHeight\n  );\n}\n\n/**\n * @internal\n */\nfunction isWidthChange(\n  prevSize: ResizeObserverElementSize | undefined,\n  nextSize: ResizeObserverElementSize\n): boolean {\n  return (\n    !prevSize ||\n    prevSize.width !== nextSize.width ||\n    prevSize.scrollWidth !== nextSize.scrollWidth\n  );\n}\n\n/**\n * Why is there a single shared observer instead of multiple and a\n * \"subscription\" model?\n *\n * Note: Probably a bit of a premature optimization right now...\n *\n * @see https://github.com/WICG/resize-observer/issues/59\n * @internal\n */\nlet sharedObserver: ResizeObserver | undefined;\n\n/**\n *\n * @internal\n */\nconst subscriptions: ResizeObserverSubscription<HTMLElement>[] = [];\n\n/**\n * Lazy initializes the shared resize observer which will loop through all the\n * subscriptions when a resize event is called.\n *\n * @internal\n */\nfunction init(): void {\n  if (sharedObserver || typeof document === \"undefined\") {\n    return;\n  }\n\n  sharedObserver = new ResizeObserver((entries) => {\n    // Note: might need to wait until an requestAnimationFrame has completed to\n    // fix the resize observer loop exceeded error if switching to\n    // `useIsomorphicLayoutEffect` and a shared observer didn't fix that error:\n    // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n    for (let i = 0; i < entries.length; i += 1) {\n      const entry = entries[i];\n      const currentSubscriptions = subscriptions.filter(\n        ({ target }) => target === entry.target\n      );\n      if (!currentSubscriptions.length) {\n        return;\n      }\n\n      const { height, width } = entry.contentRect;\n      const { scrollHeight, scrollWidth } = entry.target;\n      const nextSize: ResizeObserverElementSize = {\n        height,\n        width,\n        scrollHeight,\n        scrollWidth,\n      };\n\n      for (let j = 0; j < currentSubscriptions.length; j += 1) {\n        const subscription = currentSubscriptions[j];\n        const { handler, prevSize, disableHeight, disableWidth } = subscription;\n        const isNewHeight = isHeightChange(prevSize, nextSize);\n        const isNewWidth = isWidthChange(prevSize, nextSize);\n        if ((isNewHeight && !disableHeight) || (isNewWidth && !disableWidth)) {\n          subscription.prevSize = nextSize;\n          handler({\n            ...nextSize,\n            element: entry.target as typeof subscription.target,\n          });\n        }\n      }\n    }\n  });\n}\n\n/**\n *\n * @internal\n */\nfunction subscribe<E extends HTMLElement>(\n  target: E,\n  onResize: OnResizeObserverChange<E>,\n  disableHeight: boolean,\n  disableWidth: boolean\n): void {\n  const exists = subscriptions.find((sub) => sub.target === target);\n  subscriptions.push({\n    target,\n    handler: onResize as OnResizeObserverChange<HTMLElement>,\n    disableWidth,\n    disableHeight,\n    prevSize: undefined,\n  });\n\n  if (!exists) {\n    // I'll silently fail non-initialized observers for now until it becomes an\n    // issue... But how will I ever know?\n    sharedObserver?.observe(target);\n  }\n}\n\n/**\n *\n * @internal\n */\nfunction unsubscribe<E extends HTMLElement>(\n  target: E,\n  onResize: OnResizeObserverChange<E>,\n  disableHeight: boolean,\n  disableWidth: boolean\n): void {\n  const i = subscriptions.findIndex(\n    (sub) =>\n      sub.target === target &&\n      sub.handler === onResize &&\n      sub.disableWidth === disableWidth &&\n      sub.disableHeight === disableHeight\n  );\n  if (i !== -1) {\n    subscriptions.splice(i, 1);\n  }\n\n  const remaining = subscriptions.some((sub) => sub.target === target);\n  if (!remaining) {\n    // I'll silently fail non-initialized observers for now until it becomes an\n    // issue... But how will I ever know?\n    sharedObserver?.unobserve(target);\n  }\n}\n\n/**\n * The new resize observer API that returns a `refHandler` to attach to a DOM\n * node instead of using the weird `target` API.\n *\n * @remarks \\@since 2.3.0\n * @param onResize - The resize handler to call when the element has changed\n * height or width. If you notice performance issues or other oddities, it is\n * recommended to wrap this function in `useCallback`.\n * @param options - Any additional options to use for the resize observer.\n */\nexport function useResizeObserver<E extends HTMLElement>(\n  onResize: OnResizeObserverChange<E>,\n  options: UseResizeObserverOptions<E> = {}\n): EnsuredRefs<E> {\n  const { ref: propRef, disableWidth = false, disableHeight = false } = options;\n  const [ref, refHandler] = useEnsuredRef<E>(propRef);\n\n  useIsomorphicLayoutEffect(() => {\n    const target = ref.current;\n    if ((disableHeight && disableWidth) || !target) {\n      return;\n    }\n\n    init();\n    subscribe(target, onResize, disableHeight, disableWidth);\n    return () => {\n      unsubscribe(target, onResize, disableHeight, disableWidth);\n    };\n  }, [disableHeight, disableWidth, onResize]);\n\n  return [ref, refHandler];\n}\n"]},"metadata":{},"sourceType":"module"}