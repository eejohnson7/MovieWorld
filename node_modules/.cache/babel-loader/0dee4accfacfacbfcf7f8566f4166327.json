{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nvar VALIDITY_STATE_KEYS = [\"badInput\", \"customError\", \"patternMismatch\", \"rangeOverflow\", \"rangeUnderflow\", \"stepMismatch\", \"tooLong\", \"tooShort\", \"typeMismatch\", \"valueMissing\"];\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var RECOMMENDED_STATE_KEYS = [\"badInput\", \"tooLong\", \"valueMissing\"];\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport var RECOMMENDED_NUMBER_STATE_KEYS = __spreadArray(__spreadArray([], __read(RECOMMENDED_STATE_KEYS), false), [\"rangeOverflow\", \"rangeUnderflow\", \"tooShort\", \"typeMismatch\"], false);\n/**\n * The validation message is actually kind of weird since it's possible for a\n * form element to have multiple errors at once. The validation message will be\n * the first error that appears, so need to make sure that the first error is\n * one of the recommended state keys so the message appears for only those types\n * of errors.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nvar isRecommended = function (validity, isNumber) {\n  var errorable = isNumber ? RECOMMENDED_NUMBER_STATE_KEYS : RECOMMENDED_STATE_KEYS;\n  return VALIDITY_STATE_KEYS.every(function (key) {\n    var errored = validity[key];\n    return !errored || errorable.includes(key);\n  });\n};\n/**\n * The default implementation for getting an error message for the `TextField`\n * or `TextArea` components that relies on the behavior of the\n * {@link ChangeValidationBehavior}\n *\n * @remarks \\@since 2.5.0\n */\nexport var defaultGetErrorMessage = function (_a) {\n  var isBlurEvent = _a.isBlurEvent,\n    validity = _a.validity,\n    validationMessage = _a.validationMessage,\n    validateOnChange = _a.validateOnChange;\n  if (isBlurEvent || !validationMessage || validateOnChange === true) {\n    return validationMessage;\n  }\n  if (!validateOnChange) {\n    return \"\";\n  }\n  if (validateOnChange === \"recommended\" || validateOnChange === \"number-recommended\") {\n    return isRecommended(validity, validateOnChange === \"number-recommended\") ? validationMessage : \"\";\n  }\n  var keys = typeof validateOnChange === \"string\" ? [validateOnChange] : validateOnChange;\n  return keys.length && VALIDITY_STATE_KEYS.some(function (key) {\n    return validity[key] && keys.includes(key);\n  }) ? validationMessage : \"\";\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;;;;AAIA,IAAMA,mBAAmB,GAAqC,CAC5D,UAAU,EACV,aAAa,EACb,iBAAiB,EACjB,eAAe,EACf,gBAAgB,EAChB,cAAc,EACd,SAAS,EACT,UAAU,EACV,cAAc,EACd,cAAc,CACf;AAED;;;;AAIA,OAAO,IAAMC,sBAAsB,GAAqC,CACtE,UAAU,EACV,SAAS,EACT,cAAc,CACf;AAED;;;;AAIA,OAAO,IAAMC,6BAA6B,0CACrCD,sBAAsB,YACzB,eAAe,EACf,gBAAgB,EAChB,UAAU,EACV,cAAc,SACf;AAED;;;;;;;;;;AAUA,IAAME,aAAa,GAAG,UAACC,QAAuB,EAAEC,QAAiB;EAC/D,IAAMC,SAAS,GAAGD,QAAQ,GACtBH,6BAA6B,GAC7BD,sBAAsB;EAE1B,OAAOD,mBAAmB,CAACO,KAAK,CAAC,UAACC,GAAG;IACnC,IAAMC,OAAO,GAAGL,QAAQ,CAACI,GAAG,CAAC;IAC7B,OAAO,CAACC,OAAO,IAAIH,SAAS,CAACI,QAAQ,CAACF,GAAG,CAAC;EAC5C,CAAC,CAAC;AACJ,CAAC;AAED;;;;;;;AAOA,OAAO,IAAMG,sBAAsB,GAAoB,UAACC,EAKvD;MAJCC,WAAW;IACXT,QAAQ;IACRU,iBAAiB;IACjBC,gBAAgB;EAEhB,IAAIF,WAAW,IAAI,CAACC,iBAAiB,IAAIC,gBAAgB,KAAK,IAAI,EAAE;IAClE,OAAOD,iBAAiB;;EAG1B,IAAI,CAACC,gBAAgB,EAAE;IACrB,OAAO,EAAE;;EAGX,IACEA,gBAAgB,KAAK,aAAa,IAClCA,gBAAgB,KAAK,oBAAoB,EACzC;IACA,OAAOZ,aAAa,CAACC,QAAQ,EAAEW,gBAAgB,KAAK,oBAAoB,CAAC,GACrED,iBAAiB,GACjB,EAAE;;EAGR,IAAME,IAAI,GACR,OAAOD,gBAAgB,KAAK,QAAQ,GAChC,CAACA,gBAAgB,CAAC,GAClBA,gBAAgB;EAEtB,OAAOC,IAAI,CAACC,MAAM,IAChBjB,mBAAmB,CAACkB,IAAI,CAAC,UAACV,GAAG;IAAK,eAAQ,CAACA,GAAG,CAAC,IAAIQ,IAAI,CAACN,QAAQ,CAACF,GAAG,CAAC;EAAnC,CAAmC,CAAC,GACpEM,iBAAiB,GACjB,EAAE;AACR,CAAC","names":["VALIDITY_STATE_KEYS","RECOMMENDED_STATE_KEYS","RECOMMENDED_NUMBER_STATE_KEYS","isRecommended","validity","isNumber","errorable","every","key","errored","includes","defaultGetErrorMessage","_a","isBlurEvent","validationMessage","validateOnChange","keys","length","some"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/form/src/text-field/getErrorMessage.ts"],"sourcesContent":["import type { InputHTMLAttributes } from \"react\";\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport type TextConstraints = Pick<\n  InputHTMLAttributes<HTMLInputElement>,\n  \"pattern\" | \"required\" | \"minLength\" | \"maxLength\"\n>;\n\n/**\n * Since the default validation messages can be verbose, this type is used to\n * configure when/how to display the native browser messages when the validation\n * state changes during the `change` event phase. The validation message will\n * always be shown on blur.\n *\n * When this is:\n *\n * - `true` -&gt; always show the browser message when it exists\n * - `false` -&gt; never show the browser message\n * - `\"recommended\"` -&gt; only shows the browser message if it is not one of the\n *   `RECOMMENDED_IGNORED_KEYS` validation errors\n * - `keyof ValidityState` -&gt; only shows the browser message if it is not the\n *   specific validation error\n * - `(keyof ValidityState)[]` -&gt; only shows the browser message if it is not\n *   the specific validation errors\n *\n * @remarks \\@since 2.5.0\n */\nexport type ChangeValidationBehavior =\n  | boolean\n  | \"recommended\"\n  | \"number-recommended\"\n  | keyof ValidityState\n  | readonly (keyof ValidityState)[];\n\n/**\n * @remarks \\@since 2.5.0\n */\nexport interface ErrorMessageOptions extends TextConstraints {\n  /**\n   * The current input or textarea's validity state.\n   */\n  validity: ValidityState;\n\n  /**\n   * The browser defined validation message based on the validity state. This\n   * will be the empty string when there are no errors.\n   */\n  validationMessage: string;\n\n  /**\n   * The current `TextField` or `TextArea` value.\n   */\n  value: string;\n\n  /**\n   * Boolean if this is triggered from a blur event instead of a change event.\n   */\n  isBlurEvent: boolean;\n\n  /**\n   * The change event validation behavior that is specified in the hook.\n   */\n  validateOnChange: ChangeValidationBehavior;\n}\n\n/**\n * A function to get a custom error message for specific errors. This is really\n * useful when using the `pattern` attribute to give additional information or\n * changing the native \"language translated\" error message.\n *\n * @param options - An object containing metadata that can be used to create an\n * error message for your `TextField` or `TextArea`.\n * @returns An error message to display or an empty string.\n * @remarks \\@since 2.5.0\n */\nexport type GetErrorMessage = (options: ErrorMessageOptions) => string;\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nconst VALIDITY_STATE_KEYS: readonly (keyof ValidityState)[] = [\n  \"badInput\",\n  \"customError\",\n  \"patternMismatch\",\n  \"rangeOverflow\",\n  \"rangeUnderflow\",\n  \"stepMismatch\",\n  \"tooLong\",\n  \"tooShort\",\n  \"typeMismatch\",\n  \"valueMissing\",\n];\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const RECOMMENDED_STATE_KEYS: readonly (keyof ValidityState)[] = [\n  \"badInput\",\n  \"tooLong\",\n  \"valueMissing\",\n];\n\n/**\n * @internal\n * @remarks \\@since 2.5.0\n */\nexport const RECOMMENDED_NUMBER_STATE_KEYS: readonly (keyof ValidityState)[] = [\n  ...RECOMMENDED_STATE_KEYS,\n  \"rangeOverflow\",\n  \"rangeUnderflow\",\n  \"tooShort\",\n  \"typeMismatch\",\n];\n\n/**\n * The validation message is actually kind of weird since it's possible for a\n * form element to have multiple errors at once. The validation message will be\n * the first error that appears, so need to make sure that the first error is\n * one of the recommended state keys so the message appears for only those types\n * of errors.\n *\n * @internal\n * @remarks \\@since 2.5.0\n */\nconst isRecommended = (validity: ValidityState, isNumber: boolean): boolean => {\n  const errorable = isNumber\n    ? RECOMMENDED_NUMBER_STATE_KEYS\n    : RECOMMENDED_STATE_KEYS;\n\n  return VALIDITY_STATE_KEYS.every((key) => {\n    const errored = validity[key];\n    return !errored || errorable.includes(key);\n  });\n};\n\n/**\n * The default implementation for getting an error message for the `TextField`\n * or `TextArea` components that relies on the behavior of the\n * {@link ChangeValidationBehavior}\n *\n * @remarks \\@since 2.5.0\n */\nexport const defaultGetErrorMessage: GetErrorMessage = ({\n  isBlurEvent,\n  validity,\n  validationMessage,\n  validateOnChange,\n}) => {\n  if (isBlurEvent || !validationMessage || validateOnChange === true) {\n    return validationMessage;\n  }\n\n  if (!validateOnChange) {\n    return \"\";\n  }\n\n  if (\n    validateOnChange === \"recommended\" ||\n    validateOnChange === \"number-recommended\"\n  ) {\n    return isRecommended(validity, validateOnChange === \"number-recommended\")\n      ? validationMessage\n      : \"\";\n  }\n\n  const keys =\n    typeof validateOnChange === \"string\"\n      ? [validateOnChange]\n      : validateOnChange;\n\n  return keys.length &&\n    VALIDITY_STATE_KEYS.some((key) => validity[key] && keys.includes(key))\n    ? validationMessage\n    : \"\";\n};\n"]},"metadata":{},"sourceType":"module"}