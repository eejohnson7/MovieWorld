{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { useCallback, useState } from \"react\";\nimport { getViewportSize } from \"@react-md/utils\";\nimport { DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\n/** @internal */\nvar noop = function () {\n  // do nothing\n};\n/**\n * A hook that's used to determine the \"best\" position to render the tooltip\n * within the viewport.\n *\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport function useTooltipPosition(_a) {\n  var determinedPosition = _a.position,\n    _b = _a.defaultPosition,\n    defaultPosition = _b === void 0 ? \"below\" : _b,\n    _c = _a.threshold,\n    threshold = _c === void 0 ? DEFAULT_TOOLTIP_THRESHOLD : _c;\n  var _d = __read(useState(defaultPosition), 2),\n    position = _d[0],\n    setPosition = _d[1];\n  var updatePosition = useCallback(function (container) {\n    var _a = container.getBoundingClientRect(),\n      top = _a.top,\n      left = _a.left;\n    var vh = getViewportSize(\"height\");\n    var vw = getViewportSize(\"width\");\n    var nextPosition = defaultPosition;\n    if (defaultPosition === \"above\" && top < vh * threshold) {\n      nextPosition = \"below\";\n    } else if (defaultPosition === \"below\" && top > vh * threshold) {\n      nextPosition = \"above\";\n    } else if (defaultPosition === \"left\" && left < vw * threshold) {\n      nextPosition = \"right\";\n    } else if (defaultPosition === \"right\" && left > vw * threshold) {\n      nextPosition = \"left\";\n    }\n    setPosition(nextPosition);\n  }, [defaultPosition, threshold]);\n  if (typeof determinedPosition !== \"undefined\") {\n    return [determinedPosition, noop];\n  }\n  return [position, updatePosition];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAW,EAAEC,QAAQ,QAAQ,OAAO;AAE7C,SAASC,eAAe,QAAQ,iBAAiB;AAEjD,SAASC,yBAAyB,QAAQ,aAAa;AAEvD;AACA,IAAMC,IAAI,GAAG;EACX;AACF,CAAC;AAiDD;;;;;;;AAOA,OAAM,SAAUC,kBAAkB,CAACC,EAIN;MAHjBC,kBAAkB;IAC5BC,uBAAyB;IAAzBC,eAAe,mBAAG,OAAO;IACzBC,iBAAqC;IAArCC,SAAS,mBAAGR,yBAAyB;EAE/B,gBAA0BF,QAAQ,CAACQ,eAAe,CAAC;IAAlDG,QAAQ;IAAEC,WAAW,QAA6B;EACzD,IAAMC,cAAc,GAAGd,WAAW,CAChC,UAACe,SAAS;IACF,SAAgBA,SAAS,CAACC,qBAAqB,EAAE;MAA/CC,GAAG;MAAEC,IAAI,UAAsC;IACvD,IAAMC,EAAE,GAAGjB,eAAe,CAAC,QAAQ,CAAC;IACpC,IAAMkB,EAAE,GAAGlB,eAAe,CAAC,OAAO,CAAC;IACnC,IAAImB,YAAY,GAAGZ,eAAe;IAClC,IAAIA,eAAe,KAAK,OAAO,IAAIQ,GAAG,GAAGE,EAAE,GAAGR,SAAS,EAAE;MACvDU,YAAY,GAAG,OAAO;KACvB,MAAM,IAAIZ,eAAe,KAAK,OAAO,IAAIQ,GAAG,GAAGE,EAAE,GAAGR,SAAS,EAAE;MAC9DU,YAAY,GAAG,OAAO;KACvB,MAAM,IAAIZ,eAAe,KAAK,MAAM,IAAIS,IAAI,GAAGE,EAAE,GAAGT,SAAS,EAAE;MAC9DU,YAAY,GAAG,OAAO;KACvB,MAAM,IAAIZ,eAAe,KAAK,OAAO,IAAIS,IAAI,GAAGE,EAAE,GAAGT,SAAS,EAAE;MAC/DU,YAAY,GAAG,MAAM;;IAGvBR,WAAW,CAACQ,YAAY,CAAC;EAC3B,CAAC,EACD,CAACZ,eAAe,EAAEE,SAAS,CAAC,CAC7B;EAED,IAAI,OAAOJ,kBAAkB,KAAK,WAAW,EAAE;IAC7C,OAAO,CAACA,kBAAkB,EAAEH,IAAI,CAAC;;EAGnC,OAAO,CAACQ,QAAQ,EAAEE,cAAc,CAAC;AACnC","names":["useCallback","useState","getViewportSize","DEFAULT_TOOLTIP_THRESHOLD","noop","useTooltipPosition","_a","determinedPosition","_b","defaultPosition","_c","threshold","position","setPosition","updatePosition","container","getBoundingClientRect","top","left","vh","vw","nextPosition"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/tooltip/src/useTooltipPosition.ts"],"sourcesContent":["import { useCallback, useState } from \"react\";\nimport type { SimplePosition } from \"@react-md/utils\";\nimport { getViewportSize } from \"@react-md/utils\";\n\nimport { DEFAULT_TOOLTIP_THRESHOLD } from \"./constants\";\n\n/** @internal */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @remarks \\@since 2.8.0\n */\nexport interface TooltipPositionHookOptions {\n  /**\n   * An optional controlled position to use that will disable the functionality\n   * to determine the \"best\" position to render the tooltip within the viewport.\n   */\n  position?: SimplePosition;\n\n  /**\n   * An optional position to use before the positioning calculation has\n   * occurred. This is also used to determine if the position should be\n   * horizontal vs vertical.\n   *\n   * Vertical - `\"below\"` or `\"above\"`\n   * Horizontal - `\"left\"` or `\"right\"`\n   *\n   * @defaultValue `\"below\"`\n   */\n  defaultPosition?: SimplePosition;\n\n  /**\n   * This value should be between 0 and 1 and will be multiplied by either the\n   * viewport height or viewport width to determine the best position to render\n   * the tooltip based on available space within the viewport.\n   *\n   * You _probably_ won't ever really need to update this value.\n   */\n  threshold?: number;\n}\n\n/**\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport type UpdateTooltipPosition = (container: HTMLElement) => void;\n\n/**\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport type TooltipPositionHookReturnValue = [\n  SimplePosition,\n  UpdateTooltipPosition\n];\n\n/**\n * A hook that's used to determine the \"best\" position to render the tooltip\n * within the viewport.\n *\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport function useTooltipPosition({\n  position: determinedPosition,\n  defaultPosition = \"below\",\n  threshold = DEFAULT_TOOLTIP_THRESHOLD,\n}: TooltipPositionHookOptions): TooltipPositionHookReturnValue {\n  const [position, setPosition] = useState(defaultPosition);\n  const updatePosition = useCallback<UpdateTooltipPosition>(\n    (container) => {\n      const { top, left } = container.getBoundingClientRect();\n      const vh = getViewportSize(\"height\");\n      const vw = getViewportSize(\"width\");\n      let nextPosition = defaultPosition;\n      if (defaultPosition === \"above\" && top < vh * threshold) {\n        nextPosition = \"below\";\n      } else if (defaultPosition === \"below\" && top > vh * threshold) {\n        nextPosition = \"above\";\n      } else if (defaultPosition === \"left\" && left < vw * threshold) {\n        nextPosition = \"right\";\n      } else if (defaultPosition === \"right\" && left > vw * threshold) {\n        nextPosition = \"left\";\n      }\n\n      setPosition(nextPosition);\n    },\n    [defaultPosition, threshold]\n  );\n\n  if (typeof determinedPosition !== \"undefined\") {\n    return [determinedPosition, noop];\n  }\n\n  return [position, updatePosition];\n}\n"]},"metadata":{},"sourceType":"module"}