{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef } from \"react\";\nimport cn from \"classnames\";\nimport { useIcon } from \"@react-md/icon\";\nimport { bem } from \"@react-md/utils\";\nimport { useTableConfig } from \"./config\";\nimport { useTableFooter } from \"./footer\";\nimport { useSticky } from \"./sticky\";\nimport { TableCellContent } from \"./TableCellContent\";\nvar block = bem(\"rmd-table-cell\");\n/**\n * Creates a `<th>` or `<td>` cell with sensible styled defaults. You can create\n * a `<th>` element by enabling the `header` prop OR having a `TableCell` as a\n * child of the `TableHeader` component.\n *\n * Note: If you have a checkbox column in the `TableHeader` without any labels,\n * you will need to manually set the `header={false}` prop for that cell since\n * it is invalid to have a `<th>` without any readable content for screen\n * readers.\n */\nexport var TableCell = forwardRef(function TableCell(_a, ref) {\n  var _b;\n  var sortOrder = _a[\"aria-sort\"],\n    id = _a.id,\n    className = _a.className,\n    _c = _a.grow,\n    grow = _c === void 0 ? false : _c,\n    propScope = _a.scope,\n    propHAlign = _a.hAlign,\n    propVAlign = _a.vAlign,\n    propHeader = _a.header,\n    propDisableLineWrap = _a.lineWrap,\n    children = _a.children,\n    propSticky = _a.sticky,\n    propSortIcon = _a.sortIcon,\n    _d = _a.sortIconAfter,\n    sortIconAfter = _d === void 0 ? false : _d,\n    sortIconRotated = _a.sortIconRotated,\n    disablePadding = _a.disablePadding,\n    propColSpan = _a.colSpan,\n    props = __rest(_a, [\"aria-sort\", \"id\", \"className\", \"grow\", \"scope\", \"hAlign\", \"vAlign\", \"header\", \"lineWrap\", \"children\", \"sticky\", \"sortIcon\", \"sortIconAfter\", \"sortIconRotated\", \"disablePadding\", \"colSpan\"]);\n  // have to double cast to get the `100%` value to work.\n  var colSpan = propColSpan;\n  var sortIcon = useIcon(\"sort\", propSortIcon);\n  var isNoPadding = disablePadding !== null && disablePadding !== void 0 ? disablePadding : sortIcon && sortOrder;\n  // Note: unlike the other usages of `useTableConfig`, the `propHeader`\n  // is not provided. This is so that `TableCheckbox` components can still\n  // be a sticky header without being rendered as a `<th>`. This also makes\n  // it so the scope can be defaulted to `col` or `row` automatically.\n  var _e = useTableConfig({\n      hAlign: propHAlign,\n      vAlign: propVAlign,\n      lineWrap: propDisableLineWrap\n    }),\n    inheritedHeader = _e.header,\n    hAlign = _e.hAlign,\n    vAlign = _e.vAlign,\n    lineWrap = _e.lineWrap;\n  var header = propHeader !== null && propHeader !== void 0 ? propHeader : inheritedHeader;\n  var footer = useTableFooter();\n  var sticky = useSticky(propSticky);\n  var isStickyCell = propSticky === \"cell\" || !header && sticky;\n  var isStickyHeader = propSticky === \"header\";\n  var isStickyFooter = sticky && footer;\n  var isStickyFooterCell = isStickyFooter && (propColSpan === \"100%\" || propColSpan === 0);\n  var isStickyAbove = propSticky === \"header-cell\" || isStickyFooterCell;\n  var scope = propScope;\n  if (!scope && header) {\n    scope = !inheritedHeader && propHeader ? \"row\" : \"col\";\n  }\n  var Component = header ? \"th\" : \"td\";\n  return _jsx(Component, __assign({}, props, {\n    ref: ref,\n    id: id,\n    \"aria-sort\": sortOrder === \"none\" ? undefined : sortOrder,\n    colSpan: colSpan,\n    className: cn(block((_b = {\n      grow: grow,\n      header: header,\n      sticky: sticky,\n      \"sticky-header\": header && sticky && propSticky !== \"cell\" || isStickyHeader || isStickyAbove,\n      \"sticky-cell\": isStickyCell || isStickyAbove || isStickyFooterCell,\n      \"sticky-footer\": isStickyFooter,\n      \"sticky-above\": isStickyAbove\n    }, _b[hAlign] = hAlign !== \"left\", _b[vAlign] = vAlign !== \"middle\", _b.vertical = vAlign !== \"middle\", _b[\"no-wrap\"] = !lineWrap, _b.padded = !isNoPadding && lineWrap === \"padded\", _b[\"no-padding\"] = isNoPadding, _b)), className),\n    scope: scope\n  }, {\n    children: _jsx(TableCellContent, __assign({\n      id: id ? \"\".concat(id, \"-sort\") : undefined,\n      icon: sortIcon,\n      iconAfter: sortIconAfter,\n      sortOrder: sortOrder,\n      rotated: sortIconRotated,\n      hAlign: hAlign\n    }, {\n      children: children\n    }))\n  }));\n});","map":{"version":3,"mappings":"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","names":["forwardRef","cn","useIcon","bem","useTableConfig","useTableFooter","useSticky","TableCellContent","block","TableCell","_a","ref","sortOrder","id","className","_c","grow","propScope","propHAlign","propVAlign","propHeader","propDisableLineWrap","children","propSticky","propSortIcon","_d","sortIconAfter","sortIconRotated","disablePadding","propColSpan","props","colSpan","sortIcon","isNoPadding","hAlign","vAlign","lineWrap","inheritedHeader","header","footer","sticky","isStickyCell","isStickyHeader","isStickyFooter","isStickyFooterCell","isStickyAbove","scope","Component","_jsx","undefined","_b","icon","iconAfter","rotated"],"sources":["/Users/erin/Desktop/finalProg/node_modules/@react-md/table/src/TableCell.tsx"],"sourcesContent":["import type { ReactNode, TdHTMLAttributes, ThHTMLAttributes } from \"react\";\nimport { forwardRef } from \"react\";\nimport cn from \"classnames\";\nimport { useIcon } from \"@react-md/icon\";\nimport { bem } from \"@react-md/utils\";\n\nimport type { TableCellConfig } from \"./config\";\nimport { useTableConfig } from \"./config\";\nimport { useTableFooter } from \"./footer\";\nimport { useSticky } from \"./sticky\";\nimport type { SortOrder } from \"./TableCellContent\";\nimport { TableCellContent } from \"./TableCellContent\";\n\nexport type TableCellAttributes = Omit<\n  | TdHTMLAttributes<HTMLTableCellElement>\n  | ThHTMLAttributes<HTMLTableCellElement>,\n  \"colSpan\" | \"scope\"\n>;\n\nexport interface TableCellOptions extends TableCellConfig {\n  /**\n   * This is a bit of a \"weird\" prop since all it does is apply `width: 100%` to\n   * this cell. This will make this specific cell fill the remaining width of\n   * the table (if there is any). If no cells have this prop enabled and the\n   * `fullWidth` table configuration is enabled, all cells will have an\n   * equal-sized width.\n   */\n  grow?: boolean;\n\n  /**\n   * This prop is only valid when the `header` prop is enabled or the\n   * `TableCell` is a child of the `TableHeader` component. This will generally\n   * be used with a value of `\"row\"` if you have table headers that are at the\n   * start of each row instead of at the top of the table.\n   */\n  scope?: \"row\" | \"col\" | \"rowgroup\" | \"colgroup\";\n\n  /**\n   * The number of columns that the cell should span. If you would like a cell\n   * to span an entire row ignoring the other rows and cells, you can set this\n   * value to the number of columns within your table or `\"100%\"`.\n   */\n  colSpan?: number | \"100%\";\n\n  /**\n   * If this is a trueish value, the cell will become a sticky cell that will be\n   * fixed while the user scrolls the table. When this is a `boolean` (or\n   * inherited from a `TableHeader`) or set to `\"header\"`, the cell will act as\n   * a sticky header that will be visible for vertical scrolling.\n   *\n   * When this is set to `\"cell\"`, the cell will be fixed to the left or right\n   * for horizontal scrolling.\n   *\n   * Finally, if this is set to `\"header-cell\"`, it will be a combination of\n   * both vertical and horizontal scrolling. This means that other sticky header\n   * cells will scroll beneath this cell.\n   */\n  sticky?: boolean | \"header\" | \"cell\" | \"header-cell\";\n}\n\nexport interface TableCellProps extends TableCellAttributes, TableCellOptions {\n  /**\n   * If you want to apply a sort icon for a header cell, set this prop to either\n   * `\"ascending\"` or `\"descending\"`. When you change the sort order, this prop\n   * should change as well which will cause the sort icon to rotate. The default\n   * behavior is to have the icon facing upwards and not-rotated when\n   * `\"ascending\"`, otherwise it will rotate downwards when `\"descending\"`.\n   *\n   * If this prop is set to `\"none\"`, the cell will render the clickable button\n   * in the children, just without the sort icon. This is so that the sort\n   * behavior can still be toggled for keyboard users and will be tab-focusable.\n   */\n  \"aria-sort\"?: SortOrder;\n\n  /**\n   * An optional sort icon to use. This will be defaulted to the configured sort\n   * icon from the `@react-md/icon` package. If you do not want the default\n   * implementation for the sort icon behavior from `react-md`, you can set this\n   * prop to `null`.\n   */\n  sortIcon?: ReactNode;\n\n  /**\n   * Boolean if the sort icon should appear after the children in the cell\n   * instead of before.\n   */\n  sortIconAfter?: boolean;\n\n  /**\n   * Boolean if the sort icon should be rotated instead of the default\n   * direction. When this is `undefined`, it will only be `true` when the\n   * `\"aria-sort\"` prop is set to `\"descending\"`. If this is not `undefined`,\n   * its boolean value will always be used.\n   */\n  sortIconRotated?: boolean;\n\n  /**\n   * Boolean if cell should no longer have any padding since you want a child\n   * element to span the entire size of the cell instead. This is helpful when\n   * rendering clickable and focusable elements within a cell.\n   *\n   * This will be defaulted to `true` if the `\"aria-sort\"` prop has been\n   * provided and the `sortIcon` is not resoled as `null`. You can override this\n   * default behavior by manually setting this to `true` or `false`.\n   */\n  disablePadding?: boolean;\n}\n\nconst block = bem(\"rmd-table-cell\");\n\n/**\n * Creates a `<th>` or `<td>` cell with sensible styled defaults. You can create\n * a `<th>` element by enabling the `header` prop OR having a `TableCell` as a\n * child of the `TableHeader` component.\n *\n * Note: If you have a checkbox column in the `TableHeader` without any labels,\n * you will need to manually set the `header={false}` prop for that cell since\n * it is invalid to have a `<th>` without any readable content for screen\n * readers.\n */\nexport const TableCell = forwardRef<HTMLTableCellElement, TableCellProps>(\n  function TableCell(\n    {\n      \"aria-sort\": sortOrder,\n      id,\n      className,\n      grow = false,\n      scope: propScope,\n      hAlign: propHAlign,\n      vAlign: propVAlign,\n      header: propHeader,\n      lineWrap: propDisableLineWrap,\n      children,\n      sticky: propSticky,\n      sortIcon: propSortIcon,\n      sortIconAfter = false,\n      sortIconRotated,\n      disablePadding,\n      colSpan: propColSpan,\n      ...props\n    },\n    ref\n  ) {\n    // have to double cast to get the `100%` value to work.\n    const colSpan = propColSpan as unknown as number;\n    const sortIcon = useIcon(\"sort\", propSortIcon);\n    const isNoPadding = disablePadding ?? (sortIcon && sortOrder);\n\n    // Note: unlike the other usages of `useTableConfig`, the `propHeader`\n    // is not provided. This is so that `TableCheckbox` components can still\n    // be a sticky header without being rendered as a `<th>`. This also makes\n    // it so the scope can be defaulted to `col` or `row` automatically.\n    const {\n      header: inheritedHeader,\n      hAlign,\n      vAlign,\n      lineWrap,\n    } = useTableConfig({\n      hAlign: propHAlign,\n      vAlign: propVAlign,\n      lineWrap: propDisableLineWrap,\n    });\n    const header = propHeader ?? inheritedHeader;\n    const footer = useTableFooter();\n    const sticky = useSticky(propSticky);\n    const isStickyCell = propSticky === \"cell\" || (!header && sticky);\n    const isStickyHeader = propSticky === \"header\";\n    const isStickyFooter = sticky && footer;\n    const isStickyFooterCell =\n      isStickyFooter && (propColSpan === \"100%\" || propColSpan === 0);\n    const isStickyAbove = propSticky === \"header-cell\" || isStickyFooterCell;\n\n    let scope = propScope;\n    if (!scope && header) {\n      scope = !inheritedHeader && propHeader ? \"row\" : \"col\";\n    }\n\n    const Component = header ? \"th\" : \"td\";\n    return (\n      <Component\n        {...props}\n        ref={ref}\n        id={id}\n        aria-sort={sortOrder === \"none\" ? undefined : sortOrder}\n        colSpan={colSpan}\n        className={cn(\n          block({\n            grow,\n            header,\n            sticky,\n            \"sticky-header\":\n              (header && sticky && propSticky !== \"cell\") ||\n              isStickyHeader ||\n              isStickyAbove,\n            \"sticky-cell\": isStickyCell || isStickyAbove || isStickyFooterCell,\n            \"sticky-footer\": isStickyFooter,\n            \"sticky-above\": isStickyAbove,\n            [hAlign]: hAlign !== \"left\",\n            [vAlign]: vAlign !== \"middle\",\n            vertical: vAlign !== \"middle\",\n            \"no-wrap\": !lineWrap,\n            padded: !isNoPadding && lineWrap === \"padded\",\n            \"no-padding\": isNoPadding,\n          }),\n          className\n        )}\n        scope={scope}\n      >\n        <TableCellContent\n          id={id ? `${id}-sort` : undefined}\n          icon={sortIcon}\n          iconAfter={sortIconAfter}\n          sortOrder={sortOrder}\n          rotated={sortIconRotated}\n          hAlign={hAlign}\n        >\n          {children}\n        </TableCellContent>\n      </Component>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module"}